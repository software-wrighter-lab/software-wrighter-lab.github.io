<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://software-wrighter-lab.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://software-wrighter-lab.github.io/" rel="alternate" type="text/html" /><updated>2026-02-24T10:26:15-08:00</updated><id>https://software-wrighter-lab.github.io/feed.xml</id><title type="html">Software Wrighter Lab Blog</title><subtitle>AI coding agents, systems programming, and practical machine learning</subtitle><author><name>Mike Wright</name></author><entry><title type="html">How AI Learns Part 1: The Many Meanings of Learning</title><link href="https://software-wrighter-lab.github.io/2026/02/24/how-ai-learns-part1-time-scales/" rel="alternate" type="text/html" title="How AI Learns Part 1: The Many Meanings of Learning" /><published>2026-02-24T08:00:00-08:00</published><updated>2026-02-24T08:00:00-08:00</updated><id>https://software-wrighter-lab.github.io/2026/02/24/how-ai-learns-part1-time-scales</id><content type="html" xml:base="https://software-wrighter-lab.github.io/2026/02/24/how-ai-learns-part1-time-scales/"><![CDATA[<p><img src="/assets/images/posts/block-lamp-post.png" class="post-marker" alt="" /></p>

<p>When people say, “AI learned something,” they usually mean one of at least four very different things.</p>

<p>Large Language Models (LLMs) do not learn in one single way. They learn at different time scales, in different locations, and with very different consequences. To understand modern AI systems—especially agents—we need to separate these layers.</p>

<div class="resource-box">

  <table>
    <thead>
      <tr>
        <th>Resource</th>
        <th>Link</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Series</strong></td>
        <td><a href="/series/#how-ai-learns">How AI Learns</a></td>
      </tr>
    </tbody>
  </table>

</div>

<h2 id="four-time-scales-of-learning">Four Time Scales of Learning</h2>

<figure>
<img src="/assets/images/posts/learning-time-scales.svg" alt="Concentric rings showing four time scales of learning: core weights, adapters, external memory, and prompt/context" style="max-width: 600px; margin: 0 auto; display: block;" />
<figcaption style="text-align: center; font-style: italic; margin-top: 0.5em;">Learning happens at different layers with different persistence and speed.</figcaption>
</figure>

<h3 id="1-pretraining-years">1. Pretraining (Years)</h3>

<p>This is the foundation.</p>

<p>The model trains on massive datasets using gradient descent. The result is a set of weights—billions of parameters—encoding statistical structure of language and knowledge.</p>

<p>This learning:</p>
<ul>
  <li>Is slow and expensive</li>
  <li>Persists across restarts</li>
  <li>Cannot easily be reversed</li>
  <li>Is vulnerable to interference if modified later</li>
</ul>

<p>Think of this as <strong>long-term biological memory</strong>.</p>

<h3 id="2-fine-tuning-days-to-weeks">2. Fine-Tuning (Days to Weeks)</h3>

<p>Fine-tuning modifies the weights further, but with narrower data.</p>

<p>This includes:</p>
<ul>
  <li><strong>Instruction tuning</strong> (following directions)</li>
  <li><strong>Alignment methods</strong> (RLHF, DPO)</li>
  <li><strong>Domain adaptation</strong></li>
  <li><strong>Parameter-efficient methods</strong> like LoRA</li>
</ul>

<p>This is still weight-based learning.</p>

<p>It persists across restarts. It risks <strong>catastrophic forgetting</strong>. It modifies the brain itself.</p>

<h3 id="3-memory-based-learning-seconds-to-minutes">3. Memory-Based Learning (Seconds to Minutes)</h3>

<p>This is where many modern systems shift.</p>

<p>Instead of changing weights, they store information externally:</p>
<ul>
  <li><strong>RAG</strong> (Retrieval-Augmented Generation)</li>
  <li><strong>CAG</strong> (Cache-Augmented Generation)</li>
  <li><strong>Vector databases</strong></li>
  <li><strong>Engram-style memory modules</strong></li>
</ul>

<p>The model retrieves relevant memory per query.</p>

<p><strong>The brain stays stable. The notebook grows.</strong></p>

<p>This learning:</p>
<ul>
  <li>Persists across restarts</li>
  <li>Survives model upgrades</li>
  <li>Does not cause forgetting</li>
  <li>Is fast</li>
</ul>

<h3 id="4-in-context-learning-milliseconds">4. In-Context Learning (Milliseconds)</h3>

<p>This is temporary reasoning scaffolding.</p>

<p>Information exists only in the prompt window.</p>

<p>It:</p>
<ul>
  <li>Does not update weights</li>
  <li>Does not persist across sessions</li>
  <li>Is powerful but fragile</li>
  <li>Suffers from <strong>context rot</strong></li>
</ul>

<p>This is <strong>working memory</strong>.</p>

<h2 id="why-this-matters">Why This Matters</h2>

<p>Most discussions collapse all of this into “the model learned.”</p>

<p>But:</p>
<ul>
  <li><strong>Updating weights</strong> risks forgetting</li>
  <li><strong>Updating memory</strong> does not</li>
  <li><strong>Updating prompts</strong> does not persist</li>
  <li><strong>Updating adapters</strong> can be modular and reversible</li>
</ul>

<p>Continuous learning systems must coordinate all four.</p>

<h2 id="persistence-comparison">Persistence Comparison</h2>

<table>
  <thead>
    <tr>
      <th>Mechanism</th>
      <th>Persists Across Chat?</th>
      <th>Persists Across Restart?</th>
      <th>Persists Across Model Change?</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Pretraining</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>No</td>
    </tr>
    <tr>
      <td>Fine-tune</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>No</td>
    </tr>
    <tr>
      <td>LoRA</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Usually</td>
    </tr>
    <tr>
      <td>Distillation</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>No</td>
    </tr>
    <tr>
      <td>ICL</td>
      <td>No</td>
      <td>No</td>
      <td>No</td>
    </tr>
    <tr>
      <td>RAG</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>Engram</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>CAG</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Yes</td>
    </tr>
  </tbody>
</table>

<p>That last column is subtle but powerful for agents.</p>

<h2 id="coming-next">Coming Next</h2>

<p>In Part 2, we’ll examine the two fundamental failure modes that arise from confusing these layers: <strong>catastrophic forgetting</strong> and <strong>context rot</strong>.</p>

<hr />

<p><em>Learning happens in layers of permanence.</em></p>]]></content><author><name>Software Wrighter</name></author><category term="machine-learning" /><category term="ai-agents" /><category term="llm" /><category term="learning" /><category term="pretraining" /><category term="fine-tuning" /><category term="rag" /><category term="in-context-learning" /><category term="continuous-learning" /><summary type="html"><![CDATA[When people say, “AI learned something,” they usually mean one of at least four very different things. Large Language Models (LLMs) do not learn in one single way. They learn at different time scales, in different locations, and with very different consequences. To understand modern AI systems—especially agents—we need to separate these layers. Resource Link Series How AI Learns Four Time Scales of Learning Learning happens at different layers with different persistence and speed. 1. Pretraining (Years) This is the foundation. The model trains on massive datasets using gradient descent. The result is a set of weights—billions of parameters—encoding statistical structure of language and knowledge. This learning: Is slow and expensive Persists across restarts Cannot easily be reversed Is vulnerable to interference if modified later Think of this as long-term biological memory. 2. Fine-Tuning (Days to Weeks) Fine-tuning modifies the weights further, but with narrower data. This includes: Instruction tuning (following directions) Alignment methods (RLHF, DPO) Domain adaptation Parameter-efficient methods like LoRA This is still weight-based learning. It persists across restarts. It risks catastrophic forgetting. It modifies the brain itself. 3. Memory-Based Learning (Seconds to Minutes) This is where many modern systems shift. Instead of changing weights, they store information externally: RAG (Retrieval-Augmented Generation) CAG (Cache-Augmented Generation) Vector databases Engram-style memory modules The model retrieves relevant memory per query. The brain stays stable. The notebook grows. This learning: Persists across restarts Survives model upgrades Does not cause forgetting Is fast 4. In-Context Learning (Milliseconds) This is temporary reasoning scaffolding. Information exists only in the prompt window. It: Does not update weights Does not persist across sessions Is powerful but fragile Suffers from context rot This is working memory. Why This Matters Most discussions collapse all of this into “the model learned.” But: Updating weights risks forgetting Updating memory does not Updating prompts does not persist Updating adapters can be modular and reversible Continuous learning systems must coordinate all four. Persistence Comparison Mechanism Persists Across Chat? Persists Across Restart? Persists Across Model Change? Pretraining Yes Yes No Fine-tune Yes Yes No LoRA Yes Yes Usually Distillation Yes Yes No ICL No No No RAG Yes Yes Yes Engram Yes Yes Yes CAG Yes Yes Yes That last column is subtle but powerful for agents. Coming Next In Part 2, we’ll examine the two fundamental failure modes that arise from confusing these layers: catastrophic forgetting and context rot. Learning happens in layers of permanence.]]></summary></entry><entry><title type="html">Five ML Concepts - #21</title><link href="https://software-wrighter-lab.github.io/2026/02/24/five-ml-concepts-21/" rel="alternate" type="text/html" title="Five ML Concepts - #21" /><published>2026-02-24T00:00:00-08:00</published><updated>2026-02-24T00:00:00-08:00</updated><id>https://software-wrighter-lab.github.io/2026/02/24/five-ml-concepts-21</id><content type="html" xml:base="https://software-wrighter-lab.github.io/2026/02/24/five-ml-concepts-21/"><![CDATA[<p><img src="/assets/images/posts/block-21.png" class="post-marker" alt="" /></p>

<p>5 machine learning concepts. Under 30 seconds each.</p>

<div class="resource-box">

  <table>
    <thead>
      <tr>
        <th>Resource</th>
        <th>Link</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Papers</strong></td>
        <td>Links in References section</td>
      </tr>
      <tr>
        <td><strong>Video</strong></td>
        <td><a href="https://www.youtube.com/shorts/P8OO48Nu6ik">Five ML Concepts #21</a><br /><a href="https://www.youtube.com/shorts/P8OO48Nu6ik"><img src="https://img.youtube.com/vi/P8OO48Nu6ik/mqdefault.jpg" alt="Video" class="video-thumb" /></a></td>
      </tr>
    </tbody>
  </table>

</div>

<div class="references-section">

  <h2 id="references">References</h2>

  <table>
    <thead>
      <tr>
        <th>Concept</th>
        <th>Reference</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Prompt Injection</strong></td>
        <td><a href="https://arxiv.org/abs/2306.05499">Prompt Injection attack against LLM-integrated Applications</a> (Liu et al. 2023)</td>
      </tr>
      <tr>
        <td><strong>Jailbreaks</strong></td>
        <td><a href="https://arxiv.org/abs/2307.02483">Jailbroken: How Does LLM Safety Training Fail?</a> (Wei et al. 2023)</td>
      </tr>
      <tr>
        <td><strong>GRU</strong></td>
        <td><a href="https://arxiv.org/abs/1412.3555">Empirical Evaluation of Gated Recurrent Neural Networks</a> (Chung et al. 2014)</td>
      </tr>
      <tr>
        <td><strong>Planning vs Prediction</strong></td>
        <td><a href="https://arxiv.org/abs/2310.02029">Between accurate prediction and poor decision making</a> (Zaffalon et al. 2023)</td>
      </tr>
      <tr>
        <td><strong>Production Rollbacks</strong></td>
        <td>MLOps best practice (no canonical paper)</td>
      </tr>
    </tbody>
  </table>

</div>

<h2 id="todays-five">Today’s Five</h2>

<h3 id="1-prompt-injection">1. Prompt Injection</h3>

<p><strong>Malicious instructions embedded in user input that override intended system behavior.</strong> An attacker crafts text that tricks an AI into ignoring its original instructions.</p>

<p>This is a major security concern for LLM-integrated applications.</p>

<blockquote>
  <p>Like slipping a forged instruction into a trusted document.</p>
</blockquote>

<h3 id="2-jailbreaks">2. Jailbreaks</h3>

<p><strong>Techniques that attempt to bypass safety constraints in AI systems.</strong> These attacks exploit gaps between a model’s capabilities and its safety training.</p>

<p>Safety training can fail due to competing objectives or mismatched generalization.</p>

<blockquote>
  <p>Like convincing a guard to bend the rules.</p>
</blockquote>

<h3 id="3-gru-gated-recurrent-unit">3. GRU (Gated Recurrent Unit)</h3>

<p><strong>A recurrent neural network unit with gates that control memory flow.</strong> GRUs decide what information to keep and what to discard at each time step.</p>

<p>Simpler than LSTM but designed for similar sequence modeling tasks.</p>

<blockquote>
  <p>Like a notepad where you decide what to keep and what to erase.</p>
</blockquote>

<h3 id="4-planning-vs-prediction">4. Planning vs Prediction</h3>

<p><strong>Prediction forecasts likely outcomes. Planning evaluates actions across possible futures.</strong> Accurate predictions don’t guarantee good decisions—you also need to model how actions affect outcomes.</p>

<p>This is a key gap in many AI/ML systems.</p>

<blockquote>
  <p>Like knowing it will rain versus deciding whether to bring an umbrella.</p>
</blockquote>

<h3 id="5-production-rollbacks">5. Production Rollbacks</h3>

<p><strong>Reverting to a previous stable model version after deployment issues.</strong> When a new model causes problems in production, rolling back quickly minimizes impact.</p>

<p>Essential MLOps practice for maintaining system reliability.</p>

<blockquote>
  <p>Like reloading a saved game state when something breaks.</p>
</blockquote>

<h2 id="quick-reference">Quick Reference</h2>

<table>
  <thead>
    <tr>
      <th>Concept</th>
      <th>One-liner</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Prompt Injection</strong></td>
      <td>Malicious instructions overriding AI behavior</td>
    </tr>
    <tr>
      <td><strong>Jailbreaks</strong></td>
      <td>Bypassing safety constraints</td>
    </tr>
    <tr>
      <td><strong>GRU</strong></td>
      <td>Gated memory for sequence modeling</td>
    </tr>
    <tr>
      <td><strong>Planning vs Prediction</strong></td>
      <td>Action evaluation vs forecasting</td>
    </tr>
    <tr>
      <td><strong>Production Rollbacks</strong></td>
      <td>Reverting to stable model versions</td>
    </tr>
  </tbody>
</table>

<hr />

<table>
  <tbody>
    <tr>
      <td>*Part 21 of the Five ML Concepts series. <a href="/series/#five-ml-concepts">View all parts</a></td>
      <td><a href="/2026/02/23/five-ml-concepts-20/">← Previous: #20</a>*</td>
    </tr>
  </tbody>
</table>

<p><em>Short, accurate ML explainers. Follow for more.</em></p>]]></content><author><name>Software Wrighter</name></author><category term="llm" /><category term="machine-learning" /><category term="explainers" /><category term="five-ml-concepts" /><category term="prompt-injection" /><category term="jailbreaks" /><category term="gru" /><category term="planning" /><category term="prediction" /><category term="mlops" /><category term="ml-concepts" /><summary type="html"><![CDATA[5 machine learning concepts. Under 30 seconds each. Resource Link Papers Links in References section Video Five ML Concepts #21 References Concept Reference Prompt Injection Prompt Injection attack against LLM-integrated Applications (Liu et al. 2023) Jailbreaks Jailbroken: How Does LLM Safety Training Fail? (Wei et al. 2023) GRU Empirical Evaluation of Gated Recurrent Neural Networks (Chung et al. 2014) Planning vs Prediction Between accurate prediction and poor decision making (Zaffalon et al. 2023) Production Rollbacks MLOps best practice (no canonical paper) Today’s Five 1. Prompt Injection Malicious instructions embedded in user input that override intended system behavior. An attacker crafts text that tricks an AI into ignoring its original instructions. This is a major security concern for LLM-integrated applications. Like slipping a forged instruction into a trusted document. 2. Jailbreaks Techniques that attempt to bypass safety constraints in AI systems. These attacks exploit gaps between a model’s capabilities and its safety training. Safety training can fail due to competing objectives or mismatched generalization. Like convincing a guard to bend the rules. 3. GRU (Gated Recurrent Unit) A recurrent neural network unit with gates that control memory flow. GRUs decide what information to keep and what to discard at each time step. Simpler than LSTM but designed for similar sequence modeling tasks. Like a notepad where you decide what to keep and what to erase. 4. Planning vs Prediction Prediction forecasts likely outcomes. Planning evaluates actions across possible futures. Accurate predictions don’t guarantee good decisions—you also need to model how actions affect outcomes. This is a key gap in many AI/ML systems. Like knowing it will rain versus deciding whether to bring an umbrella. 5. Production Rollbacks Reverting to a previous stable model version after deployment issues. When a new model causes problems in production, rolling back quickly minimizes impact. Essential MLOps practice for maintaining system reliability. Like reloading a saved game state when something breaks. Quick Reference Concept One-liner Prompt Injection Malicious instructions overriding AI behavior Jailbreaks Bypassing safety constraints GRU Gated memory for sequence modeling Planning vs Prediction Action evaluation vs forecasting Production Rollbacks Reverting to stable model versions *Part 21 of the Five ML Concepts series. View all parts ← Previous: #20* Short, accurate ML explainers. Follow for more.]]></summary></entry><entry><title type="html">music-pipe-rs: Unix Pipelines for MIDI Composition</title><link href="https://software-wrighter-lab.github.io/2026/02/24/music-pipe-rs-unix-pipelines-for-midi/" rel="alternate" type="text/html" title="music-pipe-rs: Unix Pipelines for MIDI Composition" /><published>2026-02-24T00:00:00-08:00</published><updated>2026-02-24T00:00:00-08:00</updated><id>https://software-wrighter-lab.github.io/2026/02/24/music-pipe-rs-unix-pipelines-for-midi</id><content type="html" xml:base="https://software-wrighter-lab.github.io/2026/02/24/music-pipe-rs-unix-pipelines-for-midi/"><![CDATA[<p><img src="/assets/images/posts/block-ship.png" class="post-marker" alt="" /></p>

<p>After building midi-cli-rs for quick mood-based generation, I wanted something more surgical. What if music generation worked like Unix commands—small tools connected by pipes?</p>

<div class="resource-box">

  <table>
    <thead>
      <tr>
        <th>Resource</th>
        <th>Link</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Code</strong></td>
        <td><a href="https://github.com/softwarewrighter/music-pipe-rs">music-pipe-rs</a></td>
      </tr>
      <tr>
        <td><strong>Related</strong></td>
        <td><a href="/2026/02/20/midi-cli-rs-music-for-ai-agents/">midi-cli-rs</a></td>
      </tr>
    </tbody>
  </table>

</div>

<h2 id="the-unix-philosophy-for-music">The Unix Philosophy for Music</h2>

<p>Most generative music tools are monolithic. You get one application with a closed workflow. If you want to inspect intermediate results, you can’t. If you want to swap one transformation for another, you rebuild everything.</p>

<p>Unix solved this decades ago: small tools that do one thing well, connected by pipes. Each tool reads from stdin, writes to stdout. You can inspect any point in the pipeline with <code class="language-plaintext highlighter-rouge">head</code>, filter with <code class="language-plaintext highlighter-rouge">grep</code>, transform with <code class="language-plaintext highlighter-rouge">jq</code>.</p>

<p>music-pipe-rs applies this philosophy to MIDI composition.</p>

<h2 id="a-pipeline-in-action">A Pipeline in Action</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>seed 12345 | motif <span class="nt">--notes</span> 16 <span class="nt">--bpm</span> 120 | humanize | to-midi <span class="nt">--out</span> melody.mid
</code></pre></div></div>

<p>Four stages:</p>
<ol>
  <li><strong>seed</strong> establishes the random seed for the entire pipeline</li>
  <li><strong>motif</strong> generates a melodic pattern (using the pipeline seed)</li>
  <li><strong>humanize</strong> adds timing and velocity variation (using the same seed)</li>
  <li><strong>to-midi</strong> converts the event stream to a standard .mid file</li>
</ol>

<p>The output plays in any DAW.</p>

<h2 id="seed-first-architecture">Seed-First Architecture</h2>

<p>The <code class="language-plaintext highlighter-rouge">seed</code> stage goes at the head of the pipeline:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Explicit seed for reproducibility</span>
seed 12345 | motif <span class="nt">--notes</span> 16 | humanize | to-midi <span class="nt">--out</span> melody.mid

<span class="c"># Auto-generated seed (printed to stderr)</span>
seed | motif <span class="nt">--notes</span> 16 | humanize | to-midi <span class="nt">--out</span> melody.mid
<span class="c"># stderr: seed: 1708732845</span>
</code></pre></div></div>

<p>All downstream stages read the seed from the event stream. No <code class="language-plaintext highlighter-rouge">--seed</code> arguments scattered across the pipeline. One seed, set once, used everywhere.</p>

<p>This means:</p>
<ul>
  <li><strong>Same seed = identical output</strong> across all random stages</li>
  <li><strong>Different seed = different composition</strong> with same structure</li>
  <li><strong>Reproducibility is trivial</strong>: just save the seed number</li>
</ul>

<h2 id="jsonl-the-intermediate-format">JSONL: The Intermediate Format</h2>

<p>Between stages, events flow as JSONL (JSON Lines). Each line is a complete event:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"type"</span><span class="p">:</span><span class="s2">"Seed"</span><span class="p">,</span><span class="nl">"seed"</span><span class="p">:</span><span class="mi">12345</span><span class="p">}</span><span class="w">
</span><span class="p">{</span><span class="nl">"type"</span><span class="p">:</span><span class="s2">"NoteOn"</span><span class="p">,</span><span class="nl">"t"</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="nl">"ch"</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="nl">"key"</span><span class="p">:</span><span class="mi">60</span><span class="p">,</span><span class="nl">"vel"</span><span class="p">:</span><span class="mi">80</span><span class="p">}</span><span class="w">
</span><span class="p">{</span><span class="nl">"type"</span><span class="p">:</span><span class="s2">"NoteOff"</span><span class="p">,</span><span class="nl">"t"</span><span class="p">:</span><span class="mi">480</span><span class="p">,</span><span class="nl">"ch"</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="nl">"key"</span><span class="p">:</span><span class="mi">60</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>This format is human-readable and tool-friendly:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># See the first 10 events</span>
seed 42 | motif <span class="nt">--notes</span> 8 | <span class="nb">head</span> <span class="nt">-10</span>

<span class="c"># Count how many NoteOn events</span>
seed 42 | motif <span class="nt">--notes</span> 16 | <span class="nb">grep </span>NoteOn | <span class="nb">wc</span> <span class="nt">-l</span>

<span class="c"># Pretty-print with jq</span>
seed 42 | motif <span class="nt">--notes</span> 4 | jq <span class="nb">.</span>
</code></pre></div></div>

<p>No binary formats to decode. No proprietary protocols. Just text.</p>

<h2 id="visualization-with-viz">Visualization with viz</h2>

<p>The <code class="language-plaintext highlighter-rouge">viz</code> stage prints a sparkline to stderr while passing events through:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>seed 12345 | motif <span class="nt">--notes</span> 16 | viz | humanize | to-midi <span class="nt">--out</span> melody.mid
</code></pre></div></div>

<p>Output on stderr:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>▃▅▇▅▃▁▂▄▆▇▆▄▂▁▃▅
</code></pre></div></div>

<p>For more detail, use piano roll mode:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>seed 12345 | motif <span class="nt">--notes</span> 16 | viz <span class="nt">--roll</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> G6 │···█············│
F#6 │·····█··········│
 F6 │····█···········│
 G5 │·██·········█···│
 F5 │···········█····│
 E5 │·········██···█·│
 C5 │█·····███····█·█│
</code></pre></div></div>

<p>The visualization goes to stderr; the JSONL events continue to stdout. You can inspect the music without breaking the pipeline.</p>

<h2 id="available-stages">Available Stages</h2>

<table>
  <thead>
    <tr>
      <th>Stage</th>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">seed</code></td>
      <td>Start</td>
      <td>Establish random seed for pipeline</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">motif</code></td>
      <td>Generate</td>
      <td>Create melodic patterns</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">euclid</code></td>
      <td>Generate</td>
      <td>Euclidean rhythm generation</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">transpose</code></td>
      <td>Transform</td>
      <td>Shift notes by semitones</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">scale</code></td>
      <td>Transform</td>
      <td>Constrain notes to a scale</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">humanize</code></td>
      <td>Transform</td>
      <td>Add timing/velocity variation</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">viz</code></td>
      <td>Inspect</td>
      <td>Print sparkline visualization</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">to-midi</code></td>
      <td>Output</td>
      <td>Convert to .mid file</td>
    </tr>
  </tbody>
</table>

<p>Each stage is a separate binary. Mix and match as needed.</p>

<h2 id="euclidean-rhythms">Euclidean Rhythms</h2>

<p>The <code class="language-plaintext highlighter-rouge">euclid</code> stage generates Euclidean rhythms—mathematically optimal distributions of hits across steps:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 3 hits distributed across 8 steps (Cuban tresillo)</span>
seed | euclid <span class="nt">--pulses</span> 3 <span class="nt">--steps</span> 8 <span class="nt">--note</span> 36 | to-midi <span class="nt">--out</span> kick.mid

<span class="c"># 4-on-the-floor kick pattern</span>
seed | euclid <span class="nt">--pulses</span> 4 <span class="nt">--steps</span> 16 <span class="nt">--note</span> 36 | to-midi <span class="nt">--out</span> four-floor.mid
</code></pre></div></div>

<p>These patterns appear in music worldwide because they “feel right”—the spacing is as even as possible.</p>

<h2 id="scale-locking">Scale Locking</h2>

<p>The <code class="language-plaintext highlighter-rouge">scale</code> stage constrains notes to a musical scale:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>seed 42 | motif <span class="nt">--notes</span> 16 | scale <span class="nt">--root</span> C <span class="nt">--mode</span> minor | to-midi <span class="nt">--out</span> c-minor.mid
</code></pre></div></div>

<p>No wrong notes. Every pitch fits the harmonic context.</p>

<h2 id="layering-streams">Layering Streams</h2>

<p>Generate drum and melody separately, then combine:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">{</span>
    seed 100 | euclid <span class="nt">--pulses</span> 4 <span class="nt">--steps</span> 16 <span class="nt">--note</span> 36 <span class="nt">--ch</span> 9<span class="p">;</span>
    seed 100 | motif <span class="nt">--notes</span> 16 | scale <span class="nt">--root</span> C <span class="nt">--mode</span> pentatonic<span class="p">;</span>
<span class="o">}</span> | to-midi <span class="nt">--out</span> layered.mid
</code></pre></div></div>

<p>Channel 9 is General MIDI drums. Same seed ensures coherence between parts. Both streams merge into a single MIDI file.</p>

<h2 id="why-not-just-use-midi-cli-rs">Why Not Just Use midi-cli-rs?</h2>

<p>Different tools for different needs:</p>

<table>
  <thead>
    <tr>
      <th>Tool</th>
      <th>Strength</th>
      <th>Use Case</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>midi-cli-rs</strong></td>
      <td>Quick mood presets</td>
      <td>“Give me 5 seconds of jazz”</td>
    </tr>
    <tr>
      <td><strong>music-pipe-rs</strong></td>
      <td>Compositional control</td>
      <td>“Generate a motif, constrain to scale, add swing”</td>
    </tr>
  </tbody>
</table>

<p>midi-cli-rs is high-level: pick a mood, get music. music-pipe-rs is low-level: build compositions from primitive operations.</p>

<p>Both are useful. Both work with AI coding agents.</p>

<h2 id="the-personal-software-pattern">The Personal Software Pattern</h2>

<p>This continues the theme: build small tools that compose well. Don’t try to solve everything in one application. Let Unix handle orchestration.</p>

<p>The best part? Standard tools still work. <code class="language-plaintext highlighter-rouge">head</code>, <code class="language-plaintext highlighter-rouge">grep</code>, <code class="language-plaintext highlighter-rouge">jq</code>, <code class="language-plaintext highlighter-rouge">wc</code>—all participate in the pipeline. No special music knowledge required to inspect the data.</p>

<hr />

<table>
  <tbody>
    <tr>
      <td>*Part 4 of the Personal Software series. <a href="/series/#personal-software">View all parts</a></td>
      <td><a href="/2026/02/23/midi-cli-rs-extending-with-custom-mood-packs/">← Previous: midi-cli-rs Plugin Moods</a>*</td>
    </tr>
  </tbody>
</table>

<p><em>Small tools, composed well.</em></p>]]></content><author><name>Software Wrighter</name></author><category term="tools" /><category term="rust" /><category term="ai-agents" /><category term="vibe-coding" /><category term="rust" /><category term="midi" /><category term="music" /><category term="ai-agents" /><category term="cli" /><category term="unix-pipes" /><category term="vibe-coding" /><category term="personal-software" /><summary type="html"><![CDATA[After building midi-cli-rs for quick mood-based generation, I wanted something more surgical. What if music generation worked like Unix commands—small tools connected by pipes? Resource Link Code music-pipe-rs Related midi-cli-rs The Unix Philosophy for Music Most generative music tools are monolithic. You get one application with a closed workflow. If you want to inspect intermediate results, you can’t. If you want to swap one transformation for another, you rebuild everything. Unix solved this decades ago: small tools that do one thing well, connected by pipes. Each tool reads from stdin, writes to stdout. You can inspect any point in the pipeline with head, filter with grep, transform with jq. music-pipe-rs applies this philosophy to MIDI composition. A Pipeline in Action seed 12345 | motif --notes 16 --bpm 120 | humanize | to-midi --out melody.mid Four stages: seed establishes the random seed for the entire pipeline motif generates a melodic pattern (using the pipeline seed) humanize adds timing and velocity variation (using the same seed) to-midi converts the event stream to a standard .mid file The output plays in any DAW. Seed-First Architecture The seed stage goes at the head of the pipeline: # Explicit seed for reproducibility seed 12345 | motif --notes 16 | humanize | to-midi --out melody.mid # Auto-generated seed (printed to stderr) seed | motif --notes 16 | humanize | to-midi --out melody.mid # stderr: seed: 1708732845 All downstream stages read the seed from the event stream. No --seed arguments scattered across the pipeline. One seed, set once, used everywhere. This means: Same seed = identical output across all random stages Different seed = different composition with same structure Reproducibility is trivial: just save the seed number JSONL: The Intermediate Format Between stages, events flow as JSONL (JSON Lines). Each line is a complete event: {"type":"Seed","seed":12345} {"type":"NoteOn","t":0,"ch":0,"key":60,"vel":80} {"type":"NoteOff","t":480,"ch":0,"key":60} This format is human-readable and tool-friendly: # See the first 10 events seed 42 | motif --notes 8 | head -10 # Count how many NoteOn events seed 42 | motif --notes 16 | grep NoteOn | wc -l # Pretty-print with jq seed 42 | motif --notes 4 | jq . No binary formats to decode. No proprietary protocols. Just text. Visualization with viz The viz stage prints a sparkline to stderr while passing events through: seed 12345 | motif --notes 16 | viz | humanize | to-midi --out melody.mid Output on stderr: ▃▅▇▅▃▁▂▄▆▇▆▄▂▁▃▅ For more detail, use piano roll mode: seed 12345 | motif --notes 16 | viz --roll G6 │···█············│ F#6 │·····█··········│ F6 │····█···········│ G5 │·██·········█···│ F5 │···········█····│ E5 │·········██···█·│ C5 │█·····███····█·█│ The visualization goes to stderr; the JSONL events continue to stdout. You can inspect the music without breaking the pipeline. Available Stages Stage Type Description seed Start Establish random seed for pipeline motif Generate Create melodic patterns euclid Generate Euclidean rhythm generation transpose Transform Shift notes by semitones scale Transform Constrain notes to a scale humanize Transform Add timing/velocity variation viz Inspect Print sparkline visualization to-midi Output Convert to .mid file Each stage is a separate binary. Mix and match as needed. Euclidean Rhythms The euclid stage generates Euclidean rhythms—mathematically optimal distributions of hits across steps: # 3 hits distributed across 8 steps (Cuban tresillo) seed | euclid --pulses 3 --steps 8 --note 36 | to-midi --out kick.mid # 4-on-the-floor kick pattern seed | euclid --pulses 4 --steps 16 --note 36 | to-midi --out four-floor.mid These patterns appear in music worldwide because they “feel right”—the spacing is as even as possible. Scale Locking The scale stage constrains notes to a musical scale: seed 42 | motif --notes 16 | scale --root C --mode minor | to-midi --out c-minor.mid No wrong notes. Every pitch fits the harmonic context. Layering Streams Generate drum and melody separately, then combine: { seed 100 | euclid --pulses 4 --steps 16 --note 36 --ch 9; seed 100 | motif --notes 16 | scale --root C --mode pentatonic; } | to-midi --out layered.mid Channel 9 is General MIDI drums. Same seed ensures coherence between parts. Both streams merge into a single MIDI file. Why Not Just Use midi-cli-rs? Different tools for different needs: Tool Strength Use Case midi-cli-rs Quick mood presets “Give me 5 seconds of jazz” music-pipe-rs Compositional control “Generate a motif, constrain to scale, add swing” midi-cli-rs is high-level: pick a mood, get music. music-pipe-rs is low-level: build compositions from primitive operations. Both are useful. Both work with AI coding agents. The Personal Software Pattern This continues the theme: build small tools that compose well. Don’t try to solve everything in one application. Let Unix handle orchestration. The best part? Standard tools still work. head, grep, jq, wc—all participate in the pipeline. No special music knowledge required to inspect the data. *Part 4 of the Personal Software series. View all parts ← Previous: midi-cli-rs Plugin Moods* Small tools, composed well.]]></summary></entry><entry><title type="html">midi-cli-rs: Extending with Custom Mood Packs</title><link href="https://software-wrighter-lab.github.io/2026/02/23/midi-cli-rs-extending-with-custom-mood-packs/" rel="alternate" type="text/html" title="midi-cli-rs: Extending with Custom Mood Packs" /><published>2026-02-23T14:00:00-08:00</published><updated>2026-02-23T14:00:00-08:00</updated><id>https://software-wrighter-lab.github.io/2026/02/23/midi-cli-rs-extending-with-custom-mood-packs</id><content type="html" xml:base="https://software-wrighter-lab.github.io/2026/02/23/midi-cli-rs-extending-with-custom-mood-packs/"><![CDATA[<p><img src="/assets/images/posts/block-galaxy.png" class="post-marker" alt="" /></p>

<p>Personal Software doesn’t stop at “it works.” It evolves. After building midi-cli-rs for AI agents to generate music, I wanted more moods—without recompiling Rust every time.</p>

<p>The solution: a plugin system that lets anyone create custom mood packs using simple TOML files.</p>

<div class="resource-box">

  <table>
    <thead>
      <tr>
        <th>Resource</th>
        <th>Link</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Examples</strong></td>
        <td><a href="https://softwarewrighter.github.io/midi-cli-rs/">Listen to Samples</a></td>
      </tr>
      <tr>
        <td><strong>Wiki</strong></td>
        <td><a href="https://github.com/softwarewrighter/midi-cli-rs/wiki/Plugins-and-Extensibility">Plugin Documentation</a></td>
      </tr>
      <tr>
        <td><strong>Video</strong></td>
        <td><a href="https://www.youtube.com/watch?v=f13s4K60mV8">Plugin Moods Explainer</a><br /><a href="https://www.youtube.com/watch?v=f13s4K60mV8"><img src="https://img.youtube.com/vi/f13s4K60mV8/mqdefault.jpg" alt="Video" class="video-thumb" /></a></td>
      </tr>
      <tr>
        <td><strong>Code</strong></td>
        <td><a href="https://github.com/softwarewrighter/midi-cli-rs">midi-cli-rs</a></td>
      </tr>
    </tbody>
  </table>

</div>

<h2 id="the-problem-with-built-in-only">The Problem with Built-in Only</h2>

<p>The original midi-cli-rs shipped with a handful of mood presets: suspense, eerie, upbeat, calm, ambient, jazz. Useful, but limited. What if you want synthwave? Chillout? Something faster or in a different key?</p>

<p>Hardcoding every possible mood isn’t practical. And asking users to modify Rust source code isn’t friendly.</p>

<h2 id="three-levels-of-extensibility">Three Levels of Extensibility</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th>Level</th>
      <th>What You Get</th>
      <th>What You Change</th>
      <th>Skill Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><span style="color:green">✓</span></td>
      <td><strong>Built-in Moods</strong></td>
      <td>9 curated generators</td>
      <td>Nothing—use as-is</td>
      <td>None</td>
    </tr>
    <tr>
      <td style="text-align: center"><span style="color:green">✓</span></td>
      <td><strong>Plugin Moods</strong></td>
      <td>Parameter variations</td>
      <td>TOML config files</td>
      <td>Text editing</td>
    </tr>
    <tr>
      <td style="text-align: center"><span style="color:red">✗</span></td>
      <td><strong>Custom Generators</strong></td>
      <td>New musical patterns</td>
      <td>Rust source code</td>
      <td>Programming (future)</td>
    </tr>
  </tbody>
</table>

<p>This post covers <strong>Plugin Moods</strong>—the middle tier. You can preset combinations of tempo, key, and intensity, but you’re still using the built-in generators’ musical logic. Want a “smooth-jazz” preset (slower, mellower)? Plugin mood. Want bebop or Latin jazz with different chord progressions? That requires a custom generator.</p>

<p>Custom generators (writing new Rust code) will be covered in a future post when the plugin editor ships.</p>

<h2 id="the-plugin-architecture">The Plugin Architecture</h2>

<p>Custom moods live in <code class="language-plaintext highlighter-rouge">~/.midi-cli-rs/moods/</code> as TOML files. Each file is a “mood pack” that can define multiple moods. The CLI discovers them automatically.</p>

<p>Here’s how it works:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/.midi-cli-rs/
└── moods/
    ├── electronic.toml    # Your synthwave, techno, etc.
    ├── cinematic.toml     # Epic, tension, wonder
    └── seasonal.toml      # Holiday themes
</code></pre></div></div>

<h2 id="creating-a-mood-pack">Creating a Mood Pack</h2>

<p>A plug-in mood pack has two parts: pack metadata and mood definitions.</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">[</span><span class="n">pack</span><span class="k">]</span>
<span class="n">name</span> <span class="o">=</span><span class="w"> </span><span class="s">"electronic"</span>
<span class="n">version</span> <span class="o">=</span><span class="w"> </span><span class="s">"1.0.0"</span>
<span class="n">author</span> <span class="o">=</span><span class="w"> </span><span class="s">"Your Name"</span>
<span class="n">description</span> <span class="o">=</span><span class="w"> </span><span class="s">"Electronic music styles"</span>

<span class="k">[[</span><span class="n">moods</span><span class="k">]]</span>
<span class="n">name</span> <span class="o">=</span><span class="w"> </span><span class="s">"synthwave"</span>
<span class="n">base_mood</span> <span class="o">=</span><span class="w"> </span><span class="s">"upbeat"</span>
<span class="n">default_tempo</span> <span class="o">=</span><span class="w"> </span><span class="mi">118</span>
<span class="n">default_key</span> <span class="o">=</span><span class="w"> </span><span class="s">"Am"</span>
<span class="n">default_intensity</span> <span class="o">=</span><span class="w"> </span><span class="mi">65</span>
<span class="n">description</span> <span class="o">=</span><span class="w"> </span><span class="s">"80s synthwave vibes"</span>
<span class="n">tags</span> <span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s">"electronic"</span><span class="p">,</span> <span class="s">"retro"</span><span class="p">]</span>

<span class="k">[[</span><span class="n">moods</span><span class="k">]]</span>
<span class="n">name</span> <span class="o">=</span><span class="w"> </span><span class="s">"chillout"</span>
<span class="n">base_mood</span> <span class="o">=</span><span class="w"> </span><span class="s">"ambient"</span>
<span class="n">default_tempo</span> <span class="o">=</span><span class="w"> </span><span class="mi">85</span>
<span class="n">default_key</span> <span class="o">=</span><span class="w"> </span><span class="s">"Em"</span>
<span class="n">default_intensity</span> <span class="o">=</span><span class="w"> </span><span class="mi">40</span>
<span class="n">description</span> <span class="o">=</span><span class="w"> </span><span class="s">"Relaxed electronic"</span>
</code></pre></div></div>

<p>Each mood <strong>delegates</strong> to a built-in generator (<code class="language-plaintext highlighter-rouge">base_mood</code>) but overrides specific parameters. You get the musical logic of the built-in mood with your customizations applied.</p>

<h2 id="available-base-moods">Available Base Moods</h2>

<p>Your custom moods can extend any of the nine built-in generators:</p>

<table>
  <thead>
    <tr>
      <th>Base Mood</th>
      <th>Character</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">suspense</code></td>
      <td>Tense, building</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">eerie</code></td>
      <td>Dark, unsettling</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">upbeat</code></td>
      <td>Energetic, positive</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">calm</code></td>
      <td>Peaceful, slow</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ambient</code></td>
      <td>Atmospheric, textural</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">jazz</code></td>
      <td>Swing, improvisation</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">chiptune</code></td>
      <td>8-bit, retro gaming</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">orchestral</code></td>
      <td>Classical instruments</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">show</code></td>
      <td>Broadway, theatrical</td>
    </tr>
  </tbody>
</table>

<h2 id="configuration-options">Configuration Options</h2>

<p>Each mood definition supports these overrides:</p>

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Description</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">name</code></td>
      <td>CLI name (required)</td>
      <td><code class="language-plaintext highlighter-rouge">"synthwave"</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">base_mood</code></td>
      <td>Built-in to extend (required)</td>
      <td><code class="language-plaintext highlighter-rouge">"upbeat"</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">default_tempo</code></td>
      <td>BPM</td>
      <td><code class="language-plaintext highlighter-rouge">118</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">default_key</code></td>
      <td>Musical key</td>
      <td><code class="language-plaintext highlighter-rouge">"Am"</code>, <code class="language-plaintext highlighter-rouge">"C"</code>, <code class="language-plaintext highlighter-rouge">"Eb"</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">default_intensity</code></td>
      <td>0-100 energy level</td>
      <td><code class="language-plaintext highlighter-rouge">65</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">description</code></td>
      <td>Human-readable description</td>
      <td><code class="language-plaintext highlighter-rouge">"80s vibes"</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">tags</code></td>
      <td>Discovery tags</td>
      <td><code class="language-plaintext highlighter-rouge">["electronic", "retro"]</code></td>
    </tr>
  </tbody>
</table>

<h2 id="how-seeds-create-variation">How Seeds Create Variation</h2>

<p>Seeds aren’t random—they’re deterministic variation selectors. The same mood + same seed always produces identical output. But different seeds create observable musical differences across multiple dimensions:</p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Variation Range</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Tempo</td>
      <td>±15% from base</td>
    </tr>
    <tr>
      <td>Layer inclusion</td>
      <td>Which instruments appear</td>
    </tr>
    <tr>
      <td>Melodic contour</td>
      <td>16 different phrase shapes</td>
    </tr>
    <tr>
      <td>Note density</td>
      <td>0.6x to 1.4x</td>
    </tr>
    <tr>
      <td>Rest probability</td>
      <td>0% to 35% silence</td>
    </tr>
    <tr>
      <td>Phrase length</td>
      <td>3-8 notes</td>
    </tr>
    <tr>
      <td>Velocity</td>
      <td>-15 to +15 offset</td>
    </tr>
  </tbody>
</table>

<p>The system uses hash-based mixing with unique salts for each parameter. This means adjacent seeds (42 vs 43) produce completely different outputs—no gradual transitions between seeds.</p>

<p>When you combine plugin moods with seed variation, you get a matrix: your custom tempo/key/intensity settings applied across different seed-driven variations of the underlying generator’s patterns.</p>

<h2 id="using-custom-moods">Using Custom Moods</h2>

<p>Once your TOML file is in place, the mood appears automatically:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># List all moods (built-in + plugins)</span>
midi-cli-rs moods

<span class="c"># Generate with your custom mood</span>
midi-cli-rs preset <span class="nt">-m</span> synthwave <span class="nt">-d</span> 5 <span class="nt">-s</span> 42 <span class="nt">-o</span> output.wav
</code></pre></div></div>

<p>The seed system still works—same mood + same seed = identical output.</p>

<h2 id="example-electronic-pack">Example: Electronic Pack</h2>

<p>Here’s a complete pack with four electronic moods:</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">[</span><span class="n">pack</span><span class="k">]</span>
<span class="n">name</span> <span class="o">=</span><span class="w"> </span><span class="s">"electronic"</span>
<span class="n">version</span> <span class="o">=</span><span class="w"> </span><span class="s">"1.0.0"</span>
<span class="n">description</span> <span class="o">=</span><span class="w"> </span><span class="s">"Electronic music styles"</span>

<span class="k">[[</span><span class="n">moods</span><span class="k">]]</span>
<span class="n">name</span> <span class="o">=</span><span class="w"> </span><span class="s">"synthwave"</span>
<span class="n">base_mood</span> <span class="o">=</span><span class="w"> </span><span class="s">"upbeat"</span>
<span class="n">default_tempo</span> <span class="o">=</span><span class="w"> </span><span class="mi">118</span>
<span class="n">default_key</span> <span class="o">=</span><span class="w"> </span><span class="s">"Am"</span>
<span class="n">default_intensity</span> <span class="o">=</span><span class="w"> </span><span class="mi">65</span>

<span class="k">[[</span><span class="n">moods</span><span class="k">]]</span>
<span class="n">name</span> <span class="o">=</span><span class="w"> </span><span class="s">"chillout"</span>
<span class="n">base_mood</span> <span class="o">=</span><span class="w"> </span><span class="s">"ambient"</span>
<span class="n">default_tempo</span> <span class="o">=</span><span class="w"> </span><span class="mi">85</span>
<span class="n">default_key</span> <span class="o">=</span><span class="w"> </span><span class="s">"Em"</span>
<span class="n">default_intensity</span> <span class="o">=</span><span class="w"> </span><span class="mi">40</span>

<span class="k">[[</span><span class="n">moods</span><span class="k">]]</span>
<span class="n">name</span> <span class="o">=</span><span class="w"> </span><span class="s">"techno"</span>
<span class="n">base_mood</span> <span class="o">=</span><span class="w"> </span><span class="s">"upbeat"</span>
<span class="n">default_tempo</span> <span class="o">=</span><span class="w"> </span><span class="mi">130</span>
<span class="n">default_key</span> <span class="o">=</span><span class="w"> </span><span class="s">"Dm"</span>
<span class="n">default_intensity</span> <span class="o">=</span><span class="w"> </span><span class="mi">85</span>

<span class="k">[[</span><span class="n">moods</span><span class="k">]]</span>
<span class="n">name</span> <span class="o">=</span><span class="w"> </span><span class="s">"8bit"</span>
<span class="n">base_mood</span> <span class="o">=</span><span class="w"> </span><span class="s">"chiptune"</span>
<span class="n">default_tempo</span> <span class="o">=</span><span class="w"> </span><span class="mi">140</span>
<span class="n">default_key</span> <span class="o">=</span><span class="w"> </span><span class="s">"C"</span>
<span class="n">default_intensity</span> <span class="o">=</span><span class="w"> </span><span class="mi">70</span>
</code></pre></div></div>

<p>Drop this in <code class="language-plaintext highlighter-rouge">~/.midi-cli-rs/moods/electronic.toml</code> and you have four new moods.</p>

<h2 id="whats-next">What’s Next</h2>

<p>This plugin system handles <strong>mood variations</strong>—different tempos, keys, and intensities applied to existing generators. A future update will add a <strong>plugin editor</strong> for creating entirely new musical patterns without writing Rust.</p>

<p>For now, the delegation model covers most use cases: want faster jazz? Darker ambient? Major-key suspense? Create a TOML file and you’re done.</p>

<h2 id="the-personal-software-pattern">The Personal Software Pattern</h2>

<p>This follows the Personal Software philosophy: start with something that works, then extend it as needs emerge. The plugin system wasn’t in the original design. It grew from actual use—wanting more moods without recompiling.</p>

<p>Good personal software leaves room to grow.</p>

<hr />

<table>
  <tbody>
    <tr>
      <td>*Part 3 of the Personal Software series. <a href="/series/#personal-software">View all parts</a></td>
      <td><a href="/2026/02/20/midi-cli-rs-music-for-ai-agents/">← Previous: midi-cli-rs</a>*</td>
    </tr>
  </tbody>
</table>

<p><em>Personal software that evolves with your needs.</em></p>]]></content><author><name>Software Wrighter</name></author><category term="tools" /><category term="rust" /><category term="ai-agents" /><category term="vibe-coding" /><category term="rust" /><category term="midi" /><category term="music" /><category term="ai-agents" /><category term="cli" /><category term="plugins" /><category term="extensibility" /><category term="vibe-coding" /><category term="personal-software" /><summary type="html"><![CDATA[Personal Software doesn’t stop at “it works.” It evolves. After building midi-cli-rs for AI agents to generate music, I wanted more moods—without recompiling Rust every time. The solution: a plugin system that lets anyone create custom mood packs using simple TOML files. Resource Link Examples Listen to Samples Wiki Plugin Documentation Video Plugin Moods Explainer Code midi-cli-rs The Problem with Built-in Only The original midi-cli-rs shipped with a handful of mood presets: suspense, eerie, upbeat, calm, ambient, jazz. Useful, but limited. What if you want synthwave? Chillout? Something faster or in a different key? Hardcoding every possible mood isn’t practical. And asking users to modify Rust source code isn’t friendly. Three Levels of Extensibility   Level What You Get What You Change Skill Required ✓ Built-in Moods 9 curated generators Nothing—use as-is None ✓ Plugin Moods Parameter variations TOML config files Text editing ✗ Custom Generators New musical patterns Rust source code Programming (future) This post covers Plugin Moods—the middle tier. You can preset combinations of tempo, key, and intensity, but you’re still using the built-in generators’ musical logic. Want a “smooth-jazz” preset (slower, mellower)? Plugin mood. Want bebop or Latin jazz with different chord progressions? That requires a custom generator. Custom generators (writing new Rust code) will be covered in a future post when the plugin editor ships. The Plugin Architecture Custom moods live in ~/.midi-cli-rs/moods/ as TOML files. Each file is a “mood pack” that can define multiple moods. The CLI discovers them automatically. Here’s how it works: ~/.midi-cli-rs/ └── moods/ ├── electronic.toml # Your synthwave, techno, etc. ├── cinematic.toml # Epic, tension, wonder └── seasonal.toml # Holiday themes Creating a Mood Pack A plug-in mood pack has two parts: pack metadata and mood definitions. [pack] name = "electronic" version = "1.0.0" author = "Your Name" description = "Electronic music styles" [[moods]] name = "synthwave" base_mood = "upbeat" default_tempo = 118 default_key = "Am" default_intensity = 65 description = "80s synthwave vibes" tags = ["electronic", "retro"] [[moods]] name = "chillout" base_mood = "ambient" default_tempo = 85 default_key = "Em" default_intensity = 40 description = "Relaxed electronic" Each mood delegates to a built-in generator (base_mood) but overrides specific parameters. You get the musical logic of the built-in mood with your customizations applied. Available Base Moods Your custom moods can extend any of the nine built-in generators: Base Mood Character suspense Tense, building eerie Dark, unsettling upbeat Energetic, positive calm Peaceful, slow ambient Atmospheric, textural jazz Swing, improvisation chiptune 8-bit, retro gaming orchestral Classical instruments show Broadway, theatrical Configuration Options Each mood definition supports these overrides: Field Description Example name CLI name (required) "synthwave" base_mood Built-in to extend (required) "upbeat" default_tempo BPM 118 default_key Musical key "Am", "C", "Eb" default_intensity 0-100 energy level 65 description Human-readable description "80s vibes" tags Discovery tags ["electronic", "retro"] How Seeds Create Variation Seeds aren’t random—they’re deterministic variation selectors. The same mood + same seed always produces identical output. But different seeds create observable musical differences across multiple dimensions: Parameter Variation Range Tempo ±15% from base Layer inclusion Which instruments appear Melodic contour 16 different phrase shapes Note density 0.6x to 1.4x Rest probability 0% to 35% silence Phrase length 3-8 notes Velocity -15 to +15 offset The system uses hash-based mixing with unique salts for each parameter. This means adjacent seeds (42 vs 43) produce completely different outputs—no gradual transitions between seeds. When you combine plugin moods with seed variation, you get a matrix: your custom tempo/key/intensity settings applied across different seed-driven variations of the underlying generator’s patterns. Using Custom Moods Once your TOML file is in place, the mood appears automatically: # List all moods (built-in + plugins) midi-cli-rs moods # Generate with your custom mood midi-cli-rs preset -m synthwave -d 5 -s 42 -o output.wav The seed system still works—same mood + same seed = identical output. Example: Electronic Pack Here’s a complete pack with four electronic moods: [pack] name = "electronic" version = "1.0.0" description = "Electronic music styles" [[moods]] name = "synthwave" base_mood = "upbeat" default_tempo = 118 default_key = "Am" default_intensity = 65 [[moods]] name = "chillout" base_mood = "ambient" default_tempo = 85 default_key = "Em" default_intensity = 40 [[moods]] name = "techno" base_mood = "upbeat" default_tempo = 130 default_key = "Dm" default_intensity = 85 [[moods]] name = "8bit" base_mood = "chiptune" default_tempo = 140 default_key = "C" default_intensity = 70 Drop this in ~/.midi-cli-rs/moods/electronic.toml and you have four new moods. What’s Next This plugin system handles mood variations—different tempos, keys, and intensities applied to existing generators. A future update will add a plugin editor for creating entirely new musical patterns without writing Rust. For now, the delegation model covers most use cases: want faster jazz? Darker ambient? Major-key suspense? Create a TOML file and you’re done. The Personal Software Pattern This follows the Personal Software philosophy: start with something that works, then extend it as needs emerge. The plugin system wasn’t in the original design. It grew from actual use—wanting more moods without recompiling. Good personal software leaves room to grow. *Part 3 of the Personal Software series. View all parts ← Previous: midi-cli-rs* Personal software that evolves with your needs.]]></summary></entry><entry><title type="html">Five ML Concepts - #20</title><link href="https://software-wrighter-lab.github.io/2026/02/23/five-ml-concepts-20/" rel="alternate" type="text/html" title="Five ML Concepts - #20" /><published>2026-02-23T00:00:00-08:00</published><updated>2026-02-23T00:00:00-08:00</updated><id>https://software-wrighter-lab.github.io/2026/02/23/five-ml-concepts-20</id><content type="html" xml:base="https://software-wrighter-lab.github.io/2026/02/23/five-ml-concepts-20/"><![CDATA[<p><img src="/assets/images/posts/block-twenty.png" class="post-marker" alt="" /></p>

<p>5 machine learning concepts. Under 30 seconds each.</p>

<div class="resource-box">

  <table>
    <thead>
      <tr>
        <th>Resource</th>
        <th>Link</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Papers</strong></td>
        <td>Links in References section</td>
      </tr>
      <tr>
        <td><strong>Video</strong></td>
        <td><a href="https://www.youtube.com/shorts/OklW3RTV3I4">Five ML Concepts #20</a><br /><a href="https://www.youtube.com/shorts/OklW3RTV3I4"><img src="https://img.youtube.com/vi/OklW3RTV3I4/mqdefault.jpg" alt="Video" class="video-thumb" /></a></td>
      </tr>
    </tbody>
  </table>

</div>

<div class="references-section">

  <h2 id="references">References</h2>

  <table>
    <thead>
      <tr>
        <th>Concept</th>
        <th>Reference</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>VAEs</strong></td>
        <td><a href="https://arxiv.org/abs/1312.6114">Auto-Encoding Variational Bayes</a> (Kingma &amp; Welling 2013)</td>
      </tr>
      <tr>
        <td><strong>Uncertainty Estimation</strong></td>
        <td><a href="https://arxiv.org/abs/1703.04977">What Uncertainties Do We Need in Bayesian Deep Learning?</a> (Kendall &amp; Gal 2017)</td>
      </tr>
      <tr>
        <td><strong>Interpretability</strong></td>
        <td><a href="https://arxiv.org/abs/1702.08608">Towards A Rigorous Science of Interpretable Machine Learning</a> (Doshi-Velez &amp; Kim 2017)</td>
      </tr>
      <tr>
        <td><strong>Gradient Noise</strong></td>
        <td><a href="https://arxiv.org/abs/1704.04289">Stochastic Gradient Descent as Approximate Bayesian Inference</a> (Mandt et al. 2017)</td>
      </tr>
      <tr>
        <td><strong>Human-in-the-Loop</strong></td>
        <td><a href="https://www.manning.com/books/human-in-the-loop-machine-learning">Human-in-the-Loop Machine Learning</a> (Monarch 2021)</td>
      </tr>
    </tbody>
  </table>

</div>

<h2 id="todays-five">Today’s Five</h2>

<h3 id="1-variational-autoencoders-vaes">1. Variational Autoencoders (VAEs)</h3>

<p><strong>VAEs are probabilistic autoencoders that learn a structured latent distribution.</strong> By sampling from that distribution, they can generate new examples similar to the training data.</p>

<p>The key innovation is regularizing the latent space to be smooth and continuous.</p>

<blockquote>
  <p>Like learning not just to summarize books, but to create new ones in a similar style.</p>
</blockquote>

<h3 id="2-uncertainty-estimation">2. Uncertainty Estimation</h3>

<p><strong>Models can estimate how confident they should be in predictions.</strong> Some uncertainty comes from noisy data (aleatoric), and some from limited knowledge (epistemic).</p>

<p>Knowing when a model is uncertain enables safer decision-making.</p>

<blockquote>
  <p>Like a weather forecast giving seventy percent chance of rain instead of a simple yes or no.</p>
</blockquote>

<h3 id="3-why-interpretability-is-hard">3. Why Interpretability Is Hard</h3>

<p><strong>Neural networks represent information across many interacting parameters.</strong> No single component cleanly maps to a human concept.</p>

<p>Distributed representations enable powerful learning but resist simple explanations.</p>

<blockquote>
  <p>Like trying to explain a dream by pointing to individual neurons.</p>
</blockquote>

<h3 id="4-gradient-noise">4. Gradient Noise</h3>

<p><strong>When training with mini-batches, gradients vary from step to step.</strong> A little noise can help exploration, but too much can slow convergence.</p>

<p>Batch size, learning rate, and gradient clipping all influence this noise level.</p>

<blockquote>
  <p>Like getting slightly different directions each time you ask for help.</p>
</blockquote>

<h3 id="5-human-in-the-loop-systems">5. Human-in-the-Loop Systems</h3>

<p><strong>Humans review, supervise, or override model decisions in critical workflows.</strong> This improves safety and accountability in high-stakes applications.</p>

<p>The approach combines model efficiency with human judgment where it matters most.</p>

<blockquote>
  <p>Like a pilot monitoring autopilot and stepping in when necessary.</p>
</blockquote>

<h2 id="quick-reference">Quick Reference</h2>

<table>
  <thead>
    <tr>
      <th>Concept</th>
      <th>One-liner</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>VAEs</strong></td>
      <td>Generative models with structured latent spaces</td>
    </tr>
    <tr>
      <td><strong>Uncertainty Estimation</strong></td>
      <td>Know when you don’t know</td>
    </tr>
    <tr>
      <td><strong>Interpretability</strong></td>
      <td>Distributed representations resist explanation</td>
    </tr>
    <tr>
      <td><strong>Gradient Noise</strong></td>
      <td>Mini-batch variation in training</td>
    </tr>
    <tr>
      <td><strong>Human-in-the-Loop</strong></td>
      <td>Human oversight for critical decisions</td>
    </tr>
  </tbody>
</table>

<hr />

<p><em>Part 20 of the Five ML Concepts series. <a href="/series/#five-ml-concepts">View all parts</a></em></p>

<p><em>Short, accurate ML explainers. Follow for more.</em></p>]]></content><author><name>Software Wrighter</name></author><category term="llm" /><category term="machine-learning" /><category term="explainers" /><category term="five-ml-concepts" /><category term="vae" /><category term="uncertainty-estimation" /><category term="interpretability" /><category term="gradient-noise" /><category term="human-in-the-loop" /><category term="ml-concepts" /><summary type="html"><![CDATA[5 machine learning concepts. Under 30 seconds each. Resource Link Papers Links in References section Video Five ML Concepts #20 References Concept Reference VAEs Auto-Encoding Variational Bayes (Kingma &amp; Welling 2013) Uncertainty Estimation What Uncertainties Do We Need in Bayesian Deep Learning? (Kendall &amp; Gal 2017) Interpretability Towards A Rigorous Science of Interpretable Machine Learning (Doshi-Velez &amp; Kim 2017) Gradient Noise Stochastic Gradient Descent as Approximate Bayesian Inference (Mandt et al. 2017) Human-in-the-Loop Human-in-the-Loop Machine Learning (Monarch 2021) Today’s Five 1. Variational Autoencoders (VAEs) VAEs are probabilistic autoencoders that learn a structured latent distribution. By sampling from that distribution, they can generate new examples similar to the training data. The key innovation is regularizing the latent space to be smooth and continuous. Like learning not just to summarize books, but to create new ones in a similar style. 2. Uncertainty Estimation Models can estimate how confident they should be in predictions. Some uncertainty comes from noisy data (aleatoric), and some from limited knowledge (epistemic). Knowing when a model is uncertain enables safer decision-making. Like a weather forecast giving seventy percent chance of rain instead of a simple yes or no. 3. Why Interpretability Is Hard Neural networks represent information across many interacting parameters. No single component cleanly maps to a human concept. Distributed representations enable powerful learning but resist simple explanations. Like trying to explain a dream by pointing to individual neurons. 4. Gradient Noise When training with mini-batches, gradients vary from step to step. A little noise can help exploration, but too much can slow convergence. Batch size, learning rate, and gradient clipping all influence this noise level. Like getting slightly different directions each time you ask for help. 5. Human-in-the-Loop Systems Humans review, supervise, or override model decisions in critical workflows. This improves safety and accountability in high-stakes applications. The approach combines model efficiency with human judgment where it matters most. Like a pilot monitoring autopilot and stepping in when necessary. Quick Reference Concept One-liner VAEs Generative models with structured latent spaces Uncertainty Estimation Know when you don’t know Interpretability Distributed representations resist explanation Gradient Noise Mini-batch variation in training Human-in-the-Loop Human oversight for critical decisions Part 20 of the Five ML Concepts series. View all parts Short, accurate ML explainers. Follow for more.]]></summary></entry><entry><title type="html">In-Context Learning Revisited: From Mystery to Engineering</title><link href="https://software-wrighter-lab.github.io/2026/02/22/icl-revisited-from-mystery-to-engineering/" rel="alternate" type="text/html" title="In-Context Learning Revisited: From Mystery to Engineering" /><published>2026-02-22T00:00:00-08:00</published><updated>2026-02-22T00:00:00-08:00</updated><id>https://software-wrighter-lab.github.io/2026/02/22/icl-revisited-from-mystery-to-engineering</id><content type="html" xml:base="https://software-wrighter-lab.github.io/2026/02/22/icl-revisited-from-mystery-to-engineering/"><![CDATA[<p><img src="/assets/images/posts/block-framework.png" class="post-marker" alt="" /></p>

<p>It was 2020 when GPT-3 shocked everyone. It could learn from examples in the query—without updating its weights. We called it In-Context Learning. But was it magic, or was it doing something deeper?</p>

<div class="resource-box">

  <table>
    <thead>
      <tr>
        <th>Resource</th>
        <th>Link</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Video</strong></td>
        <td><a href="https://www.youtube.com/shorts/zWKmRxChRlA">ICL Revisited</a><br /><a href="https://www.youtube.com/shorts/zWKmRxChRlA"><img src="https://img.youtube.com/vi/zWKmRxChRlA/mqdefault.jpg" alt="Video" class="video-thumb" /></a></td>
      </tr>
      <tr>
        <td><strong>Papers</strong></td>
        <td><a href="#references">4 References</a></td>
      </tr>
    </tbody>
  </table>

</div>

<h2 id="phase-1-the-empirical-discovery-2020">Phase 1: The Empirical Discovery (2020)</h2>

<p>The GPT-3 paper showed that large models could perform few-shot learning. Give them examples, and they generalize. No gradient updates. No retraining. Just forward passes.</p>

<p>The surprising part was that <strong>scaling alone</strong> seemed to unlock it.</p>

<h3 id="paper-language-models-are-few-shot-learners">Paper: Language Models are Few-Shot Learners</h3>

<p><strong>ELI5:</strong> Show a big language model a few examples of a task in your prompt, and it figures out how to do the task—without any retraining. Nobody told it to do this. It just emerged when models got big enough.</p>

<p><strong>Main idea:</strong> Scale unlocks emergent capabilities. ICL was discovered, not designed.</p>

<h2 id="phase-2-mechanistic-explanations-2022">Phase 2: Mechanistic Explanations (2022)</h2>

<p>By 2022, researchers began probing the internal mechanisms. Several papers proposed that transformers implement <strong>implicit meta-learning</strong>. The model appears to learn during inference by performing gradient-descent-like operations internally.</p>

<h3 id="paper-what-explains-in-context-learning-in-transformers">Paper: What Explains In-Context Learning in Transformers?</h3>

<p><strong>ELI5:</strong> When you give a transformer examples, its attention layers do something that looks like fitting a simple linear model to those examples—on the fly, during the forward pass. It’s not memorizing; it’s computing a mini-solution.</p>

<p><strong>Main idea:</strong> ICL works because attention can simulate linear regression internally.</p>

<h3 id="paper-transformers-learn-in-context-by-gradient-descent">Paper: Transformers Learn In-Context by Gradient Descent</h3>

<p><strong>ELI5:</strong> The transformer’s forward pass is secretly doing something similar to training. The attention mechanism acts like one step of gradient descent over the examples you provided. Learning happens inside inference.</p>

<p><strong>Main idea:</strong> ICL is implicit gradient descent—learning hidden inside prediction.</p>

<h2 id="phase-3-engineering-the-effect">Phase 3: Engineering the Effect</h2>

<p>Once researchers understood that ordering and structure affect ICL, prompt design became less of an art and more of an optimization problem. The quality and arrangement of demonstrations directly shape performance.</p>

<p>ICL became tunable. Researchers could now deliberately improve it rather than just observe it.</p>

<h2 id="phase-4-interactive-icl-2026">Phase 4: Interactive ICL (2026)</h2>

<p>Recent work pushes this further. Models are trained to predict natural language critiques and feedback. If a model can predict what a teacher would say, it can internalize that signal. External correction becomes an internal capability.</p>

<h3 id="paper-improving-interactive-in-context-learning-from-natural-language-feedback">Paper: Improving Interactive In-Context Learning from Natural Language Feedback</h3>

<p><strong>ELI5:</strong> Train a model to guess what feedback a human would give. Now the model has internalized the “teacher” and can improve itself without needing the actual teacher present. Self-correction without weight updates.</p>

<p><strong>Main idea:</strong> Models can learn to learn from feedback, making ICL interactive and self-improving.</p>

<h2 id="beyond-language">Beyond Language</h2>

<p>Newer work applies ICL to neuroscience discovery, showing that the mechanism is not limited to text tasks. It becomes a flexible reasoning substrate across domains. That’s when you know a concept has matured.</p>

<h2 id="the-arc">The Arc</h2>

<table>
  <thead>
    <tr>
      <th>Phase</th>
      <th>Era</th>
      <th>Key Insight</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Discovery</strong></td>
      <td>2020</td>
      <td>Emerges from scale</td>
    </tr>
    <tr>
      <td><strong>Explanation</strong></td>
      <td>2022</td>
      <td>Implicit gradient descent</td>
    </tr>
    <tr>
      <td><strong>Engineering</strong></td>
      <td>2023-24</td>
      <td>Prompt design as optimization</td>
    </tr>
    <tr>
      <td><strong>Self-improvement</strong></td>
      <td>2026</td>
      <td>Learning from feedback</td>
    </tr>
  </tbody>
</table>

<h2 id="the-deeper-insight">The Deeper Insight</h2>

<p>In-Context Learning started as an emergent surprise. Now it’s becoming an engineered learning substrate inside transformers.</p>

<p>It was not magic. It was <strong>meta-learning hiding in plain sight</strong>.</p>

<div class="references-section">

  <h2 id="references">References</h2>

  <table>
    <thead>
      <tr>
        <th>Paper</th>
        <th>Link</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Language Models are Few-Shot Learners (GPT-3)</td>
        <td><a href="https://arxiv.org/abs/2005.14165">arXiv:2005.14165</a></td>
      </tr>
      <tr>
        <td>What Explains In-Context Learning in Transformers?</td>
        <td><a href="https://arxiv.org/abs/2202.12837">arXiv:2202.12837</a></td>
      </tr>
      <tr>
        <td>Transformers Learn In-Context by Gradient Descent</td>
        <td><a href="https://arxiv.org/abs/2212.07677">arXiv:2212.07677</a></td>
      </tr>
      <tr>
        <td>Improving Interactive ICL from Natural Language Feedback</td>
        <td><a href="https://arxiv.org/abs/2602.16066">arXiv:2602.16066</a></td>
      </tr>
    </tbody>
  </table>

</div>

<hr />

<p><em>ICL started as “whoa, it works.” Now we understand “why it works.” Next: engineering it deliberately.</em></p>]]></content><author><name>Software Wrighter</name></author><category term="machine-learning" /><category term="llm" /><category term="research" /><category term="in-context-learning" /><category term="icl" /><category term="transformers" /><category term="meta-learning" /><category term="gpt" /><category term="few-shot-learning" /><summary type="html"><![CDATA[It was 2020 when GPT-3 shocked everyone. It could learn from examples in the query—without updating its weights. We called it In-Context Learning. But was it magic, or was it doing something deeper? Resource Link Video ICL Revisited Papers 4 References Phase 1: The Empirical Discovery (2020) The GPT-3 paper showed that large models could perform few-shot learning. Give them examples, and they generalize. No gradient updates. No retraining. Just forward passes. The surprising part was that scaling alone seemed to unlock it. Paper: Language Models are Few-Shot Learners ELI5: Show a big language model a few examples of a task in your prompt, and it figures out how to do the task—without any retraining. Nobody told it to do this. It just emerged when models got big enough. Main idea: Scale unlocks emergent capabilities. ICL was discovered, not designed. Phase 2: Mechanistic Explanations (2022) By 2022, researchers began probing the internal mechanisms. Several papers proposed that transformers implement implicit meta-learning. The model appears to learn during inference by performing gradient-descent-like operations internally. Paper: What Explains In-Context Learning in Transformers? ELI5: When you give a transformer examples, its attention layers do something that looks like fitting a simple linear model to those examples—on the fly, during the forward pass. It’s not memorizing; it’s computing a mini-solution. Main idea: ICL works because attention can simulate linear regression internally. Paper: Transformers Learn In-Context by Gradient Descent ELI5: The transformer’s forward pass is secretly doing something similar to training. The attention mechanism acts like one step of gradient descent over the examples you provided. Learning happens inside inference. Main idea: ICL is implicit gradient descent—learning hidden inside prediction. Phase 3: Engineering the Effect Once researchers understood that ordering and structure affect ICL, prompt design became less of an art and more of an optimization problem. The quality and arrangement of demonstrations directly shape performance. ICL became tunable. Researchers could now deliberately improve it rather than just observe it. Phase 4: Interactive ICL (2026) Recent work pushes this further. Models are trained to predict natural language critiques and feedback. If a model can predict what a teacher would say, it can internalize that signal. External correction becomes an internal capability. Paper: Improving Interactive In-Context Learning from Natural Language Feedback ELI5: Train a model to guess what feedback a human would give. Now the model has internalized the “teacher” and can improve itself without needing the actual teacher present. Self-correction without weight updates. Main idea: Models can learn to learn from feedback, making ICL interactive and self-improving. Beyond Language Newer work applies ICL to neuroscience discovery, showing that the mechanism is not limited to text tasks. It becomes a flexible reasoning substrate across domains. That’s when you know a concept has matured. The Arc Phase Era Key Insight Discovery 2020 Emerges from scale Explanation 2022 Implicit gradient descent Engineering 2023-24 Prompt design as optimization Self-improvement 2026 Learning from feedback The Deeper Insight In-Context Learning started as an emergent surprise. Now it’s becoming an engineered learning substrate inside transformers. It was not magic. It was meta-learning hiding in plain sight. References Paper Link Language Models are Few-Shot Learners (GPT-3) arXiv:2005.14165 What Explains In-Context Learning in Transformers? arXiv:2202.12837 Transformers Learn In-Context by Gradient Descent arXiv:2212.07677 Improving Interactive ICL from Natural Language Feedback arXiv:2602.16066 ICL started as “whoa, it works.” Now we understand “why it works.” Next: engineering it deliberately.]]></summary></entry><entry><title type="html">Five ML Concepts - #19</title><link href="https://software-wrighter-lab.github.io/2026/02/22/five-ml-concepts-19/" rel="alternate" type="text/html" title="Five ML Concepts - #19" /><published>2026-02-22T00:00:00-08:00</published><updated>2026-02-22T00:00:00-08:00</updated><id>https://software-wrighter-lab.github.io/2026/02/22/five-ml-concepts-19</id><content type="html" xml:base="https://software-wrighter-lab.github.io/2026/02/22/five-ml-concepts-19/"><![CDATA[<p><img src="/assets/images/posts/block-nineteen.png" class="post-marker" alt="" /></p>

<p>5 machine learning concepts. Under 30 seconds each.</p>

<div class="resource-box">

  <table>
    <thead>
      <tr>
        <th>Resource</th>
        <th>Link</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Papers</strong></td>
        <td>Links in References section</td>
      </tr>
      <tr>
        <td><strong>Video</strong></td>
        <td><a href="https://www.youtube.com/shorts/ppoONTOdqJQ">Five ML Concepts #19</a><br /><a href="https://www.youtube.com/shorts/ppoONTOdqJQ"><img src="https://img.youtube.com/vi/ppoONTOdqJQ/mqdefault.jpg" alt="Video" class="video-thumb" /></a></td>
      </tr>
    </tbody>
  </table>

</div>

<div class="references-section">

  <h2 id="references">References</h2>

  <table>
    <thead>
      <tr>
        <th>Concept</th>
        <th>Reference</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Autoencoders</strong></td>
        <td><a href="https://www.science.org/doi/10.1126/science.1127647">Reducing the Dimensionality of Data with Neural Networks</a> (Hinton &amp; Salakhutdinov 2006)</td>
      </tr>
      <tr>
        <td><strong>Correlation vs Causation</strong></td>
        <td><a href="https://www.cambridge.org/core/books/causality/B0046844FAE10CBF274D4ACBDAEB5F5B">Causality</a> (Pearl 2009)</td>
      </tr>
      <tr>
        <td><strong>Curriculum Learning</strong></td>
        <td><a href="https://dl.acm.org/doi/10.1145/1553374.1553380">Curriculum Learning</a> (Bengio et al. 2009)</td>
      </tr>
      <tr>
        <td><strong>Failure Analysis</strong></td>
        <td><a href="https://www.oreilly.com/library/view/practical-machine-learning/9781098102357/">Practical Machine Learning for Computer Vision</a> (Lakshmanan et al. 2021)</td>
      </tr>
      <tr>
        <td><strong>Covariate Shift</strong></td>
        <td><a href="https://mitpress.mit.edu/9780262170055/">Dataset Shift in Machine Learning</a> (Quinonero-Candela et al. 2009)</td>
      </tr>
    </tbody>
  </table>

</div>

<h2 id="todays-five">Today’s Five</h2>

<h3 id="1-autoencoders">1. Autoencoders</h3>

<p><strong>Autoencoders are neural networks trained to compress inputs into a smaller representation and reconstruct them.</strong> The bottleneck forces the model to capture essential structure.</p>

<p>This learned compression is useful for dimensionality reduction, denoising, and feature learning.</p>

<blockquote>
  <p>Like summarizing a book into key points and then rebuilding the story from that summary.</p>
</blockquote>

<h3 id="2-correlation-vs-causation">2. Correlation vs Causation</h3>

<p><strong>Two variables can move together without one causing the other.</strong> Models typically learn correlations present in data, not true cause-and-effect relationships.</p>

<p>This matters because interventions based on correlation alone may not produce intended effects.</p>

<blockquote>
  <p>Like noticing umbrella sales rise with rain—umbrellas don’t cause rain.</p>
</blockquote>

<h3 id="3-curriculum-learning">3. Curriculum Learning</h3>

<p><strong>Training starts with easier examples and gradually introduces harder ones.</strong> This can improve stability and learning speed in some settings.</p>

<p>The approach mirrors how humans learn complex subjects incrementally.</p>

<blockquote>
  <p>Like teaching math by starting with addition before moving to calculus.</p>
</blockquote>

<h3 id="4-failure-analysis">4. Failure Analysis</h3>

<p><strong>Failure analysis groups model errors into categories to understand where performance breaks down.</strong> This helps target improvements instead of guessing.</p>

<p>Systematic error analysis often reveals actionable patterns invisible in aggregate metrics.</p>

<blockquote>
  <p>Like a teacher reviewing which types of questions students miss most often.</p>
</blockquote>

<h3 id="5-covariate-shift">5. Covariate Shift</h3>

<p><strong>Covariate shift occurs when the input distribution changes between training and deployment, while the task itself remains the same.</strong> The model may underperform because it sees unfamiliar inputs.</p>

<p>Monitoring input distributions helps detect this shift early.</p>

<blockquote>
  <p>Like training a driver in sunny weather and testing them in snow.</p>
</blockquote>

<h2 id="quick-reference">Quick Reference</h2>

<table>
  <thead>
    <tr>
      <th>Concept</th>
      <th>One-liner</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Autoencoders</strong></td>
      <td>Compress and reconstruct to learn structure</td>
    </tr>
    <tr>
      <td><strong>Correlation vs Causation</strong></td>
      <td>Co-occurrence isn’t cause</td>
    </tr>
    <tr>
      <td><strong>Curriculum Learning</strong></td>
      <td>Start easy, progress to hard</td>
    </tr>
    <tr>
      <td><strong>Failure Analysis</strong></td>
      <td>Categorize errors to guide fixes</td>
    </tr>
    <tr>
      <td><strong>Covariate Shift</strong></td>
      <td>New inputs, same task</td>
    </tr>
  </tbody>
</table>

<hr />

<table>
  <tbody>
    <tr>
      <td>*Part 19 of the Five ML Concepts series. <a href="/series/#five-ml-concepts">View all parts</a></td>
      <td><a href="/2026/02/23/five-ml-concepts-20/">Next: #20 →</a>*</td>
    </tr>
  </tbody>
</table>

<p><em>Short, accurate ML explainers. Follow for more.</em></p>]]></content><author><name>Software Wrighter</name></author><category term="llm" /><category term="machine-learning" /><category term="explainers" /><category term="five-ml-concepts" /><category term="autoencoders" /><category term="correlation-causation" /><category term="curriculum-learning" /><category term="failure-analysis" /><category term="covariate-shift" /><category term="ml-concepts" /><summary type="html"><![CDATA[5 machine learning concepts. Under 30 seconds each. Resource Link Papers Links in References section Video Five ML Concepts #19 References Concept Reference Autoencoders Reducing the Dimensionality of Data with Neural Networks (Hinton &amp; Salakhutdinov 2006) Correlation vs Causation Causality (Pearl 2009) Curriculum Learning Curriculum Learning (Bengio et al. 2009) Failure Analysis Practical Machine Learning for Computer Vision (Lakshmanan et al. 2021) Covariate Shift Dataset Shift in Machine Learning (Quinonero-Candela et al. 2009) Today’s Five 1. Autoencoders Autoencoders are neural networks trained to compress inputs into a smaller representation and reconstruct them. The bottleneck forces the model to capture essential structure. This learned compression is useful for dimensionality reduction, denoising, and feature learning. Like summarizing a book into key points and then rebuilding the story from that summary. 2. Correlation vs Causation Two variables can move together without one causing the other. Models typically learn correlations present in data, not true cause-and-effect relationships. This matters because interventions based on correlation alone may not produce intended effects. Like noticing umbrella sales rise with rain—umbrellas don’t cause rain. 3. Curriculum Learning Training starts with easier examples and gradually introduces harder ones. This can improve stability and learning speed in some settings. The approach mirrors how humans learn complex subjects incrementally. Like teaching math by starting with addition before moving to calculus. 4. Failure Analysis Failure analysis groups model errors into categories to understand where performance breaks down. This helps target improvements instead of guessing. Systematic error analysis often reveals actionable patterns invisible in aggregate metrics. Like a teacher reviewing which types of questions students miss most often. 5. Covariate Shift Covariate shift occurs when the input distribution changes between training and deployment, while the task itself remains the same. The model may underperform because it sees unfamiliar inputs. Monitoring input distributions helps detect this shift early. Like training a driver in sunny weather and testing them in snow. Quick Reference Concept One-liner Autoencoders Compress and reconstruct to learn structure Correlation vs Causation Co-occurrence isn’t cause Curriculum Learning Start easy, progress to hard Failure Analysis Categorize errors to guide fixes Covariate Shift New inputs, same task *Part 19 of the Five ML Concepts series. View all parts Next: #20 →* Short, accurate ML explainers. Follow for more.]]></summary></entry><entry><title type="html">JSON et al: A Deep Dive into Data Serialization Formats</title><link href="https://software-wrighter-lab.github.io/2026/02/21/json-et-al-data-serialization-formats/" rel="alternate" type="text/html" title="JSON et al: A Deep Dive into Data Serialization Formats" /><published>2026-02-21T14:00:00-08:00</published><updated>2026-02-21T14:00:00-08:00</updated><id>https://software-wrighter-lab.github.io/2026/02/21/json-et-al-data-serialization-formats</id><content type="html" xml:base="https://software-wrighter-lab.github.io/2026/02/21/json-et-al-data-serialization-formats/"><![CDATA[<p><img src="/assets/images/posts/block-brackets.png" class="post-marker no-invert" alt="" /></p>

<p>JSON is everywhere. APIs. Logs. Databases. Configuration files. But it’s not alone. A whole ecosystem of formats exists—each optimizing for different tradeoffs.</p>

<p>This post expands on the <a href="https://www.youtube.com/shorts/3ezjk1CnZEU">JSON et al</a> short, providing technical depth on each format: when it was created, where it’s specified, and what problems it solves.</p>

<hr />

<h2 id="the-tradeoff-triangle">The Tradeoff Triangle</h2>

<p>Before diving in, understand the fundamental constraint. Data formats balance three competing goals:</p>

<table>
  <thead>
    <tr>
      <th>Goal</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Human Readability</strong></td>
      <td>Can a developer read and edit it directly?</td>
    </tr>
    <tr>
      <td><strong>Compactness</strong></td>
      <td>How many bytes does it take to represent data?</td>
    </tr>
    <tr>
      <td><strong>Query Performance</strong></td>
      <td>How fast can you access specific fields?</td>
    </tr>
  </tbody>
</table>

<p>You usually only get two. JSON optimizes readability. Protobuf optimizes compactness. JSONB optimizes query performance. No format wins everywhere.</p>

<hr />

<h2 id="json-the-ubiquitous-baseline">JSON: The Ubiquitous Baseline</h2>

<p><strong>Created:</strong> 2001 (discovered/formalized by Douglas Crockford)
<strong>Specification:</strong> <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-404/">ECMA-404</a> (2013), <a href="https://datatracker.ietf.org/doc/html/rfc8259">RFC 8259</a> (2017)
<strong>File Extension:</strong> <code class="language-plaintext highlighter-rouge">.json</code></p>

<p>JSON (JavaScript Object Notation) emerged from JavaScript’s object literal syntax but became language-agnostic. Crockford didn’t invent it—he “discovered” it already existing in JavaScript and formalized the specification.</p>

<h3 id="technical-details">Technical Details</h3>

<ul>
  <li><strong>Encoding:</strong> UTF-8 text (UTF-16/32 allowed but rare)</li>
  <li><strong>Data Types:</strong> Objects <code class="language-plaintext highlighter-rouge">{}</code>, arrays <code class="language-plaintext highlighter-rouge">[]</code>, strings, numbers, booleans, <code class="language-plaintext highlighter-rouge">null</code></li>
  <li><strong>Schema:</strong> None required</li>
  <li><strong>Comments:</strong> Not allowed in strict JSON</li>
</ul>

<h3 id="strengths">Strengths</h3>

<ul>
  <li>Universal parser support (every language has one)</li>
  <li>Human readable without tools</li>
  <li>Web-native (JavaScript parses it natively)</li>
  <li>Simple specification (fits on a business card)</li>
</ul>

<h3 id="weaknesses">Weaknesses</h3>

<ul>
  <li>Verbose (field names repeated for every object)</li>
  <li>No binary data type (must base64-encode)</li>
  <li>No comments (frustrating for config files)</li>
  <li>Parsing overhead (tokenization + string decoding every time)</li>
</ul>

<h3 id="eli5">ELI5</h3>

<p>Like typing a long email instead of sending a terse text. Every message spells everything out—clear, but verbose.</p>

<h3 id="when-to-use">When to Use</h3>

<p>REST APIs, configuration (when comments aren’t needed), data interchange between systems, anywhere human readability matters more than efficiency.</p>

<hr />

<h2 id="jsonl--ndjson-streaming-json">JSONL / NDJSON: Streaming JSON</h2>

<p><strong>Created:</strong> ~2013 (formalized)
<strong>Specification:</strong> <a href="https://jsonlines.org/">JSON Lines</a>, <a href="http://ndjsonspec.org/">NDJSON</a>
<strong>File Extension:</strong> <code class="language-plaintext highlighter-rouge">.jsonl</code>, <code class="language-plaintext highlighter-rouge">.ndjson</code></p>

<p>JSONL (JSON Lines) and NDJSON (Newline-Delimited JSON) are the same concept: one valid JSON object per line, separated by newlines.</p>

<h3 id="technical-details-1">Technical Details</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{"name": "Alice", "score": 95}
{"name": "Bob", "score": 87}
{"name": "Carol", "score": 92}
</code></pre></div></div>

<p>No wrapping array. Each line is independently parseable.</p>

<h3 id="strengths-1">Strengths</h3>

<ul>
  <li><strong>Streaming:</strong> Process line-by-line without loading entire file</li>
  <li><strong>Append-only:</strong> Add records without rewriting the file</li>
  <li><strong>Parallel processing:</strong> Split by line, distribute to workers</li>
  <li><strong>Fault-tolerant:</strong> One corrupt line doesn’t invalidate the file</li>
</ul>

<h3 id="weaknesses-1">Weaknesses</h3>

<ul>
  <li>Not valid JSON (can’t parse with standard JSON parser)</li>
  <li>Still text-based (same verbosity as JSON)</li>
  <li>No random access by index</li>
</ul>

<h3 id="eli5-1">ELI5</h3>

<p>Like removing one comma per line to save some typing. Each line is self-contained, so you can grab and process them one at a time.</p>

<h3 id="when-to-use-1">When to Use</h3>

<p>Log files, big data pipelines (Spark, Pandas), ML datasets, event streams, anywhere you need to process records incrementally.</p>

<hr />

<h2 id="jsonb-binary-json-for-databases">JSONB: Binary JSON for Databases</h2>

<p><strong>Created:</strong> 2014 (PostgreSQL 9.4)
<strong>Specification:</strong> Implementation-specific (no universal standard)
<strong>Storage:</strong> Database column type</p>

<p>JSONB isn’t a file format—it’s a database storage optimization. PostgreSQL’s JSONB differs from MongoDB’s BSON, which differs from other implementations.</p>

<h3 id="postgresql-jsonb-details">PostgreSQL JSONB Details</h3>

<ul>
  <li><strong>Parsed once:</strong> Text converted to binary on INSERT</li>
  <li><strong>Keys sorted:</strong> Deterministic ordering for indexing</li>
  <li><strong>Duplicates removed:</strong> Last value wins</li>
  <li><strong>Offset table:</strong> O(log n) field lookup instead of O(n) text scanning</li>
</ul>

<h3 id="mongodb-bson">MongoDB BSON</h3>

<p><strong>Specification:</strong> <a href="https://bsonspec.org/">bsonspec.org</a></p>

<p>BSON (Binary JSON) is MongoDB’s serialization format. Unlike PostgreSQL’s JSONB, BSON is a standalone binary format:</p>

<ul>
  <li>Type-prefixed values</li>
  <li>Supports additional types (Date, Binary, ObjectId)</li>
  <li>Length-prefixed for fast skipping</li>
  <li>~10-15% smaller than JSON typically</li>
</ul>

<h3 id="strengths-2">Strengths</h3>

<ul>
  <li>Fast queries without re-parsing</li>
  <li>Indexable (GIN indexes on JSONB in PostgreSQL)</li>
  <li>Type coercion at storage time</li>
</ul>

<h3 id="weaknesses-2">Weaknesses</h3>

<ul>
  <li>Not portable (implementation-specific)</li>
  <li>Not human-readable</li>
  <li>INSERT overhead (parsing cost upfront)</li>
</ul>

<h3 id="eli5-2">ELI5</h3>

<p>Instead of cooking from scratch every time, you heat a pre-made meal. The prep work happens once (on INSERT), so serving (queries) is fast.</p>

<h3 id="when-to-use-2">When to Use</h3>

<p>Database storage where you query into JSON structures. PostgreSQL JSONB + GIN indexes enable fast <code class="language-plaintext highlighter-rouge">@&gt;</code> containment queries.</p>

<hr />

<h2 id="protocol-buffers-googles-schema-first-format">Protocol Buffers: Google’s Schema-First Format</h2>

<p><strong>Created:</strong> 2001 (internal Google), 2008 (open-sourced)
<strong>Specification:</strong> <a href="https://developers.google.com/protocol-buffers/docs/proto3">developers.google.com/protocol-buffers</a>
<strong>File Extension:</strong> <code class="language-plaintext highlighter-rouge">.proto</code> (schema), binary wire format</p>

<p>Protocol Buffers (Protobuf) is Google’s language-neutral, schema-required serialization format. It powers gRPC.</p>

<h3 id="technical-details-2">Technical Details</h3>

<p>Schema definition:</p>
<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">message</span> <span class="nc">Sensor</span> <span class="p">{</span>
  <span class="kt">int32</span> <span class="na">temperature</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int32</span> <span class="na">humidity</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Wire format uses field numbers, not names:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Field 1: 72
Field 2: 40
</code></pre></div></div>

<h3 id="key-features">Key Features</h3>

<ul>
  <li><strong>Varint encoding:</strong> Small integers use fewer bytes</li>
  <li><strong>Field numbers:</strong> Enable backward compatibility</li>
  <li><strong>Code generation:</strong> <code class="language-plaintext highlighter-rouge">.proto</code> → language-specific classes</li>
  <li><strong>No self-description:</strong> Receiver must know schema</li>
</ul>

<h3 id="strengths-3">Strengths</h3>

<ul>
  <li>Extremely compact (3-10x smaller than JSON typically)</li>
  <li>Fast serialization/deserialization</li>
  <li>Strong versioning semantics</li>
  <li>gRPC integration</li>
</ul>

<h3 id="weaknesses-3">Weaknesses</h3>

<ul>
  <li>Requires schema agreement</li>
  <li>Not human-readable</li>
  <li>Tooling required for debugging</li>
  <li>Schema evolution has rules</li>
</ul>

<h3 id="eli5-3">ELI5</h3>

<p>Everyone agrees upfront what “field 1” means. You don’t waste space spelling out “temperature”—you just send the number 1 and the value. Both sides know the code.</p>

<h3 id="when-to-use-3">When to Use</h3>

<p>Microservices (gRPC), internal APIs, anywhere bandwidth and latency matter more than debuggability.</p>

<hr />

<h2 id="asn1-the-telecom-veteran">ASN.1: The Telecom Veteran</h2>

<p><strong>Created:</strong> 1984 (ITU-T X.208)
<strong>Specification:</strong> <a href="https://www.itu.int/rec/T-REC-X.680-X.683">ITU-T X.680-X.683</a>
<strong>Encoding Rules:</strong> BER, DER, PER, XER, and more</p>

<p>ASN.1 (Abstract Syntax Notation One) predates all modern formats. It defines both schema and encoding, with multiple encoding rules for different use cases.</p>

<h3 id="encoding-rules-comparison">Encoding Rules Comparison</h3>

<table>
  <thead>
    <tr>
      <th>Rule</th>
      <th>Use Case</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>BER</strong> (Basic Encoding Rules)</td>
      <td>Flexible, general purpose</td>
    </tr>
    <tr>
      <td><strong>DER</strong> (Distinguished Encoding Rules)</td>
      <td>Deterministic, for cryptography</td>
    </tr>
    <tr>
      <td><strong>PER</strong> (Packed Encoding Rules)</td>
      <td>Most compact, for bandwidth-constrained</td>
    </tr>
    <tr>
      <td><strong>XER</strong> (XML Encoding Rules)</td>
      <td>XML-based, for interop</td>
    </tr>
  </tbody>
</table>

<h3 id="where-you-see-asn1">Where You See ASN.1</h3>

<ul>
  <li><strong>X.509 certificates</strong> (SSL/TLS certs are DER-encoded ASN.1)</li>
  <li><strong>LDAP</strong> (directory services)</li>
  <li><strong>SNMP</strong> (network management)</li>
  <li><strong>Telecom protocols</strong> (SS7, GSM, LTE)</li>
</ul>

<h3 id="strengths-4">Strengths</h3>

<ul>
  <li>Bit-level precision</li>
  <li>Proven over 40 years</li>
  <li>Multiple encoding options</li>
  <li>Formal verification possible</li>
</ul>

<h3 id="weaknesses-4">Weaknesses</h3>

<ul>
  <li>Complex specification</li>
  <li>Steep learning curve</li>
  <li>Tooling can be expensive</li>
  <li>Security vulnerabilities in parsers (historically)</li>
</ul>

<h3 id="eli5-4">ELI5</h3>

<p>Same idea as Protobuf—everyone agrees upfront what each field number means. ASN.1 just got there 20 years earlier and handles even more edge cases.</p>

<h3 id="when-to-use-4">When to Use</h3>

<p>You probably won’t choose ASN.1 for new projects. You’ll encounter it in cryptography, certificates, and legacy telecom systems.</p>

<hr />

<h2 id="yaml-human-friendly-configuration">YAML: Human-Friendly Configuration</h2>

<p><strong>Created:</strong> 2001 (Clark Evans, Ingy döt Net, Oren Ben-Kiki)
<strong>Specification:</strong> <a href="https://yaml.org/spec/1.2.2/">yaml.org/spec/1.2.2</a>
<strong>File Extension:</strong> <code class="language-plaintext highlighter-rouge">.yaml</code>, <code class="language-plaintext highlighter-rouge">.yml</code></p>

<p>YAML (YAML Ain’t Markup Language) prioritizes human readability. It’s a superset of JSON—any valid JSON is valid YAML.</p>

<h3 id="technical-details-3">Technical Details</h3>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Comments allowed!</span>
<span class="na">server</span><span class="pi">:</span>
  <span class="na">host</span><span class="pi">:</span> <span class="s">localhost</span>
  <span class="na">port</span><span class="pi">:</span> <span class="m">8080</span>
  <span class="na">features</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">auth</span>
    <span class="pi">-</span> <span class="s">logging</span>
</code></pre></div></div>

<h3 id="key-features-1">Key Features</h3>

<ul>
  <li><strong>Indentation-based:</strong> Whitespace matters</li>
  <li><strong>Comments:</strong> <code class="language-plaintext highlighter-rouge">#</code> for single-line</li>
  <li><strong>Anchors/aliases:</strong> <code class="language-plaintext highlighter-rouge">&amp;name</code> and <code class="language-plaintext highlighter-rouge">*name</code> for references</li>
  <li><strong>Multiple documents:</strong> <code class="language-plaintext highlighter-rouge">---</code> separator</li>
</ul>

<h3 id="strengths-5">Strengths</h3>

<ul>
  <li>Highly readable</li>
  <li>Comments supported</li>
  <li>Multi-line strings without escaping</li>
  <li>Complex data structures</li>
</ul>

<h3 id="weaknesses-5">Weaknesses</h3>

<ul>
  <li><strong>“Norway problem”:</strong> <code class="language-plaintext highlighter-rouge">NO</code> parses as boolean <code class="language-plaintext highlighter-rouge">false</code></li>
  <li>Whitespace sensitivity causes errors</li>
  <li>Multiple ways to express same data</li>
  <li>Security concerns (arbitrary code execution in some parsers)</li>
</ul>

<h3 id="eli5-5">ELI5</h3>

<p>Optimized for clarity, not bandwidth. YAML is for humans editing config files—not for machines exchanging data over networks.</p>

<h3 id="when-to-use-5">When to Use</h3>

<p>Configuration files (Kubernetes, Docker Compose, CI/CD), anywhere humans edit data directly and comments help.</p>

<hr />

<h2 id="toml-minimal-configuration">TOML: Minimal Configuration</h2>

<p><strong>Created:</strong> 2013 (Tom Preston-Werner)
<strong>Specification:</strong> <a href="https://toml.io/en/v1.0.0">toml.io</a>
<strong>File Extension:</strong> <code class="language-plaintext highlighter-rouge">.toml</code></p>

<p>TOML (Tom’s Obvious Minimal Language) emerged as a reaction to YAML’s complexity. It’s used by Rust (Cargo.toml), Python (pyproject.toml), and others.</p>

<h3 id="technical-details-4">Technical Details</h3>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">[</span><span class="n">server</span><span class="k">]</span>
<span class="n">host</span> <span class="o">=</span><span class="w"> </span><span class="s">"localhost"</span>
<span class="n">port</span> <span class="o">=</span><span class="w"> </span><span class="mi">8080</span>

<span class="k">[</span><span class="n">server</span><span class="k">.</span><span class="n">features</span><span class="k">]</span>
<span class="n">auth</span> <span class="o">=</span><span class="w"> </span><span class="kc">true</span>
<span class="n">logging</span> <span class="o">=</span><span class="w"> </span><span class="kc">true</span>
</code></pre></div></div>

<h3 id="key-features-2">Key Features</h3>

<ul>
  <li><strong>Explicit typing:</strong> Dates, times, arrays have clear syntax</li>
  <li><strong>Sections:</strong> <code class="language-plaintext highlighter-rouge">[section]</code> and <code class="language-plaintext highlighter-rouge">[section.subsection]</code></li>
  <li><strong>No anchors:</strong> Intentionally simpler than YAML</li>
  <li><strong>Deterministic:</strong> Same data = same representation</li>
</ul>

<h3 id="strengths-6">Strengths</h3>

<ul>
  <li>Easy to read and write</li>
  <li>Unambiguous parsing</li>
  <li>Clear error messages</li>
  <li>Growing ecosystem support</li>
</ul>

<h3 id="weaknesses-6">Weaknesses</h3>

<ul>
  <li>Less expressive than YAML</li>
  <li>Nested structures can be verbose</li>
  <li>Smaller ecosystem than JSON/YAML</li>
</ul>

<h3 id="eli5-6">ELI5</h3>

<p>Same goal as YAML—clarity for humans, not bandwidth for machines—but with stricter rules so you make fewer mistakes.</p>

<h3 id="when-to-use-6">When to Use</h3>

<p>Configuration files where YAML’s complexity isn’t needed. Rust projects (mandatory). Python packaging (pyproject.toml).</p>

<hr />

<h2 id="toon-token-optimized-for-llms">TOON: Token-Optimized for LLMs</h2>

<p><strong>Created:</strong> October 2025 (toon-format organization)
<strong>Specification:</strong> <a href="https://github.com/toon-format/toon">github.com/toon-format/toon</a> (v3.0)
<strong>File Extension:</strong> <code class="language-plaintext highlighter-rouge">.toon</code>
<strong>Media Type:</strong> <code class="language-plaintext highlighter-rouge">text/toon</code> (provisional)</p>

<p>TOON (Token Oriented Object Notation) is the newest format in this list, designed specifically for LLM input. It’s a lossless representation of JSON that minimizes tokens.</p>

<h3 id="technical-details-5">Technical Details</h3>

<p>TOON combines YAML-style indentation for nested objects with CSV-like tabular layouts for uniform arrays:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>users[2]{name,age}:
Alice,25
Bob,30
</code></pre></div></div>

<p>Equivalent JSON:</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"users"</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Alice"</span><span class="p">,</span><span class="w"> </span><span class="nl">"age"</span><span class="p">:</span><span class="w"> </span><span class="mi">25</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Bob"</span><span class="p">,</span><span class="w"> </span><span class="nl">"age"</span><span class="p">:</span><span class="w"> </span><span class="mi">30</span><span class="p">}]}</span><span class="w">
</span></code></pre></div></div>

<h3 id="key-features-3">Key Features</h3>

<ul>
  <li><strong>Header-based:</strong> Field names declared once, values follow</li>
  <li><strong>40% fewer tokens:</strong> Than equivalent JSON typically</li>
  <li><strong>Lossless:</strong> Round-trips to JSON perfectly</li>
  <li><strong>UTF-8 always:</strong> No encoding ambiguity</li>
</ul>

<h3 id="performance">Performance</h3>

<table>
  <thead>
    <tr>
      <th>Metric</th>
      <th>JSON</th>
      <th>TOON</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Accuracy</td>
      <td>69.7%</td>
      <td>73.9%</td>
    </tr>
    <tr>
      <td>Efficiency (acc/1K tokens)</td>
      <td>15.3</td>
      <td>26.9</td>
    </tr>
  </tbody>
</table>

<h3 id="strengths-7">Strengths</h3>

<ul>
  <li>Significant token savings at scale</li>
  <li>Better context window utilization</li>
  <li>Lower API costs for LLM applications</li>
  <li>Human-readable (unlike binary formats)</li>
</ul>

<h3 id="weaknesses-7">Weaknesses</h3>

<ul>
  <li>New format (October 2025)</li>
  <li>Limited tooling compared to JSON</li>
  <li>Requires conversion layer for existing systems</li>
  <li>Not yet widely adopted</li>
</ul>

<h3 id="eli5-7">ELI5</h3>

<p>Like having one header row for each column in a table instead of repeating the column name for every single row. You declare field names once, then just list the values.</p>

<h3 id="when-to-use-7">When to Use</h3>

<p>LLM prompts with structured data, RAG applications, anywhere token efficiency matters. Especially useful for large datasets with uniform object arrays.</p>

<h3 id="implementations">Implementations</h3>

<ul>
  <li><strong>TypeScript:</strong> Reference implementation</li>
  <li><strong>Python:</strong> <a href="https://pypi.org/project/toons/">toons</a> (Rust-based, fast)</li>
  <li><strong>Go, Rust, .NET:</strong> Available via toon-format org</li>
</ul>

<hr />

<h2 id="alternatives-not-in-the-video">Alternatives Not in the Video</h2>

<h3 id="messagepack">MessagePack</h3>

<p><strong>Created:</strong> 2008 (Sadayuki Furuhashi)
<strong>Specification:</strong> <a href="https://msgpack.org/">msgpack.org</a></p>

<p>Binary JSON without schema. Type-prefixed values, efficient numeric encoding.</p>

<p><strong>Use when:</strong> You want JSON semantics but smaller/faster.</p>

<h3 id="cbor">CBOR</h3>

<p><strong>Created:</strong> 2013 (IETF)
<strong>Specification:</strong> <a href="https://datatracker.ietf.org/doc/html/rfc8949">RFC 8949</a></p>

<p>Concise Binary Object Representation. Designed for constrained environments (IoT).</p>

<p><strong>Use when:</strong> Resource-constrained devices, need a standard binary format.</p>

<h3 id="apache-avro">Apache Avro</h3>

<p><strong>Created:</strong> 2009 (Apache, Doug Cutting)
<strong>Specification:</strong> <a href="https://avro.apache.org/docs/current/spec.html">avro.apache.org</a></p>

<p>Schema-based, row-oriented binary format. Schema embedded or stored separately. Strong schema evolution support.</p>

<p><strong>Use when:</strong> Big data pipelines (Hadoop, Kafka), schema evolution is critical.</p>

<h3 id="apache-parquet">Apache Parquet</h3>

<p><strong>Created:</strong> 2013 (Twitter + Cloudera)
<strong>Specification:</strong> <a href="https://parquet.apache.org/docs/file-format/">parquet.apache.org</a></p>

<p>Columnar storage format. Not for serialization—for analytics storage.</p>

<p><strong>Use when:</strong> Large-scale analytics, data warehousing, Spark/Pandas workflows.</p>

<h3 id="capn-proto">Cap’n Proto</h3>

<p><strong>Created:</strong> 2013 (Kenton Varda, ex-Protobuf author)
<strong>Specification:</strong> <a href="https://capnproto.org/">capnproto.org</a></p>

<p>Zero-copy serialization. The serialized form <em>is</em> the in-memory form.</p>

<p><strong>Use when:</strong> Extreme performance requirements, inter-process communication.</p>

<h3 id="flatbuffers">FlatBuffers</h3>

<p><strong>Created:</strong> 2014 (Google)
<strong>Specification:</strong> <a href="https://google.github.io/flatbuffers/">google.github.io/flatbuffers</a></p>

<p>Zero-copy like Cap’n Proto but with better tooling. Used in games, mobile.</p>

<p><strong>Use when:</strong> Games, mobile apps, anywhere memory allocation matters.</p>

<hr />

<h2 id="quick-reference">Quick Reference</h2>

<table>
  <thead>
    <tr>
      <th>Format</th>
      <th>Year</th>
      <th>Schema</th>
      <th>Binary</th>
      <th>Human-Readable</th>
      <th>Best For</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>JSON</td>
      <td>2001</td>
      <td>No</td>
      <td>No</td>
      <td>Yes</td>
      <td>APIs, interchange</td>
    </tr>
    <tr>
      <td>JSONL</td>
      <td>2013</td>
      <td>No</td>
      <td>No</td>
      <td>Yes</td>
      <td>Logs, streaming</td>
    </tr>
    <tr>
      <td>JSONB</td>
      <td>2014</td>
      <td>No</td>
      <td>Yes</td>
      <td>No</td>
      <td>Database queries</td>
    </tr>
    <tr>
      <td>Protobuf</td>
      <td>2008</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>No</td>
      <td>Microservices</td>
    </tr>
    <tr>
      <td>ASN.1</td>
      <td>1984</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>No</td>
      <td>Crypto, telecom</td>
    </tr>
    <tr>
      <td>YAML</td>
      <td>2001</td>
      <td>No</td>
      <td>No</td>
      <td>Yes</td>
      <td>Config files</td>
    </tr>
    <tr>
      <td>TOML</td>
      <td>2013</td>
      <td>No</td>
      <td>No</td>
      <td>Yes</td>
      <td>Simple config</td>
    </tr>
    <tr>
      <td>TOON</td>
      <td>2025</td>
      <td>No</td>
      <td>No</td>
      <td>Yes</td>
      <td>LLM prompts</td>
    </tr>
    <tr>
      <td>MessagePack</td>
      <td>2008</td>
      <td>No</td>
      <td>Yes</td>
      <td>No</td>
      <td>Fast JSON</td>
    </tr>
    <tr>
      <td>CBOR</td>
      <td>2013</td>
      <td>Optional</td>
      <td>Yes</td>
      <td>No</td>
      <td>IoT</td>
    </tr>
    <tr>
      <td>Avro</td>
      <td>2009</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>No</td>
      <td>Big data</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="key-takeaways">Key Takeaways</h2>

<ol>
  <li>
    <p><strong>No “best” format exists.</strong> Each optimizes for different constraints.</p>
  </li>
  <li>
    <p><strong>Text formats favor humans.</strong> JSON, YAML, TOML prioritize readability over efficiency.</p>
  </li>
  <li>
    <p><strong>Binary formats favor machines.</strong> Protobuf, MessagePack, CBOR prioritize compactness and speed.</p>
  </li>
  <li>
    <p><strong>Schema formats favor correctness.</strong> Protobuf, Avro, ASN.1 catch errors at compile time.</p>
  </li>
  <li>
    <p><strong>The tradeoff triangle is real.</strong> Readability, compactness, query performance—pick two.</p>
  </li>
</ol>

<p>The question isn’t “which format wins?” The question is: what problem are you solving?</p>

<hr />

<h2 id="resources">Resources</h2>

<ul>
  <li><a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-404/">ECMA-404 JSON Specification</a></li>
  <li><a href="https://datatracker.ietf.org/doc/html/rfc8259">RFC 8259 JSON</a></li>
  <li><a href="https://jsonlines.org/">JSON Lines Specification</a></li>
  <li><a href="https://www.postgresql.org/docs/current/datatype-json.html">PostgreSQL JSONB Documentation</a></li>
  <li><a href="https://developers.google.com/protocol-buffers">Protocol Buffers Documentation</a></li>
  <li><a href="https://yaml.org/spec/1.2.2/">YAML 1.2.2 Specification</a></li>
  <li><a href="https://toml.io/en/v1.0.0">TOML v1.0.0 Specification</a></li>
  <li><a href="https://datatracker.ietf.org/doc/html/rfc8949">RFC 8949 CBOR</a></li>
  <li><a href="https://github.com/msgpack/msgpack/blob/master/spec.md">MessagePack Specification</a></li>
  <li><a href="https://avro.apache.org/docs/current/spec.html">Apache Avro Specification</a></li>
</ul>

<hr />

<p><em>Data formats are design decisions. Choose based on your constraints, not trends.</em></p>

<p><em>Questions? Find me on <a href="https://www.youtube.com/@SoftwareWrighter">YouTube @SoftwareWrighter</a>.</em></p>]]></content><author><name>Software Wrighter</name></author><category term="data-formats" /><category term="fundamentals" /><category term="json" /><category term="jsonb" /><category term="jsonl" /><category term="protobuf" /><category term="yaml" /><category term="toml" /><category term="serialization" /><summary type="html"><![CDATA[JSON is everywhere. APIs. Logs. Databases. Configuration files. But it’s not alone. A whole ecosystem of formats exists—each optimizing for different tradeoffs. This post expands on the JSON et al short, providing technical depth on each format: when it was created, where it’s specified, and what problems it solves. The Tradeoff Triangle Before diving in, understand the fundamental constraint. Data formats balance three competing goals: Goal Description Human Readability Can a developer read and edit it directly? Compactness How many bytes does it take to represent data? Query Performance How fast can you access specific fields? You usually only get two. JSON optimizes readability. Protobuf optimizes compactness. JSONB optimizes query performance. No format wins everywhere. JSON: The Ubiquitous Baseline Created: 2001 (discovered/formalized by Douglas Crockford) Specification: ECMA-404 (2013), RFC 8259 (2017) File Extension: .json JSON (JavaScript Object Notation) emerged from JavaScript’s object literal syntax but became language-agnostic. Crockford didn’t invent it—he “discovered” it already existing in JavaScript and formalized the specification. Technical Details Encoding: UTF-8 text (UTF-16/32 allowed but rare) Data Types: Objects {}, arrays [], strings, numbers, booleans, null Schema: None required Comments: Not allowed in strict JSON Strengths Universal parser support (every language has one) Human readable without tools Web-native (JavaScript parses it natively) Simple specification (fits on a business card) Weaknesses Verbose (field names repeated for every object) No binary data type (must base64-encode) No comments (frustrating for config files) Parsing overhead (tokenization + string decoding every time) ELI5 Like typing a long email instead of sending a terse text. Every message spells everything out—clear, but verbose. When to Use REST APIs, configuration (when comments aren’t needed), data interchange between systems, anywhere human readability matters more than efficiency. JSONL / NDJSON: Streaming JSON Created: ~2013 (formalized) Specification: JSON Lines, NDJSON File Extension: .jsonl, .ndjson JSONL (JSON Lines) and NDJSON (Newline-Delimited JSON) are the same concept: one valid JSON object per line, separated by newlines. Technical Details {"name": "Alice", "score": 95} {"name": "Bob", "score": 87} {"name": "Carol", "score": 92} No wrapping array. Each line is independently parseable. Strengths Streaming: Process line-by-line without loading entire file Append-only: Add records without rewriting the file Parallel processing: Split by line, distribute to workers Fault-tolerant: One corrupt line doesn’t invalidate the file Weaknesses Not valid JSON (can’t parse with standard JSON parser) Still text-based (same verbosity as JSON) No random access by index ELI5 Like removing one comma per line to save some typing. Each line is self-contained, so you can grab and process them one at a time. When to Use Log files, big data pipelines (Spark, Pandas), ML datasets, event streams, anywhere you need to process records incrementally. JSONB: Binary JSON for Databases Created: 2014 (PostgreSQL 9.4) Specification: Implementation-specific (no universal standard) Storage: Database column type JSONB isn’t a file format—it’s a database storage optimization. PostgreSQL’s JSONB differs from MongoDB’s BSON, which differs from other implementations. PostgreSQL JSONB Details Parsed once: Text converted to binary on INSERT Keys sorted: Deterministic ordering for indexing Duplicates removed: Last value wins Offset table: O(log n) field lookup instead of O(n) text scanning MongoDB BSON Specification: bsonspec.org BSON (Binary JSON) is MongoDB’s serialization format. Unlike PostgreSQL’s JSONB, BSON is a standalone binary format: Type-prefixed values Supports additional types (Date, Binary, ObjectId) Length-prefixed for fast skipping ~10-15% smaller than JSON typically Strengths Fast queries without re-parsing Indexable (GIN indexes on JSONB in PostgreSQL) Type coercion at storage time Weaknesses Not portable (implementation-specific) Not human-readable INSERT overhead (parsing cost upfront) ELI5 Instead of cooking from scratch every time, you heat a pre-made meal. The prep work happens once (on INSERT), so serving (queries) is fast. When to Use Database storage where you query into JSON structures. PostgreSQL JSONB + GIN indexes enable fast @&gt; containment queries. Protocol Buffers: Google’s Schema-First Format Created: 2001 (internal Google), 2008 (open-sourced) Specification: developers.google.com/protocol-buffers File Extension: .proto (schema), binary wire format Protocol Buffers (Protobuf) is Google’s language-neutral, schema-required serialization format. It powers gRPC. Technical Details Schema definition: message Sensor { int32 temperature = 1; int32 humidity = 2; } Wire format uses field numbers, not names: Field 1: 72 Field 2: 40 Key Features Varint encoding: Small integers use fewer bytes Field numbers: Enable backward compatibility Code generation: .proto → language-specific classes No self-description: Receiver must know schema Strengths Extremely compact (3-10x smaller than JSON typically) Fast serialization/deserialization Strong versioning semantics gRPC integration Weaknesses Requires schema agreement Not human-readable Tooling required for debugging Schema evolution has rules ELI5 Everyone agrees upfront what “field 1” means. You don’t waste space spelling out “temperature”—you just send the number 1 and the value. Both sides know the code. When to Use Microservices (gRPC), internal APIs, anywhere bandwidth and latency matter more than debuggability. ASN.1: The Telecom Veteran Created: 1984 (ITU-T X.208) Specification: ITU-T X.680-X.683 Encoding Rules: BER, DER, PER, XER, and more ASN.1 (Abstract Syntax Notation One) predates all modern formats. It defines both schema and encoding, with multiple encoding rules for different use cases. Encoding Rules Comparison Rule Use Case BER (Basic Encoding Rules) Flexible, general purpose DER (Distinguished Encoding Rules) Deterministic, for cryptography PER (Packed Encoding Rules) Most compact, for bandwidth-constrained XER (XML Encoding Rules) XML-based, for interop Where You See ASN.1 X.509 certificates (SSL/TLS certs are DER-encoded ASN.1) LDAP (directory services) SNMP (network management) Telecom protocols (SS7, GSM, LTE) Strengths Bit-level precision Proven over 40 years Multiple encoding options Formal verification possible Weaknesses Complex specification Steep learning curve Tooling can be expensive Security vulnerabilities in parsers (historically) ELI5 Same idea as Protobuf—everyone agrees upfront what each field number means. ASN.1 just got there 20 years earlier and handles even more edge cases. When to Use You probably won’t choose ASN.1 for new projects. You’ll encounter it in cryptography, certificates, and legacy telecom systems. YAML: Human-Friendly Configuration Created: 2001 (Clark Evans, Ingy döt Net, Oren Ben-Kiki) Specification: yaml.org/spec/1.2.2 File Extension: .yaml, .yml YAML (YAML Ain’t Markup Language) prioritizes human readability. It’s a superset of JSON—any valid JSON is valid YAML. Technical Details # Comments allowed! server: host: localhost port: 8080 features: - auth - logging Key Features Indentation-based: Whitespace matters Comments: # for single-line Anchors/aliases: &amp;name and *name for references Multiple documents: --- separator Strengths Highly readable Comments supported Multi-line strings without escaping Complex data structures Weaknesses “Norway problem”: NO parses as boolean false Whitespace sensitivity causes errors Multiple ways to express same data Security concerns (arbitrary code execution in some parsers) ELI5 Optimized for clarity, not bandwidth. YAML is for humans editing config files—not for machines exchanging data over networks. When to Use Configuration files (Kubernetes, Docker Compose, CI/CD), anywhere humans edit data directly and comments help. TOML: Minimal Configuration Created: 2013 (Tom Preston-Werner) Specification: toml.io File Extension: .toml TOML (Tom’s Obvious Minimal Language) emerged as a reaction to YAML’s complexity. It’s used by Rust (Cargo.toml), Python (pyproject.toml), and others. Technical Details [server] host = "localhost" port = 8080 [server.features] auth = true logging = true Key Features Explicit typing: Dates, times, arrays have clear syntax Sections: [section] and [section.subsection] No anchors: Intentionally simpler than YAML Deterministic: Same data = same representation Strengths Easy to read and write Unambiguous parsing Clear error messages Growing ecosystem support Weaknesses Less expressive than YAML Nested structures can be verbose Smaller ecosystem than JSON/YAML ELI5 Same goal as YAML—clarity for humans, not bandwidth for machines—but with stricter rules so you make fewer mistakes. When to Use Configuration files where YAML’s complexity isn’t needed. Rust projects (mandatory). Python packaging (pyproject.toml). TOON: Token-Optimized for LLMs Created: October 2025 (toon-format organization) Specification: github.com/toon-format/toon (v3.0) File Extension: .toon Media Type: text/toon (provisional) TOON (Token Oriented Object Notation) is the newest format in this list, designed specifically for LLM input. It’s a lossless representation of JSON that minimizes tokens. Technical Details TOON combines YAML-style indentation for nested objects with CSV-like tabular layouts for uniform arrays: users[2]{name,age}: Alice,25 Bob,30 Equivalent JSON: {"users": [{"name": "Alice", "age": 25}, {"name": "Bob", "age": 30}]} Key Features Header-based: Field names declared once, values follow 40% fewer tokens: Than equivalent JSON typically Lossless: Round-trips to JSON perfectly UTF-8 always: No encoding ambiguity Performance Metric JSON TOON Accuracy 69.7% 73.9% Efficiency (acc/1K tokens) 15.3 26.9 Strengths Significant token savings at scale Better context window utilization Lower API costs for LLM applications Human-readable (unlike binary formats) Weaknesses New format (October 2025) Limited tooling compared to JSON Requires conversion layer for existing systems Not yet widely adopted ELI5 Like having one header row for each column in a table instead of repeating the column name for every single row. You declare field names once, then just list the values. When to Use LLM prompts with structured data, RAG applications, anywhere token efficiency matters. Especially useful for large datasets with uniform object arrays. Implementations TypeScript: Reference implementation Python: toons (Rust-based, fast) Go, Rust, .NET: Available via toon-format org Alternatives Not in the Video MessagePack Created: 2008 (Sadayuki Furuhashi) Specification: msgpack.org Binary JSON without schema. Type-prefixed values, efficient numeric encoding. Use when: You want JSON semantics but smaller/faster. CBOR Created: 2013 (IETF) Specification: RFC 8949 Concise Binary Object Representation. Designed for constrained environments (IoT). Use when: Resource-constrained devices, need a standard binary format. Apache Avro Created: 2009 (Apache, Doug Cutting) Specification: avro.apache.org Schema-based, row-oriented binary format. Schema embedded or stored separately. Strong schema evolution support. Use when: Big data pipelines (Hadoop, Kafka), schema evolution is critical. Apache Parquet Created: 2013 (Twitter + Cloudera) Specification: parquet.apache.org Columnar storage format. Not for serialization—for analytics storage. Use when: Large-scale analytics, data warehousing, Spark/Pandas workflows. Cap’n Proto Created: 2013 (Kenton Varda, ex-Protobuf author) Specification: capnproto.org Zero-copy serialization. The serialized form is the in-memory form. Use when: Extreme performance requirements, inter-process communication. FlatBuffers Created: 2014 (Google) Specification: google.github.io/flatbuffers Zero-copy like Cap’n Proto but with better tooling. Used in games, mobile. Use when: Games, mobile apps, anywhere memory allocation matters. Quick Reference Format Year Schema Binary Human-Readable Best For JSON 2001 No No Yes APIs, interchange JSONL 2013 No No Yes Logs, streaming JSONB 2014 No Yes No Database queries Protobuf 2008 Yes Yes No Microservices ASN.1 1984 Yes Yes No Crypto, telecom YAML 2001 No No Yes Config files TOML 2013 No No Yes Simple config TOON 2025 No No Yes LLM prompts MessagePack 2008 No Yes No Fast JSON CBOR 2013 Optional Yes No IoT Avro 2009 Yes Yes No Big data Key Takeaways No “best” format exists. Each optimizes for different constraints. Text formats favor humans. JSON, YAML, TOML prioritize readability over efficiency. Binary formats favor machines. Protobuf, MessagePack, CBOR prioritize compactness and speed. Schema formats favor correctness. Protobuf, Avro, ASN.1 catch errors at compile time. The tradeoff triangle is real. Readability, compactness, query performance—pick two. The question isn’t “which format wins?” The question is: what problem are you solving? Resources ECMA-404 JSON Specification RFC 8259 JSON JSON Lines Specification PostgreSQL JSONB Documentation Protocol Buffers Documentation YAML 1.2.2 Specification TOML v1.0.0 Specification RFC 8949 CBOR MessagePack Specification Apache Avro Specification Data formats are design decisions. Choose based on your constraints, not trends. Questions? Find me on YouTube @SoftwareWrighter.]]></summary></entry><entry><title type="html">Five ML Concepts - #18</title><link href="https://software-wrighter-lab.github.io/2026/02/21/five-ml-concepts-18/" rel="alternate" type="text/html" title="Five ML Concepts - #18" /><published>2026-02-21T00:00:00-08:00</published><updated>2026-02-21T00:00:00-08:00</updated><id>https://software-wrighter-lab.github.io/2026/02/21/five-ml-concepts-18</id><content type="html" xml:base="https://software-wrighter-lab.github.io/2026/02/21/five-ml-concepts-18/"><![CDATA[<p><img src="/assets/images/posts/block-eighteen.png" class="post-marker" alt="" /></p>

<p>5 machine learning concepts. Under 30 seconds each.</p>

<div class="resource-box">

  <table>
    <thead>
      <tr>
        <th>Resource</th>
        <th>Link</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Papers</strong></td>
        <td>Links in References section</td>
      </tr>
      <tr>
        <td><strong>Video</strong></td>
        <td><a href="https://www.youtube.com/shorts/osj1GQxG4uo">Five ML Concepts #18</a><br /><a href="https://www.youtube.com/shorts/osj1GQxG4uo"><img src="https://img.youtube.com/vi/osj1GQxG4uo/mqdefault.jpg" alt="Video" class="video-thumb" /></a></td>
      </tr>
    </tbody>
  </table>

</div>

<div class="references-section">

  <h2 id="references">References</h2>

  <table>
    <thead>
      <tr>
        <th>Concept</th>
        <th>Reference</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Preference Learning</strong></td>
        <td><a href="https://arxiv.org/abs/2009.01325">Learning to summarize from human feedback</a> (Stiennon et al. 2020)</td>
      </tr>
      <tr>
        <td><strong>Ensembling</strong></td>
        <td><a href="https://link.springer.com/chapter/10.1007/3-540-45014-9_1">Ensemble Methods in Machine Learning</a> (Dietterich 2000)</td>
      </tr>
      <tr>
        <td><strong>ML Fragility</strong></td>
        <td><a href="https://arxiv.org/abs/1903.12261">Distribution Shift</a> (Quinonero-Candela et al. 2009)</td>
      </tr>
      <tr>
        <td><strong>Epoch</strong></td>
        <td><a href="https://www.deeplearningbook.org/">Deep Learning</a> (Goodfellow et al. 2016), Chapter 8</td>
      </tr>
      <tr>
        <td><strong>Cost vs Quality</strong></td>
        <td><a href="https://arxiv.org/abs/2009.06732">Efficient Transformers: A Survey</a> (Tay et al. 2022)</td>
      </tr>
    </tbody>
  </table>

</div>

<h2 id="todays-five">Today’s Five</h2>

<h3 id="1-preference-learning">1. Preference Learning</h3>

<p><strong>Instead of learning from fixed labels, models are trained from comparisons between outputs.</strong> This helps align model behavior with human judgments.</p>

<p>The approach works well when absolute quality is hard to define but relative preferences are easier to express.</p>

<blockquote>
  <p>Like learning to cook by asking which dish tastes better.</p>
</blockquote>

<h3 id="2-ensembling">2. Ensembling</h3>

<p><strong>Ensembling combines predictions from multiple models.</strong> Different models make different errors, and combining them can improve robustness.</p>

<p>Common strategies include voting, averaging, and stacking models together.</p>

<blockquote>
  <p>Like asking several experts and averaging their opinions.</p>
</blockquote>

<h3 id="3-why-ml-is-fragile">3. Why ML Is Fragile</h3>

<p><strong>Models rely on statistical patterns learned from data.</strong> When those patterns shift, performance can degrade quickly.</p>

<p>This fragility emerges because models optimize for training distributions, not arbitrary future scenarios.</p>

<blockquote>
  <p>Like a spell checker that works on common words but struggles with unusual ones.</p>
</blockquote>

<h3 id="4-epoch">4. Epoch</h3>

<p><strong>An epoch is one complete pass through the training dataset.</strong> Multiple epochs allow the model to refine its weights over repeated passes.</p>

<p>Training typically continues for many epochs until validation performance stops improving.</p>

<blockquote>
  <p>Like reading a textbook from beginning to end more than once.</p>
</blockquote>

<h3 id="5-cost-vs-quality-tradeoffs">5. Cost vs Quality Tradeoffs</h3>

<p><strong>Increasing model size or compute often improves performance, but also increases cost and latency.</strong> Engineers balance quality against budget and responsiveness.</p>

<p>Production systems often use smaller, faster models rather than the largest available.</p>

<blockquote>
  <p>Like choosing between a luxury car and an economy car depending on your needs.</p>
</blockquote>

<h2 id="quick-reference">Quick Reference</h2>

<table>
  <thead>
    <tr>
      <th>Concept</th>
      <th>One-liner</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Preference Learning</strong></td>
      <td>Train from comparisons, not labels</td>
    </tr>
    <tr>
      <td><strong>Ensembling</strong></td>
      <td>Combine models for robustness</td>
    </tr>
    <tr>
      <td><strong>ML Fragility</strong></td>
      <td>Statistical models break on distribution shift</td>
    </tr>
    <tr>
      <td><strong>Epoch</strong></td>
      <td>One pass through training data</td>
    </tr>
    <tr>
      <td><strong>Cost vs Quality</strong></td>
      <td>Bigger isn’t always better in production</td>
    </tr>
  </tbody>
</table>

<hr />

<table>
  <tbody>
    <tr>
      <td>*Part 18 of the Five ML Concepts series. <a href="/series/#five-ml-concepts">View all parts</a></td>
      <td><a href="/2026/02/22/five-ml-concepts-19/">Next: #19 →</a>*</td>
    </tr>
  </tbody>
</table>

<p><em>Short, accurate ML explainers. Follow for more.</em></p>]]></content><author><name>Software Wrighter</name></author><category term="llm" /><category term="machine-learning" /><category term="explainers" /><category term="five-ml-concepts" /><category term="preference-learning" /><category term="ensembling" /><category term="ml-fragility" /><category term="epoch" /><category term="cost-quality-tradeoffs" /><category term="ml-concepts" /><summary type="html"><![CDATA[5 machine learning concepts. Under 30 seconds each. Resource Link Papers Links in References section Video Five ML Concepts #18 References Concept Reference Preference Learning Learning to summarize from human feedback (Stiennon et al. 2020) Ensembling Ensemble Methods in Machine Learning (Dietterich 2000) ML Fragility Distribution Shift (Quinonero-Candela et al. 2009) Epoch Deep Learning (Goodfellow et al. 2016), Chapter 8 Cost vs Quality Efficient Transformers: A Survey (Tay et al. 2022) Today’s Five 1. Preference Learning Instead of learning from fixed labels, models are trained from comparisons between outputs. This helps align model behavior with human judgments. The approach works well when absolute quality is hard to define but relative preferences are easier to express. Like learning to cook by asking which dish tastes better. 2. Ensembling Ensembling combines predictions from multiple models. Different models make different errors, and combining them can improve robustness. Common strategies include voting, averaging, and stacking models together. Like asking several experts and averaging their opinions. 3. Why ML Is Fragile Models rely on statistical patterns learned from data. When those patterns shift, performance can degrade quickly. This fragility emerges because models optimize for training distributions, not arbitrary future scenarios. Like a spell checker that works on common words but struggles with unusual ones. 4. Epoch An epoch is one complete pass through the training dataset. Multiple epochs allow the model to refine its weights over repeated passes. Training typically continues for many epochs until validation performance stops improving. Like reading a textbook from beginning to end more than once. 5. Cost vs Quality Tradeoffs Increasing model size or compute often improves performance, but also increases cost and latency. Engineers balance quality against budget and responsiveness. Production systems often use smaller, faster models rather than the largest available. Like choosing between a luxury car and an economy car depending on your needs. Quick Reference Concept One-liner Preference Learning Train from comparisons, not labels Ensembling Combine models for robustness ML Fragility Statistical models break on distribution shift Epoch One pass through training data Cost vs Quality Bigger isn’t always better in production *Part 18 of the Five ML Concepts series. View all parts Next: #19 →* Short, accurate ML explainers. Follow for more.]]></summary></entry><entry><title type="html">Five ML Concepts - #17</title><link href="https://software-wrighter-lab.github.io/2026/02/20/five-ml-concepts-17/" rel="alternate" type="text/html" title="Five ML Concepts - #17" /><published>2026-02-20T00:00:00-08:00</published><updated>2026-02-20T00:00:00-08:00</updated><id>https://software-wrighter-lab.github.io/2026/02/20/five-ml-concepts-17</id><content type="html" xml:base="https://software-wrighter-lab.github.io/2026/02/20/five-ml-concepts-17/"><![CDATA[<p><img src="/assets/images/posts/block-seventeen.png" class="post-marker" alt="" /></p>

<p>5 machine learning concepts. Under 30 seconds each.</p>

<div class="resource-box">

  <table>
    <thead>
      <tr>
        <th>Resource</th>
        <th>Link</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Papers</strong></td>
        <td>Links in References section</td>
      </tr>
      <tr>
        <td><strong>Video</strong></td>
        <td><a href="https://www.youtube.com/shorts/Xk2hkc0bgi4">Five ML Concepts #17</a><br /><a href="https://www.youtube.com/shorts/Xk2hkc0bgi4"><img src="https://img.youtube.com/vi/Xk2hkc0bgi4/mqdefault.jpg" alt="Video" class="video-thumb" /></a></td>
      </tr>
    </tbody>
  </table>

</div>

<div class="references-section">

  <h2 id="references">References</h2>

  <table>
    <thead>
      <tr>
        <th>Concept</th>
        <th>Reference</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Benchmark Leakage</strong></td>
        <td><a href="https://arxiv.org/abs/1512.00567">Rethinking the Inception Architecture for Computer Vision</a> (Szegedy et al. 2016)</td>
      </tr>
      <tr>
        <td><strong>Concept/Data Drift</strong></td>
        <td><a href="https://ieeexplore.ieee.org/document/8496795">Learning under Concept Drift: A Review</a> (Lu et al. 2018)</td>
      </tr>
      <tr>
        <td><strong>Weight Decay</strong></td>
        <td><a href="https://arxiv.org/abs/1711.05101">Decoupled Weight Decay Regularization</a> (Loshchilov &amp; Hutter 2019)</td>
      </tr>
      <tr>
        <td><strong>Scaling Laws</strong></td>
        <td><a href="https://arxiv.org/abs/2001.08361">Scaling Laws for Neural Language Models</a> (Kaplan et al. 2020)</td>
      </tr>
      <tr>
        <td><strong>Shadow Deployment</strong></td>
        <td><a href="https://www.oreilly.com/library/view/reliable-machine-learning/9781098106218/">Reliable Machine Learning</a> (Cathy Chen et al. 2022)</td>
      </tr>
    </tbody>
  </table>

</div>

<h2 id="todays-five">Today’s Five</h2>

<h3 id="1-benchmark-leakage">1. Benchmark Leakage</h3>

<p><strong>When benchmark or test data influences training, tuning, or model selection, evaluation results become unreliable.</strong> This inflates reported performance beyond real-world capability.</p>

<p>Strict separation between development and evaluation data is essential for honest assessment.</p>

<blockquote>
  <p>Like practicing with the exact questions that will appear on the final exam.</p>
</blockquote>

<h3 id="2-concept-drift-vs-data-drift">2. Concept Drift vs Data Drift</h3>

<p><strong>Data drift occurs when input distributions change. Concept drift occurs when the relationship between inputs and outputs changes.</strong> Both can degrade model performance over time.</p>

<p>Data drift: customers buy different products. Concept drift: what “good” means has changed.</p>

<blockquote>
  <p>Like customers buying different products versus products changing what they mean.</p>
</blockquote>

<h3 id="3-weight-decay">3. Weight Decay</h3>

<p><strong>A regularization method that penalizes large weights, often implemented as L2 regularization.</strong> This encourages simpler models that generalize better.</p>

<p>Weight decay adds a term proportional to the squared magnitude of weights to the loss function.</p>

<blockquote>
  <p>Like encouraging shorter, simpler answers instead of overly complicated ones.</p>
</blockquote>

<h3 id="4-scaling-laws">4. Scaling Laws</h3>

<p><strong>Empirical relationships showing how performance tends to improve as model size, data, or compute increase.</strong> These relationships follow predictable power-law curves.</p>

<p>Scaling laws help predict resource requirements for target performance levels.</p>

<blockquote>
  <p>Like noticing that adding horsepower often increases a car’s speed, but with diminishing returns.</p>
</blockquote>

<h3 id="5-shadow-deployment">5. Shadow Deployment</h3>

<p><strong>Running a new model in parallel with production without affecting live user decisions.</strong> The shadow model processes real traffic but its outputs are only logged, not served.</p>

<p>This allows safe evaluation before full deployment.</p>

<blockquote>
  <p>Like a new chef preparing the same dishes in the back kitchen before serving customers.</p>
</blockquote>

<h2 id="quick-reference">Quick Reference</h2>

<table>
  <thead>
    <tr>
      <th>Concept</th>
      <th>One-liner</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Benchmark Leakage</strong></td>
      <td>Test data contaminating training/selection</td>
    </tr>
    <tr>
      <td><strong>Concept vs Data Drift</strong></td>
      <td>Changed relationships vs changed inputs</td>
    </tr>
    <tr>
      <td><strong>Weight Decay</strong></td>
      <td>L2 penalty discourages large weights</td>
    </tr>
    <tr>
      <td><strong>Scaling Laws</strong></td>
      <td>Performance scales predictably with resources</td>
    </tr>
    <tr>
      <td><strong>Shadow Deployment</strong></td>
      <td>Test safely alongside production</td>
    </tr>
  </tbody>
</table>

<hr />

<table>
  <tbody>
    <tr>
      <td>*Part 17 of the Five ML Concepts series. <a href="/series/#five-ml-concepts">View all parts</a></td>
      <td><a href="/2026/02/21/five-ml-concepts-18/">Next: #18 →</a>*</td>
    </tr>
  </tbody>
</table>

<p><em>Short, accurate ML explainers. Follow for more.</em></p>]]></content><author><name>Software Wrighter</name></author><category term="llm" /><category term="machine-learning" /><category term="explainers" /><category term="five-ml-concepts" /><category term="benchmark-leakage" /><category term="concept-drift" /><category term="data-drift" /><category term="weight-decay" /><category term="scaling-laws" /><category term="shadow-deployment" /><category term="ml-concepts" /><summary type="html"><![CDATA[5 machine learning concepts. Under 30 seconds each. Resource Link Papers Links in References section Video Five ML Concepts #17 References Concept Reference Benchmark Leakage Rethinking the Inception Architecture for Computer Vision (Szegedy et al. 2016) Concept/Data Drift Learning under Concept Drift: A Review (Lu et al. 2018) Weight Decay Decoupled Weight Decay Regularization (Loshchilov &amp; Hutter 2019) Scaling Laws Scaling Laws for Neural Language Models (Kaplan et al. 2020) Shadow Deployment Reliable Machine Learning (Cathy Chen et al. 2022) Today’s Five 1. Benchmark Leakage When benchmark or test data influences training, tuning, or model selection, evaluation results become unreliable. This inflates reported performance beyond real-world capability. Strict separation between development and evaluation data is essential for honest assessment. Like practicing with the exact questions that will appear on the final exam. 2. Concept Drift vs Data Drift Data drift occurs when input distributions change. Concept drift occurs when the relationship between inputs and outputs changes. Both can degrade model performance over time. Data drift: customers buy different products. Concept drift: what “good” means has changed. Like customers buying different products versus products changing what they mean. 3. Weight Decay A regularization method that penalizes large weights, often implemented as L2 regularization. This encourages simpler models that generalize better. Weight decay adds a term proportional to the squared magnitude of weights to the loss function. Like encouraging shorter, simpler answers instead of overly complicated ones. 4. Scaling Laws Empirical relationships showing how performance tends to improve as model size, data, or compute increase. These relationships follow predictable power-law curves. Scaling laws help predict resource requirements for target performance levels. Like noticing that adding horsepower often increases a car’s speed, but with diminishing returns. 5. Shadow Deployment Running a new model in parallel with production without affecting live user decisions. The shadow model processes real traffic but its outputs are only logged, not served. This allows safe evaluation before full deployment. Like a new chef preparing the same dishes in the back kitchen before serving customers. Quick Reference Concept One-liner Benchmark Leakage Test data contaminating training/selection Concept vs Data Drift Changed relationships vs changed inputs Weight Decay L2 penalty discourages large weights Scaling Laws Performance scales predictably with resources Shadow Deployment Test safely alongside production *Part 17 of the Five ML Concepts series. View all parts Next: #18 →* Short, accurate ML explainers. Follow for more.]]></summary></entry></feed>