<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Deepseek Papers (1/3): mHC - Training Stability at Any Depth | Software Wrighter Lab Blog</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Deepseek Papers (1/3): mHC - Training Stability at Any Depth" />
<meta name="author" content="Software Wrighter" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Deepseek publishes papers. I implement them. This paper tackles a fundamental transformer problem: training stability in deep networks. This post covers my implementation of mHC (Manifold-Constrained Hyper-Connections)—running on both Apple Silicon and NVIDIA GPUs. Resource Link Paper arXiv:2512.24880 Code mHC-poc ELI5 eli5-mHC.md ELI4 eli4-mHC.md Video 1 mHC Demo Video 2 mHC Explained Video 3 mHC Results The Problem: Deep Networks Explode Residual connections revolutionized deep learning. Skip connections let gradients flow through hundreds of layers. But there’s a catch. Standard residual connections: output = layer(input) + input This works, but the signal accumulates. With many layers, small amplifications compound into instability. Hyper-Connections (HC) tried to fix this by learning connection weights: output = α₁ × layer(input) + α₂ × input Better expressiveness, but learned weights can still cause explosion. At 48 layers, HC becomes unstable. The mHC Solution: Doubly-Stochastic Constraints mHC constrains the connection weights using Sinkhorn-Knopp iteration—a mathematical technique that ensures weights form a doubly-stochastic matrix. What does “doubly-stochastic” mean? Each row sums to 1 Each column sums to 1 This bounds the total signal flow. No matter how deep the network, amplification stays controlled. # Sinkhorn-Knopp iteration (simplified) def make_doubly_stochastic(weights, iterations=5): for _ in range(iterations): weights = weights / weights.sum(dim=0) # Column normalize weights = weights / weights.sum(dim=1) # Row normalize return weights Results: Stability at Depth The mHC-poc repo stress-tests this with a depth sweep: Depth Baseline HC mHC 12 layers Stable Stable Stable 24 layers Struggling Stable Stable 48 layers Oscillating Explodes Stable At 48 layers: HC gain proxy: 10²⁷ (catastrophic amplification) mHC gain proxy: 10⁻⁰·⁶ (bounded, healthy) HC’s final loss at 48 layers: 5.54 (never learns) mHC’s final loss at 48 layers: 0.0002 (perfect convergence) Cross-Platform Validation The implementation runs on both Apple Silicon (MLX) and NVIDIA (PyTorch/CUDA): Metric MLX (Apple) CUDA (NVIDIA) Gain Proxy (24L) -0.6 -0.602 Gradient Stability Stable Stable NaN Events 0 0 Identical results confirm the Sinkhorn-Knopp projection works correctly on both platforms. Running the mHC Demo git clone https://github.com/softwarewrighter/mHC-poc cd mHC-poc # Apple Silicon (MLX) uv venv &amp;&amp; source .venv/bin/activate uv pip install -r mlx/requirements.txt bash scripts/run_depth_sweep.sh # NVIDIA (CUDA) cd cuda uv venv &amp;&amp; source .venv/bin/activate uv pip install -r requirements.txt bash scripts/run_cuda_depth_sweep.sh Results go to runs/ with plots showing loss, gradient norms, and gain proxy across depths. Implementation Details Metric Value Primary Language Python Source Files 29 .py, 3 .sh, 10 .yaml Estimated Size ~2.5 KLOC Frameworks MLX, PyTorch Platforms Apple Silicon, NVIDIA CUDA Key Features Depth sweep, cross-platform validation, visualization Good for you if: You want to understand mHC’s stability benefits, compare MLX vs PyTorch implementations, or experiment with residual connection variants. Complexity: Moderate. Well-documented with ELI5 explanations in docs/. Requires understanding of residual connections and matrix constraints. Key Takeaways mHC solves deep network instability. Doubly-stochastic constraints bound signal amplification at any depth. Cross-platform matters. The repo runs on Apple Silicon and NVIDIA, validated to produce identical results. Deepseek publishes useful research. Their papers address real problems with practical solutions. What’s Next Part 2 covers Engram—Deepseek’s approach to reducing redundant computation through conditional memory. Resources mHC Paper (arXiv:2512.24880) mHC-poc Repository mHC Video Demo mHC Explained mHC Results *Part 1 of 3 in the Deepseek Papers series. View all parts Next: Part 2 →* Implementing papers is the best way to understand them. Clone the repo and run the demo yourself." />
<meta property="og:description" content="Deepseek publishes papers. I implement them. This paper tackles a fundamental transformer problem: training stability in deep networks. This post covers my implementation of mHC (Manifold-Constrained Hyper-Connections)—running on both Apple Silicon and NVIDIA GPUs. Resource Link Paper arXiv:2512.24880 Code mHC-poc ELI5 eli5-mHC.md ELI4 eli4-mHC.md Video 1 mHC Demo Video 2 mHC Explained Video 3 mHC Results The Problem: Deep Networks Explode Residual connections revolutionized deep learning. Skip connections let gradients flow through hundreds of layers. But there’s a catch. Standard residual connections: output = layer(input) + input This works, but the signal accumulates. With many layers, small amplifications compound into instability. Hyper-Connections (HC) tried to fix this by learning connection weights: output = α₁ × layer(input) + α₂ × input Better expressiveness, but learned weights can still cause explosion. At 48 layers, HC becomes unstable. The mHC Solution: Doubly-Stochastic Constraints mHC constrains the connection weights using Sinkhorn-Knopp iteration—a mathematical technique that ensures weights form a doubly-stochastic matrix. What does “doubly-stochastic” mean? Each row sums to 1 Each column sums to 1 This bounds the total signal flow. No matter how deep the network, amplification stays controlled. # Sinkhorn-Knopp iteration (simplified) def make_doubly_stochastic(weights, iterations=5): for _ in range(iterations): weights = weights / weights.sum(dim=0) # Column normalize weights = weights / weights.sum(dim=1) # Row normalize return weights Results: Stability at Depth The mHC-poc repo stress-tests this with a depth sweep: Depth Baseline HC mHC 12 layers Stable Stable Stable 24 layers Struggling Stable Stable 48 layers Oscillating Explodes Stable At 48 layers: HC gain proxy: 10²⁷ (catastrophic amplification) mHC gain proxy: 10⁻⁰·⁶ (bounded, healthy) HC’s final loss at 48 layers: 5.54 (never learns) mHC’s final loss at 48 layers: 0.0002 (perfect convergence) Cross-Platform Validation The implementation runs on both Apple Silicon (MLX) and NVIDIA (PyTorch/CUDA): Metric MLX (Apple) CUDA (NVIDIA) Gain Proxy (24L) -0.6 -0.602 Gradient Stability Stable Stable NaN Events 0 0 Identical results confirm the Sinkhorn-Knopp projection works correctly on both platforms. Running the mHC Demo git clone https://github.com/softwarewrighter/mHC-poc cd mHC-poc # Apple Silicon (MLX) uv venv &amp;&amp; source .venv/bin/activate uv pip install -r mlx/requirements.txt bash scripts/run_depth_sweep.sh # NVIDIA (CUDA) cd cuda uv venv &amp;&amp; source .venv/bin/activate uv pip install -r requirements.txt bash scripts/run_cuda_depth_sweep.sh Results go to runs/ with plots showing loss, gradient norms, and gain proxy across depths. Implementation Details Metric Value Primary Language Python Source Files 29 .py, 3 .sh, 10 .yaml Estimated Size ~2.5 KLOC Frameworks MLX, PyTorch Platforms Apple Silicon, NVIDIA CUDA Key Features Depth sweep, cross-platform validation, visualization Good for you if: You want to understand mHC’s stability benefits, compare MLX vs PyTorch implementations, or experiment with residual connection variants. Complexity: Moderate. Well-documented with ELI5 explanations in docs/. Requires understanding of residual connections and matrix constraints. Key Takeaways mHC solves deep network instability. Doubly-stochastic constraints bound signal amplification at any depth. Cross-platform matters. The repo runs on Apple Silicon and NVIDIA, validated to produce identical results. Deepseek publishes useful research. Their papers address real problems with practical solutions. What’s Next Part 2 covers Engram—Deepseek’s approach to reducing redundant computation through conditional memory. Resources mHC Paper (arXiv:2512.24880) mHC-poc Repository mHC Video Demo mHC Explained mHC Results *Part 1 of 3 in the Deepseek Papers series. View all parts Next: Part 2 →* Implementing papers is the best way to understand them. Clone the repo and run the demo yourself." />
<link rel="canonical" href="http://localhost:5907/2026/02/01/deepseek-papers-part1-mhc/" />
<meta property="og:url" content="http://localhost:5907/2026/02/01/deepseek-papers-part1-mhc/" />
<meta property="og:site_name" content="Software Wrighter Lab Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2026-02-01T00:00:00-08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Deepseek Papers (1/3): mHC - Training Stability at Any Depth" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Software Wrighter"},"dateModified":"2026-02-01T00:00:00-08:00","datePublished":"2026-02-01T00:00:00-08:00","description":"Deepseek publishes papers. I implement them. This paper tackles a fundamental transformer problem: training stability in deep networks. This post covers my implementation of mHC (Manifold-Constrained Hyper-Connections)—running on both Apple Silicon and NVIDIA GPUs. Resource Link Paper arXiv:2512.24880 Code mHC-poc ELI5 eli5-mHC.md ELI4 eli4-mHC.md Video 1 mHC Demo Video 2 mHC Explained Video 3 mHC Results The Problem: Deep Networks Explode Residual connections revolutionized deep learning. Skip connections let gradients flow through hundreds of layers. But there’s a catch. Standard residual connections: output = layer(input) + input This works, but the signal accumulates. With many layers, small amplifications compound into instability. Hyper-Connections (HC) tried to fix this by learning connection weights: output = α₁ × layer(input) + α₂ × input Better expressiveness, but learned weights can still cause explosion. At 48 layers, HC becomes unstable. The mHC Solution: Doubly-Stochastic Constraints mHC constrains the connection weights using Sinkhorn-Knopp iteration—a mathematical technique that ensures weights form a doubly-stochastic matrix. What does “doubly-stochastic” mean? Each row sums to 1 Each column sums to 1 This bounds the total signal flow. No matter how deep the network, amplification stays controlled. # Sinkhorn-Knopp iteration (simplified) def make_doubly_stochastic(weights, iterations=5): for _ in range(iterations): weights = weights / weights.sum(dim=0) # Column normalize weights = weights / weights.sum(dim=1) # Row normalize return weights Results: Stability at Depth The mHC-poc repo stress-tests this with a depth sweep: Depth Baseline HC mHC 12 layers Stable Stable Stable 24 layers Struggling Stable Stable 48 layers Oscillating Explodes Stable At 48 layers: HC gain proxy: 10²⁷ (catastrophic amplification) mHC gain proxy: 10⁻⁰·⁶ (bounded, healthy) HC’s final loss at 48 layers: 5.54 (never learns) mHC’s final loss at 48 layers: 0.0002 (perfect convergence) Cross-Platform Validation The implementation runs on both Apple Silicon (MLX) and NVIDIA (PyTorch/CUDA): Metric MLX (Apple) CUDA (NVIDIA) Gain Proxy (24L) -0.6 -0.602 Gradient Stability Stable Stable NaN Events 0 0 Identical results confirm the Sinkhorn-Knopp projection works correctly on both platforms. Running the mHC Demo git clone https://github.com/softwarewrighter/mHC-poc cd mHC-poc # Apple Silicon (MLX) uv venv &amp;&amp; source .venv/bin/activate uv pip install -r mlx/requirements.txt bash scripts/run_depth_sweep.sh # NVIDIA (CUDA) cd cuda uv venv &amp;&amp; source .venv/bin/activate uv pip install -r requirements.txt bash scripts/run_cuda_depth_sweep.sh Results go to runs/ with plots showing loss, gradient norms, and gain proxy across depths. Implementation Details Metric Value Primary Language Python Source Files 29 .py, 3 .sh, 10 .yaml Estimated Size ~2.5 KLOC Frameworks MLX, PyTorch Platforms Apple Silicon, NVIDIA CUDA Key Features Depth sweep, cross-platform validation, visualization Good for you if: You want to understand mHC’s stability benefits, compare MLX vs PyTorch implementations, or experiment with residual connection variants. Complexity: Moderate. Well-documented with ELI5 explanations in docs/. Requires understanding of residual connections and matrix constraints. Key Takeaways mHC solves deep network instability. Doubly-stochastic constraints bound signal amplification at any depth. Cross-platform matters. The repo runs on Apple Silicon and NVIDIA, validated to produce identical results. Deepseek publishes useful research. Their papers address real problems with practical solutions. What’s Next Part 2 covers Engram—Deepseek’s approach to reducing redundant computation through conditional memory. Resources mHC Paper (arXiv:2512.24880) mHC-poc Repository mHC Video Demo mHC Explained mHC Results *Part 1 of 3 in the Deepseek Papers series. View all parts Next: Part 2 →* Implementing papers is the best way to understand them. Clone the repo and run the demo yourself.","headline":"Deepseek Papers (1/3): mHC - Training Stability at Any Depth","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:5907/2026/02/01/deepseek-papers-part1-mhc/"},"url":"http://localhost:5907/2026/02/01/deepseek-papers-part1-mhc/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:5907/feed.xml" title="Software Wrighter Lab Blog" /><!-- Theme toggle script - load early to prevent flash -->
  <script>
    (function() {
      var stored = localStorage.getItem('sw-lab-theme');
      var theme = stored;
      if (!theme) {
        theme = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
      }
      document.documentElement.setAttribute('data-theme', theme);
    })();
  </script>
  <!-- Font size - load early to prevent flash -->
  <script>
    (function() {
      var NEW_DEFAULT = 110;
      var OLD_DEFAULT = 150;
      var stored = localStorage.getItem('sw-lab-font-size');
      var ack = localStorage.getItem('sw-lab-prefs-ack');
      var size = stored ? parseInt(stored, 10) : null;

      // Migration: if on old default and not acknowledged, use new default
      if (size === OLD_DEFAULT && ack !== 'true') {
        size = NEW_DEFAULT;
      } else if (size === null) {
        size = NEW_DEFAULT;
      }

      // Apply to post content when DOM is ready
      document.addEventListener('DOMContentLoaded', function() {
        var pc = document.querySelector('.post-content');
        if (pc) pc.style.fontSize = size + '%';
        var pl = document.querySelector('.post-list');
        if (pl) pl.style.fontSize = size + '%';
      });
    })();
  </script>
  <script src="/assets/js/theme-toggle.js" defer></script>
  <script src="/assets/js/font-size.js" defer></script>
  <script src="/assets/js/preferences.js" defer></script>
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">
      <img src="/assets/images/site/logo.jpg" alt="Software Wrighter Lab Blog" class="site-logo">
      <span class="site-title-text">Software Wrighter Lab Blog</span>
    </a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/abstracts/">Abstracts</a><a class="page-link" href="/index-all/">Index</a><a class="page-link" href="/series/">Series</a><a class="page-link" href="/tags/">Tags</a><a class="page-link" href="/categories/">Categories</a><a class="page-link" href="/search/">Search</a><div class="font-size-controls">
  <button class="font-size-btn" id="font-decrease" title="Decrease font size" aria-label="Decrease font size">A-</button>
  <button class="font-size-btn" id="font-reset" title="Reset font size" aria-label="Reset font size">A</button>
  <button class="font-size-btn" id="font-increase" title="Increase font size" aria-label="Increase font size">A+</button>
</div>
<button class="theme-toggle" aria-label="Switch theme" title="Switch theme">
  <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
  </svg>
  <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
  </svg>
</button>
</div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Deepseek Papers (1/3): mHC - Training Stability at Any Depth</h1><p class="post-meta">February 1, 2026 &bull; Software Wrighter</p>
<p class="post-reading-info"><em><span class="post-word-count">784 words</span> &bull; <span class="post-read-time">4 min read</span></em> &bull; <span class="abstract-toggle" onclick="this.classList.toggle('open'); this.parentElement.nextElementSibling.classList.toggle('open')">Abstract</span></p><div class="post-meta-abstract">Implementing Deepseek's mHC (Manifold-Constrained Hyper-Connections) paper. Using Sinkhorn-Knopp iteration to create doubly-stochastic matrices, mHC maintains training stability at 48 layers where standard hyper-connections explode. Cross-platform validation on Apple Silicon and NVIDIA.</div><div class="post-taxonomies"><span class="post-categories"><a href="/categories/#llm" class="category">llm</a><a href="/categories/#machine-learning" class="category">machine-learning</a><a href="/categories/#research" class="category">research</a></span><span class="post-tags"><a href="/tags/#deepseek" class="tag">deepseek</a><a href="/tags/#mhc" class="tag">mhc</a><a href="/tags/#transformers" class="tag">transformers</a><a href="/tags/#apple-silicon" class="tag">apple-silicon</a><a href="/tags/#cuda" class="tag">cuda</a></span></div></header><nav class="toc" data-toc-id="default">
  <h4>Contents</h4>
  <ul class="toc-list"></ul>
</nav>

<style>
/* Post content flows around floated TOC */
.post-content {
  overflow: hidden;
}

.toc {
  background: #fffde7;
  border-radius: 8px;
  padding: 1rem 1.5rem;
  margin: 0 1.5rem 1rem 0;
  float: left;
  max-width: 280px;
}

[data-theme="dark"] .toc {
  background: #3d3a00;
}

@media (prefers-color-scheme: dark) {
  :root:not([data-theme="light"]) .toc {
    background: #3d3a00;
  }
}

.toc h4 {
  margin: 0 0 0.75rem 0;
  font-size: 1rem;
}

.toc ul {
  margin: 0;
  padding-left: 1.25rem;
  list-style-type: disc;
}

.toc li {
  margin: 0.25rem 0;
}

.toc li.toc-h3 {
  margin-left: 1rem;
  font-size: 0.95em;
}

.toc a {
  text-decoration: none;
}

.toc a:hover {
  text-decoration: underline;
}


@media (max-width: 600px) {
  .toc {
    float: none;
    max-width: 100%;
    margin: 0 0 1.5rem 0;
  }
}

/* References section that floats alongside TOC */
.references-float {
  overflow: hidden; /* contain floated content */
}

.references-float h2 {
  margin-top: 0;
  font-size: 1.25rem;
}

.references-float table {
  font-size: 0.9em;
  width: 100%;
}

.references-float td, .references-float th {
  padding: 0.4rem 0.6rem;
  vertical-align: top;
}

.references-float td:first-child {
  white-space: nowrap;
  font-weight: bold;
  width: 1%;
}

@media (max-width: 600px) {
  .references-float table {
    font-size: 0.85em;
  }
}
</style>

<script>
(function() {
  // Run after DOM is ready
  function initTOC() {
    document.querySelectorAll('.toc').forEach(function(toc) {
      if (toc.dataset.initialized) return;
      toc.dataset.initialized = 'true';

      const tocList = toc.querySelector('.toc-list');
      if (!tocList) return;

      // Find the associated post-content (next sibling or parent's post-content)
      let article = toc.nextElementSibling;
      while (article && !article.classList.contains('post-content')) {
        article = article.nextElementSibling;
      }
      // Fallback: look for .post-content in the document (single post page)
      if (!article) {
        article = document.querySelector('.post-content');
      }

      if (!article) {
        toc.style.display = 'none';
        return;
      }

      const headings = article.querySelectorAll('h2, h3');

      if (headings.length < 3) {
        toc.style.display = 'none';
        return;
      }

      const tocId = toc.dataset.tocId || Math.random().toString(36).substr(2, 9);

      headings.forEach(function(heading, index) {
        // Add unique ID if missing
        if (!heading.id) {
          heading.id = 'toc-' + tocId + '-heading-' + index;
        }

        const li = document.createElement('li');
        li.className = 'toc-' + heading.tagName.toLowerCase();

        const a = document.createElement('a');
        a.href = '#' + heading.id;
        a.textContent = heading.textContent;

        li.appendChild(a);
        tocList.appendChild(li);
      });
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initTOC);
  } else {
    initTOC();
  }
})();
</script>
<div class="post-content e-content" itemprop="articleBody">
    <p><img src="/assets/images/site/post-marker-stamp.png" class="post-marker" alt="" /></p>

<p>Deepseek publishes papers. I implement them. This paper tackles a fundamental transformer problem: training stability in deep networks.</p>

<p>This post covers my implementation of <strong>mHC</strong> (Manifold-Constrained Hyper-Connections)—running on both Apple Silicon and NVIDIA GPUs.</p>

<div class="resource-box">

  <table>
    <thead>
      <tr>
        <th>Resource</th>
        <th>Link</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Paper</strong></td>
        <td><a href="https://arxiv.org/abs/2512.24880">arXiv:2512.24880</a></td>
      </tr>
      <tr>
        <td><strong>Code</strong></td>
        <td><a href="https://github.com/softwarewrighter/mHC-poc">mHC-poc</a></td>
      </tr>
      <tr>
        <td><strong>ELI5</strong></td>
        <td><a href="https://github.com/softwarewrighter/mHC-poc/blob/main/docs/eli5-mHC.md">eli5-mHC.md</a></td>
      </tr>
      <tr>
        <td><strong>ELI4</strong></td>
        <td><a href="https://github.com/softwarewrighter/mHC-poc/blob/main/docs/eli4-mHC.md">eli4-mHC.md</a></td>
      </tr>
      <tr>
        <td><strong>Video 1</strong></td>
        <td><a href="https://youtube.com/shorts/fh21_zIK2ZE">mHC Demo</a><br /><a href="https://youtube.com/shorts/fh21_zIK2ZE"><img src="https://img.youtube.com/vi/fh21_zIK2ZE/mqdefault.jpg" alt="Video" class="video-thumb" /></a></td>
      </tr>
      <tr>
        <td><strong>Video 2</strong></td>
        <td><a href="https://www.youtube.com/watch?v=MYTXVYDtCEU">mHC Explained</a><br /><a href="https://www.youtube.com/watch?v=MYTXVYDtCEU"><img src="https://img.youtube.com/vi/MYTXVYDtCEU/mqdefault.jpg" alt="Video" class="video-thumb" /></a></td>
      </tr>
      <tr>
        <td><strong>Video 3</strong></td>
        <td><a href="https://youtube.com/shorts/BOuBFn5e1gA">mHC Results</a><br /><a href="https://youtube.com/shorts/BOuBFn5e1gA"><img src="https://img.youtube.com/vi/BOuBFn5e1gA/mqdefault.jpg" alt="Video" class="video-thumb" /></a></td>
      </tr>
    </tbody>
  </table>

</div>

<h2 id="the-problem-deep-networks-explode">The Problem: Deep Networks Explode</h2>

<p>Residual connections revolutionized deep learning. Skip connections let gradients flow through hundreds of layers. But there’s a catch.</p>

<p>Standard residual connections:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>output = layer(input) + input
</code></pre></div></div>

<p>This works, but the signal accumulates. With many layers, small amplifications compound into instability.</p>

<p><strong>Hyper-Connections (HC)</strong> tried to fix this by learning connection weights:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>output = α₁ × layer(input) + α₂ × input
</code></pre></div></div>

<p>Better expressiveness, but learned weights can still cause explosion. At 48 layers, HC becomes unstable.</p>

<h2 id="the-mhc-solution-doubly-stochastic-constraints">The mHC Solution: Doubly-Stochastic Constraints</h2>

<p>mHC constrains the connection weights using <strong>Sinkhorn-Knopp iteration</strong>—a mathematical technique that ensures weights form a doubly-stochastic matrix.</p>

<p>What does “doubly-stochastic” mean?</p>
<ul>
  <li>Each row sums to 1</li>
  <li>Each column sums to 1</li>
</ul>

<p>This bounds the total signal flow. No matter how deep the network, amplification stays controlled.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Sinkhorn-Knopp iteration (simplified)
</span><span class="k">def</span> <span class="nf">make_doubly_stochastic</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">iterations</span><span class="p">):</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">/</span> <span class="n">weights</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># Column normalize
</span>        <span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">/</span> <span class="n">weights</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Row normalize
</span>    <span class="k">return</span> <span class="n">weights</span>
</code></pre></div></div>

<h2 id="results-stability-at-depth">Results: Stability at Depth</h2>

<p>The <a href="https://github.com/softwarewrighter/mHC-poc">mHC-poc</a> repo stress-tests this with a depth sweep:</p>

<table>
  <thead>
    <tr>
      <th>Depth</th>
      <th>Baseline</th>
      <th>HC</th>
      <th>mHC</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>12 layers</td>
      <td>Stable</td>
      <td>Stable</td>
      <td>Stable</td>
    </tr>
    <tr>
      <td>24 layers</td>
      <td>Struggling</td>
      <td>Stable</td>
      <td>Stable</td>
    </tr>
    <tr>
      <td>48 layers</td>
      <td>Oscillating</td>
      <td><strong>Explodes</strong></td>
      <td><strong>Stable</strong></td>
    </tr>
  </tbody>
</table>

<p>At 48 layers:</p>
<ul>
  <li><strong>HC</strong> gain proxy: 10²⁷ (catastrophic amplification)</li>
  <li><strong>mHC</strong> gain proxy: 10⁻⁰·⁶ (bounded, healthy)</li>
</ul>

<p>HC’s final loss at 48 layers: <strong>5.54</strong> (never learns)
mHC’s final loss at 48 layers: <strong>0.0002</strong> (perfect convergence)</p>

<h2 id="cross-platform-validation">Cross-Platform Validation</h2>

<p>The implementation runs on both Apple Silicon (MLX) and NVIDIA (PyTorch/CUDA):</p>

<table>
  <thead>
    <tr>
      <th>Metric</th>
      <th>MLX (Apple)</th>
      <th>CUDA (NVIDIA)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Gain Proxy (24L)</td>
      <td>-0.6</td>
      <td>-0.602</td>
    </tr>
    <tr>
      <td>Gradient Stability</td>
      <td>Stable</td>
      <td>Stable</td>
    </tr>
    <tr>
      <td>NaN Events</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p>Identical results confirm the Sinkhorn-Knopp projection works correctly on both platforms.</p>

<h2 id="running-the-mhc-demo">Running the mHC Demo</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/softwarewrighter/mHC-poc
<span class="nb">cd </span>mHC-poc

<span class="c"># Apple Silicon (MLX)</span>
uv venv <span class="o">&amp;&amp;</span> <span class="nb">source</span> .venv/bin/activate
uv pip <span class="nb">install</span> <span class="nt">-r</span> mlx/requirements.txt
bash scripts/run_depth_sweep.sh

<span class="c"># NVIDIA (CUDA)</span>
<span class="nb">cd </span>cuda
uv venv <span class="o">&amp;&amp;</span> <span class="nb">source</span> .venv/bin/activate
uv pip <span class="nb">install</span> <span class="nt">-r</span> requirements.txt
bash scripts/run_cuda_depth_sweep.sh
</code></pre></div></div>

<p>Results go to <code class="language-plaintext highlighter-rouge">runs/</code> with plots showing loss, gradient norms, and gain proxy across depths.</p>

<h2 id="implementation-details">Implementation Details</h2>

<table>
  <thead>
    <tr>
      <th>Metric</th>
      <th>Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Primary Language</strong></td>
      <td>Python</td>
    </tr>
    <tr>
      <td><strong>Source Files</strong></td>
      <td>29 <code class="language-plaintext highlighter-rouge">.py</code>, 3 <code class="language-plaintext highlighter-rouge">.sh</code>, 10 <code class="language-plaintext highlighter-rouge">.yaml</code></td>
    </tr>
    <tr>
      <td><strong>Estimated Size</strong></td>
      <td>~2.5 KLOC</td>
    </tr>
    <tr>
      <td><strong>Frameworks</strong></td>
      <td>MLX, PyTorch</td>
    </tr>
    <tr>
      <td><strong>Platforms</strong></td>
      <td>Apple Silicon, NVIDIA CUDA</td>
    </tr>
    <tr>
      <td><strong>Key Features</strong></td>
      <td>Depth sweep, cross-platform validation, visualization</td>
    </tr>
  </tbody>
</table>

<p><strong>Good for you if:</strong> You want to understand mHC’s stability benefits, compare MLX vs PyTorch implementations, or experiment with residual connection variants.</p>

<p><strong>Complexity:</strong> Moderate. Well-documented with ELI5 explanations in <code class="language-plaintext highlighter-rouge">docs/</code>. Requires understanding of residual connections and matrix constraints.</p>

<h2 id="key-takeaways">Key Takeaways</h2>

<ol>
  <li>
    <p><strong>mHC solves deep network instability.</strong> Doubly-stochastic constraints bound signal amplification at any depth.</p>
  </li>
  <li>
    <p><strong>Cross-platform matters.</strong> The repo runs on Apple Silicon and NVIDIA, validated to produce identical results.</p>
  </li>
  <li>
    <p><strong>Deepseek publishes useful research.</strong> Their papers address real problems with practical solutions.</p>
  </li>
</ol>

<h2 id="whats-next">What’s Next</h2>

<p>Part 2 covers <strong>Engram</strong>—Deepseek’s approach to reducing redundant computation through conditional memory.</p>

<h2 id="resources">Resources</h2>

<ul>
  <li><a href="https://arxiv.org/abs/2512.24880">mHC Paper (arXiv:2512.24880)</a></li>
  <li><a href="https://github.com/softwarewrighter/mHC-poc">mHC-poc Repository</a></li>
  <li><a href="https://youtube.com/shorts/fh21_zIK2ZE">mHC Video Demo</a></li>
  <li><a href="https://www.youtube.com/watch?v=MYTXVYDtCEU">mHC Explained</a></li>
  <li><a href="https://youtube.com/shorts/BOuBFn5e1gA">mHC Results</a></li>
</ul>

<hr />

<table>
  <tbody>
    <tr>
      <td>*Part 1 of 3 in the Deepseek Papers series. <a href="/series/#deepseek-papers">View all parts</a></td>
      <td><a href="/2026/02/02/deepseek-papers-part2-engram/">Next: Part 2 →</a>*</td>
    </tr>
  </tbody>
</table>

<p><em>Implementing papers is the best way to understand them. Clone the repo and run the demo yourself.</em></p>

  </div><div class="series-nav">
    <p><em>Part 1 of the Deepseek Papers series. <a href="/series/#deepseek-papers">View all parts</a> | <a href="/2026/02/02/deepseek-papers-part2-engram/">Next: Part 2 →</a></em></p>
  </div>





<div class="youtube-embed-container" id="yt-container-fh21_zIK2ZE">
  <h3>Watch the Video</h3>
  <div class="youtube-embed-wrapper">
    <iframe
      id="yt-player-fh21_zIK2ZE"
      src="https://www.youtube.com/embed/fh21_zIK2ZE?enablejsapi=1&mute=1&autoplay=1&cc_load_policy=1"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      allowfullscreen
      loading="lazy">
    </iframe>
  </div>
  <p class="youtube-embed-note">Unmute to hear narration.</p>
</div>

<style>
.youtube-embed-container {
  margin: 2rem auto;
  padding: 1.5rem;
  background: var(--code-background-color, #f5f5f5);
  border-radius: 8px;
  width: 66%;
}

.youtube-embed-container h3 {
  margin-top: 0;
  margin-bottom: 1rem;
}

.youtube-embed-wrapper {
  position: relative;
  width: 100%;
  padding-bottom: 56.25%; /* 16:9 aspect ratio */
  height: 0;
  overflow: hidden;
}

.youtube-embed-wrapper iframe {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border-radius: 4px;
}

.youtube-embed-note {
  margin-top: 0.75rem;
  margin-bottom: 0;
  font-size: 0.85rem;
  color: var(--text-muted-color, #666);
  font-style: italic;
}
</style>

<script>
(function() {
  const containerId = 'yt-container-fh21_zIK2ZE';
  const playerId = 'yt-player-fh21_zIK2ZE';

  // Load YouTube IFrame API if not already loaded
  if (!window.YT) {
    const tag = document.createElement('script');
    tag.src = 'https://www.youtube.com/iframe_api';
    const firstScriptTag = document.getElementsByTagName('script')[0];
    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
  }

  let player;
  let isPlaying = false;

  function onYouTubeIframeAPIReady() {
    player = new YT.Player(playerId, {
      events: {
        'onReady': onPlayerReady
      }
    });
  }

  function onPlayerReady(event) {
    setupIntersectionObserver();
  }

  function setupIntersectionObserver() {
    const container = document.getElementById(containerId);
    if (!container) return;

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && entry.intersectionRatio >= 0.5) {
          if (!isPlaying && player && player.playVideo) {
            player.playVideo();
            isPlaying = true;
          }
        } else {
          if (isPlaying && player && player.pauseVideo) {
            player.pauseVideo();
            isPlaying = false;
          }
        }
      });
    }, {
      threshold: [0.5]
    });

    observer.observe(container);
  }

  // Handle API ready callback
  if (window.YT && window.YT.Player) {
    onYouTubeIframeAPIReady();
  } else {
    window.onYouTubeIframeAPIReady = window.onYouTubeIframeAPIReady || onYouTubeIframeAPIReady;
    // Queue multiple players if needed
    const existingCallback = window.onYouTubeIframeAPIReady;
    window.onYouTubeIframeAPIReady = function() {
      if (existingCallback) existingCallback();
      onYouTubeIframeAPIReady();
    };
  }
})();
</script>







<div class="youtube-embed-container" id="yt-container-MYTXVYDtCEU">
  <h3>Watch the Video</h3>
  <div class="youtube-embed-wrapper">
    <iframe
      id="yt-player-MYTXVYDtCEU"
      src="https://www.youtube.com/embed/MYTXVYDtCEU?enablejsapi=1&mute=1&autoplay=1&cc_load_policy=1"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      allowfullscreen
      loading="lazy">
    </iframe>
  </div>
  <p class="youtube-embed-note">Unmute to hear narration.</p>
</div>

<style>
.youtube-embed-container {
  margin: 2rem auto;
  padding: 1.5rem;
  background: var(--code-background-color, #f5f5f5);
  border-radius: 8px;
  width: 66%;
}

.youtube-embed-container h3 {
  margin-top: 0;
  margin-bottom: 1rem;
}

.youtube-embed-wrapper {
  position: relative;
  width: 100%;
  padding-bottom: 56.25%; /* 16:9 aspect ratio */
  height: 0;
  overflow: hidden;
}

.youtube-embed-wrapper iframe {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border-radius: 4px;
}

.youtube-embed-note {
  margin-top: 0.75rem;
  margin-bottom: 0;
  font-size: 0.85rem;
  color: var(--text-muted-color, #666);
  font-style: italic;
}
</style>

<script>
(function() {
  const containerId = 'yt-container-MYTXVYDtCEU';
  const playerId = 'yt-player-MYTXVYDtCEU';

  // Load YouTube IFrame API if not already loaded
  if (!window.YT) {
    const tag = document.createElement('script');
    tag.src = 'https://www.youtube.com/iframe_api';
    const firstScriptTag = document.getElementsByTagName('script')[0];
    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
  }

  let player;
  let isPlaying = false;

  function onYouTubeIframeAPIReady() {
    player = new YT.Player(playerId, {
      events: {
        'onReady': onPlayerReady
      }
    });
  }

  function onPlayerReady(event) {
    setupIntersectionObserver();
  }

  function setupIntersectionObserver() {
    const container = document.getElementById(containerId);
    if (!container) return;

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && entry.intersectionRatio >= 0.5) {
          if (!isPlaying && player && player.playVideo) {
            player.playVideo();
            isPlaying = true;
          }
        } else {
          if (isPlaying && player && player.pauseVideo) {
            player.pauseVideo();
            isPlaying = false;
          }
        }
      });
    }, {
      threshold: [0.5]
    });

    observer.observe(container);
  }

  // Handle API ready callback
  if (window.YT && window.YT.Player) {
    onYouTubeIframeAPIReady();
  } else {
    window.onYouTubeIframeAPIReady = window.onYouTubeIframeAPIReady || onYouTubeIframeAPIReady;
    // Queue multiple players if needed
    const existingCallback = window.onYouTubeIframeAPIReady;
    window.onYouTubeIframeAPIReady = function() {
      if (existingCallback) existingCallback();
      onYouTubeIframeAPIReady();
    };
  }
})();
</script>







<div class="youtube-embed-container" id="yt-container-BOuBFn5e1gA">
  <h3>Watch the Video</h3>
  <div class="youtube-embed-wrapper">
    <iframe
      id="yt-player-BOuBFn5e1gA"
      src="https://www.youtube.com/embed/BOuBFn5e1gA?enablejsapi=1&mute=1&autoplay=1&cc_load_policy=1"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      allowfullscreen
      loading="lazy">
    </iframe>
  </div>
  <p class="youtube-embed-note">Unmute to hear narration.</p>
</div>

<style>
.youtube-embed-container {
  margin: 2rem auto;
  padding: 1.5rem;
  background: var(--code-background-color, #f5f5f5);
  border-radius: 8px;
  width: 66%;
}

.youtube-embed-container h3 {
  margin-top: 0;
  margin-bottom: 1rem;
}

.youtube-embed-wrapper {
  position: relative;
  width: 100%;
  padding-bottom: 56.25%; /* 16:9 aspect ratio */
  height: 0;
  overflow: hidden;
}

.youtube-embed-wrapper iframe {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border-radius: 4px;
}

.youtube-embed-note {
  margin-top: 0.75rem;
  margin-bottom: 0;
  font-size: 0.85rem;
  color: var(--text-muted-color, #666);
  font-style: italic;
}
</style>

<script>
(function() {
  const containerId = 'yt-container-BOuBFn5e1gA';
  const playerId = 'yt-player-BOuBFn5e1gA';

  // Load YouTube IFrame API if not already loaded
  if (!window.YT) {
    const tag = document.createElement('script');
    tag.src = 'https://www.youtube.com/iframe_api';
    const firstScriptTag = document.getElementsByTagName('script')[0];
    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
  }

  let player;
  let isPlaying = false;

  function onYouTubeIframeAPIReady() {
    player = new YT.Player(playerId, {
      events: {
        'onReady': onPlayerReady
      }
    });
  }

  function onPlayerReady(event) {
    setupIntersectionObserver();
  }

  function setupIntersectionObserver() {
    const container = document.getElementById(containerId);
    if (!container) return;

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && entry.intersectionRatio >= 0.5) {
          if (!isPlaying && player && player.playVideo) {
            player.playVideo();
            isPlaying = true;
          }
        } else {
          if (isPlaying && player && player.pauseVideo) {
            player.pauseVideo();
            isPlaying = false;
          }
        }
      });
    }, {
      threshold: [0.5]
    });

    observer.observe(container);
  }

  // Handle API ready callback
  if (window.YT && window.YT.Player) {
    onYouTubeIframeAPIReady();
  } else {
    window.onYouTubeIframeAPIReady = window.onYouTubeIframeAPIReady || onYouTubeIframeAPIReady;
    // Queue multiple players if needed
    const existingCallback = window.onYouTubeIframeAPIReady;
    window.onYouTubeIframeAPIReady = function() {
      if (existingCallback) existingCallback();
      onYouTubeIframeAPIReady();
    };
  }
})();
</script>

<img src="/assets/images/site/post-separator.png" class="post-separator" alt=""><a class="u-url" href="/2026/02/01/deepseek-papers-part1-mhc/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Software Wrighter Lab Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Mike Wright</li><li><a class="u-email" href="mailto:"></a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/softwarewrighter"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">softwarewrighter</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>AI coding agents, systems programming, and practical machine learning</p>
      </div>
    </div>

    <div class="footer-copyright">
      <p>Copyright &copy; 2026 Michael A. Wright</p>
    </div>

  </div>

  <button id="scroll-to-top" aria-label="Scroll to top" title="Scroll to top">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="18 15 12 9 6 15"></polyline>
    </svg>
  </button>

  <style>
  #scroll-to-top {
    position: fixed;
    bottom: 2rem;
    right: 2rem;
    width: 44px;
    height: 44px;
    border-radius: 50%;
    border: none;
    background: var(--brand-color, #2a7ae2);
    color: white;
    cursor: pointer;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s, visibility 0.3s, transform 0.2s;
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
  }

  #scroll-to-top:hover {
    transform: scale(1.1);
  }

  #scroll-to-top.visible {
    opacity: 1;
    visibility: visible;
  }

  #scroll-to-top svg {
    width: 24px;
    height: 24px;
  }
  </style>

  <script>
  (function() {
    const btn = document.getElementById('scroll-to-top');
    if (!btn) return;

    window.addEventListener('scroll', function() {
      if (window.scrollY > 300) {
        btn.classList.add('visible');
      } else {
        btn.classList.remove('visible');
      }
    });

    btn.addEventListener('click', function() {
      window.scrollTo({ top: 0, behavior: 'smooth' });
    });
  })();
  </script>

</footer>
</body>

</html>
