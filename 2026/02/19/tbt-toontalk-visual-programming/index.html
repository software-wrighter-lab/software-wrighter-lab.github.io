<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>TBT (4/?): ToonTalk - Teaching Robots to Program | Software Wrighter Lab Blog</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="TBT (4/?): ToonTalk - Teaching Robots to Program" />
<meta name="author" content="Software Wrighter" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I first discovered ToonTalk during the Windows XP era—probably around 2003 or 2004. It was unlike anything I’d seen: a programming environment disguised as a video game where you trained robots by showing them what to do. The concept stuck with me for two decades. Resource Link Video ToonTalk in Rust tt-rs Demo Live Demo tt-rs Repo tt-rs What is ToonTalk? ToonTalk is a visual programming environment created by Ken Kahn in 1995. The “Toon” stands for cartoon—every abstract programming concept is mapped to a concrete, animated metaphor: Concept ToonTalk Metaphor Variables Boxes with numbered holes Values Numbers, text, images in boxes Comparison Scales that tip when values differ Functions Robots that watch and learn Message passing Birds that carry items to nests Garbage collection Trucks that haul away unused items The design was influenced by games like The Legend of Zelda and Robot Odyssey—the kind of games that made you think while you played. Programming by Demonstration The core idea is radical: you don’t write code, you show a robot what to do. Create a robot and put it in “training mode” Perform actions while the robot watches (move items, compare values, etc.) The robot records your actions as a program Give the robot a box matching the training pattern—it executes the learned behavior This is programming by demonstration. The robot generalizes from your example, matching patterns and applying transformations. It’s the same conceptual model as teaching a child: “Watch what I do, then you try.” Three Generations ToonTalk has existed in three forms: Version Era Technology Original ToonTalk 1995-2009 C++, 3D desktop application ToonTalk Reborn 2014-2017 JavaScript/jQuery web app tt-rs 2025-2026 Rust/WebAssembly/Yew The original was a full 3D world—cities, houses, helicopters, even bombs for debugging. Ken Kahn later created ToonTalk Reborn, a simplified JavaScript version that runs in browsers. Why I Built tt-rs When I rediscovered ToonTalk Reborn a few years ago, I wanted to experiment with the concepts myself. But diving into a large jQuery codebase wasn’t appealing. So I did what any reasonable person would do: I vibe coded my own version in Rust. tt-rs is a modern reimplementation using: Rust for core logic WebAssembly for browser execution Yew for reactive UI SVG/CSS for graphics and animations It’s not a port—it’s a fresh implementation inspired by the same ideas. Building it myself lets me understand the concepts deeply and experiment with variations. Three Learning Levels The demo introduces concepts progressively through three levels: Level Concepts Widgets tt1 Basics Numbers, boxes, scales, wand, vacuum tt2 Messaging Birds and nests for communication tt3 Automation Sensors (time, random) + robots Level one covers the fundamentals: numbers with arithmetic, boxes as containers, scales for comparison, and tools for copying and removing. Level two adds asynchronous messaging—birds carry items to their paired nests. Level three brings sensors that produce values and robots that automate actions. Current Features The live demo includes: Widgets: Numbers: Rational arithmetic with +, -, *, / operators Boxes: Configurable containers with 0-9 holes (resize with keyboard) Text: Basic text display Scales: Visual comparison that tips when values differ Robot: Training mode, action recording, execution Bird/Nest: Message passing with pairing and delivery Sensors: Time (milliseconds) and random number generation Tools: Wand: Copy any widget Vacuum: Remove widgets Magnifier: Inspect nest message queues and robot actions Interactions: Drag-and-drop with visual feedback Box joining (drop box on edge of another) Box splitting (drop box on a number) Contextual help panel with level-specific content Puzzle system with animated “Show Me” demos Robot Training The core feature is programming by demonstration: Click robot to enter training mode (yellow glow indicates “I’m watching”) Perform actions while the robot records (arithmetic, copy, remove, move to box) Click robot again to stop training Click robot to replay—it executes the recorded sequence The tutorials demonstrate this workflow step by step. In the “Train Robot” tutorial, you teach a robot to move a number into a box. In “Robot Sensors,” you train a robot to generate random numbers, apply modulo, and send results to a nest via a bird. Interactive Tutorials Each tutorial has two parts: Show Me: Watch an animated demonstration where a cursor walks through the solution Practice: Try it yourself with the same widgets The tutorials cover: Fill a box with numbers Add numbers together Copy widgets with the wand Send messages with birds and nests Train your first robot Combine robots with sensors What’s Next The immediate priorities: Pattern matching - Robot generalizes from specific values to “any number” Watched execution - See robot work step-by-step with animated cursor Persistence - Save and load workspaces Long term, I’d like to add the 3D elements from the original—the cities, the houses, the helicopter view. But that’s a much larger project. The Enduring Appeal What makes ToonTalk fascinating isn’t just the visual metaphors—it’s the computational model. Under the hood, ToonTalk implements concurrent constraint logic programming. The robots are essentially guarded Horn clauses. The birds and nests implement the actor model. Heavy concepts, but you don’t need to know any of that to use it. You just train robots by example. The abstraction is complete. That’s why it stuck with me for twenty years. Good abstractions are rare. When you find one, it’s worth understanding deeply. References Resource Link ToonTalk Website toontalk.com ToonTalk on Wikipedia Wikipedia ToonTalk Reborn (JS) github.com/ToonTalk/ToonTalk ToonTalk Reborn Demo toontalk.github.io/ToonTalk ToonTalk Reborn Wiki Wiki Ken Kahn’s Page Ken Kahn Original Paper (1995) ERIC - ToonTalk: An Animated Programming Environment Ken Kahn’s Research Academia.edu Part 4 of the Throwback Thursday series. View all parts Some ideas are worth rediscovering. ToonTalk is one of them." />
<meta property="og:description" content="I first discovered ToonTalk during the Windows XP era—probably around 2003 or 2004. It was unlike anything I’d seen: a programming environment disguised as a video game where you trained robots by showing them what to do. The concept stuck with me for two decades. Resource Link Video ToonTalk in Rust tt-rs Demo Live Demo tt-rs Repo tt-rs What is ToonTalk? ToonTalk is a visual programming environment created by Ken Kahn in 1995. The “Toon” stands for cartoon—every abstract programming concept is mapped to a concrete, animated metaphor: Concept ToonTalk Metaphor Variables Boxes with numbered holes Values Numbers, text, images in boxes Comparison Scales that tip when values differ Functions Robots that watch and learn Message passing Birds that carry items to nests Garbage collection Trucks that haul away unused items The design was influenced by games like The Legend of Zelda and Robot Odyssey—the kind of games that made you think while you played. Programming by Demonstration The core idea is radical: you don’t write code, you show a robot what to do. Create a robot and put it in “training mode” Perform actions while the robot watches (move items, compare values, etc.) The robot records your actions as a program Give the robot a box matching the training pattern—it executes the learned behavior This is programming by demonstration. The robot generalizes from your example, matching patterns and applying transformations. It’s the same conceptual model as teaching a child: “Watch what I do, then you try.” Three Generations ToonTalk has existed in three forms: Version Era Technology Original ToonTalk 1995-2009 C++, 3D desktop application ToonTalk Reborn 2014-2017 JavaScript/jQuery web app tt-rs 2025-2026 Rust/WebAssembly/Yew The original was a full 3D world—cities, houses, helicopters, even bombs for debugging. Ken Kahn later created ToonTalk Reborn, a simplified JavaScript version that runs in browsers. Why I Built tt-rs When I rediscovered ToonTalk Reborn a few years ago, I wanted to experiment with the concepts myself. But diving into a large jQuery codebase wasn’t appealing. So I did what any reasonable person would do: I vibe coded my own version in Rust. tt-rs is a modern reimplementation using: Rust for core logic WebAssembly for browser execution Yew for reactive UI SVG/CSS for graphics and animations It’s not a port—it’s a fresh implementation inspired by the same ideas. Building it myself lets me understand the concepts deeply and experiment with variations. Three Learning Levels The demo introduces concepts progressively through three levels: Level Concepts Widgets tt1 Basics Numbers, boxes, scales, wand, vacuum tt2 Messaging Birds and nests for communication tt3 Automation Sensors (time, random) + robots Level one covers the fundamentals: numbers with arithmetic, boxes as containers, scales for comparison, and tools for copying and removing. Level two adds asynchronous messaging—birds carry items to their paired nests. Level three brings sensors that produce values and robots that automate actions. Current Features The live demo includes: Widgets: Numbers: Rational arithmetic with +, -, *, / operators Boxes: Configurable containers with 0-9 holes (resize with keyboard) Text: Basic text display Scales: Visual comparison that tips when values differ Robot: Training mode, action recording, execution Bird/Nest: Message passing with pairing and delivery Sensors: Time (milliseconds) and random number generation Tools: Wand: Copy any widget Vacuum: Remove widgets Magnifier: Inspect nest message queues and robot actions Interactions: Drag-and-drop with visual feedback Box joining (drop box on edge of another) Box splitting (drop box on a number) Contextual help panel with level-specific content Puzzle system with animated “Show Me” demos Robot Training The core feature is programming by demonstration: Click robot to enter training mode (yellow glow indicates “I’m watching”) Perform actions while the robot records (arithmetic, copy, remove, move to box) Click robot again to stop training Click robot to replay—it executes the recorded sequence The tutorials demonstrate this workflow step by step. In the “Train Robot” tutorial, you teach a robot to move a number into a box. In “Robot Sensors,” you train a robot to generate random numbers, apply modulo, and send results to a nest via a bird. Interactive Tutorials Each tutorial has two parts: Show Me: Watch an animated demonstration where a cursor walks through the solution Practice: Try it yourself with the same widgets The tutorials cover: Fill a box with numbers Add numbers together Copy widgets with the wand Send messages with birds and nests Train your first robot Combine robots with sensors What’s Next The immediate priorities: Pattern matching - Robot generalizes from specific values to “any number” Watched execution - See robot work step-by-step with animated cursor Persistence - Save and load workspaces Long term, I’d like to add the 3D elements from the original—the cities, the houses, the helicopter view. But that’s a much larger project. The Enduring Appeal What makes ToonTalk fascinating isn’t just the visual metaphors—it’s the computational model. Under the hood, ToonTalk implements concurrent constraint logic programming. The robots are essentially guarded Horn clauses. The birds and nests implement the actor model. Heavy concepts, but you don’t need to know any of that to use it. You just train robots by example. The abstraction is complete. That’s why it stuck with me for twenty years. Good abstractions are rare. When you find one, it’s worth understanding deeply. References Resource Link ToonTalk Website toontalk.com ToonTalk on Wikipedia Wikipedia ToonTalk Reborn (JS) github.com/ToonTalk/ToonTalk ToonTalk Reborn Demo toontalk.github.io/ToonTalk ToonTalk Reborn Wiki Wiki Ken Kahn’s Page Ken Kahn Original Paper (1995) ERIC - ToonTalk: An Animated Programming Environment Ken Kahn’s Research Academia.edu Part 4 of the Throwback Thursday series. View all parts Some ideas are worth rediscovering. ToonTalk is one of them." />
<link rel="canonical" href="http://localhost:5907/2026/02/19/tbt-toontalk-visual-programming/" />
<meta property="og:url" content="http://localhost:5907/2026/02/19/tbt-toontalk-visual-programming/" />
<meta property="og:site_name" content="Software Wrighter Lab Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2026-02-19T00:00:00-08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="TBT (4/?): ToonTalk - Teaching Robots to Program" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Software Wrighter"},"dateModified":"2026-02-19T00:00:00-08:00","datePublished":"2026-02-19T00:00:00-08:00","description":"I first discovered ToonTalk during the Windows XP era—probably around 2003 or 2004. It was unlike anything I’d seen: a programming environment disguised as a video game where you trained robots by showing them what to do. The concept stuck with me for two decades. Resource Link Video ToonTalk in Rust tt-rs Demo Live Demo tt-rs Repo tt-rs What is ToonTalk? ToonTalk is a visual programming environment created by Ken Kahn in 1995. The “Toon” stands for cartoon—every abstract programming concept is mapped to a concrete, animated metaphor: Concept ToonTalk Metaphor Variables Boxes with numbered holes Values Numbers, text, images in boxes Comparison Scales that tip when values differ Functions Robots that watch and learn Message passing Birds that carry items to nests Garbage collection Trucks that haul away unused items The design was influenced by games like The Legend of Zelda and Robot Odyssey—the kind of games that made you think while you played. Programming by Demonstration The core idea is radical: you don’t write code, you show a robot what to do. Create a robot and put it in “training mode” Perform actions while the robot watches (move items, compare values, etc.) The robot records your actions as a program Give the robot a box matching the training pattern—it executes the learned behavior This is programming by demonstration. The robot generalizes from your example, matching patterns and applying transformations. It’s the same conceptual model as teaching a child: “Watch what I do, then you try.” Three Generations ToonTalk has existed in three forms: Version Era Technology Original ToonTalk 1995-2009 C++, 3D desktop application ToonTalk Reborn 2014-2017 JavaScript/jQuery web app tt-rs 2025-2026 Rust/WebAssembly/Yew The original was a full 3D world—cities, houses, helicopters, even bombs for debugging. Ken Kahn later created ToonTalk Reborn, a simplified JavaScript version that runs in browsers. Why I Built tt-rs When I rediscovered ToonTalk Reborn a few years ago, I wanted to experiment with the concepts myself. But diving into a large jQuery codebase wasn’t appealing. So I did what any reasonable person would do: I vibe coded my own version in Rust. tt-rs is a modern reimplementation using: Rust for core logic WebAssembly for browser execution Yew for reactive UI SVG/CSS for graphics and animations It’s not a port—it’s a fresh implementation inspired by the same ideas. Building it myself lets me understand the concepts deeply and experiment with variations. Three Learning Levels The demo introduces concepts progressively through three levels: Level Concepts Widgets tt1 Basics Numbers, boxes, scales, wand, vacuum tt2 Messaging Birds and nests for communication tt3 Automation Sensors (time, random) + robots Level one covers the fundamentals: numbers with arithmetic, boxes as containers, scales for comparison, and tools for copying and removing. Level two adds asynchronous messaging—birds carry items to their paired nests. Level three brings sensors that produce values and robots that automate actions. Current Features The live demo includes: Widgets: Numbers: Rational arithmetic with +, -, *, / operators Boxes: Configurable containers with 0-9 holes (resize with keyboard) Text: Basic text display Scales: Visual comparison that tips when values differ Robot: Training mode, action recording, execution Bird/Nest: Message passing with pairing and delivery Sensors: Time (milliseconds) and random number generation Tools: Wand: Copy any widget Vacuum: Remove widgets Magnifier: Inspect nest message queues and robot actions Interactions: Drag-and-drop with visual feedback Box joining (drop box on edge of another) Box splitting (drop box on a number) Contextual help panel with level-specific content Puzzle system with animated “Show Me” demos Robot Training The core feature is programming by demonstration: Click robot to enter training mode (yellow glow indicates “I’m watching”) Perform actions while the robot records (arithmetic, copy, remove, move to box) Click robot again to stop training Click robot to replay—it executes the recorded sequence The tutorials demonstrate this workflow step by step. In the “Train Robot” tutorial, you teach a robot to move a number into a box. In “Robot Sensors,” you train a robot to generate random numbers, apply modulo, and send results to a nest via a bird. Interactive Tutorials Each tutorial has two parts: Show Me: Watch an animated demonstration where a cursor walks through the solution Practice: Try it yourself with the same widgets The tutorials cover: Fill a box with numbers Add numbers together Copy widgets with the wand Send messages with birds and nests Train your first robot Combine robots with sensors What’s Next The immediate priorities: Pattern matching - Robot generalizes from specific values to “any number” Watched execution - See robot work step-by-step with animated cursor Persistence - Save and load workspaces Long term, I’d like to add the 3D elements from the original—the cities, the houses, the helicopter view. But that’s a much larger project. The Enduring Appeal What makes ToonTalk fascinating isn’t just the visual metaphors—it’s the computational model. Under the hood, ToonTalk implements concurrent constraint logic programming. The robots are essentially guarded Horn clauses. The birds and nests implement the actor model. Heavy concepts, but you don’t need to know any of that to use it. You just train robots by example. The abstraction is complete. That’s why it stuck with me for twenty years. Good abstractions are rare. When you find one, it’s worth understanding deeply. References Resource Link ToonTalk Website toontalk.com ToonTalk on Wikipedia Wikipedia ToonTalk Reborn (JS) github.com/ToonTalk/ToonTalk ToonTalk Reborn Demo toontalk.github.io/ToonTalk ToonTalk Reborn Wiki Wiki Ken Kahn’s Page Ken Kahn Original Paper (1995) ERIC - ToonTalk: An Animated Programming Environment Ken Kahn’s Research Academia.edu Part 4 of the Throwback Thursday series. View all parts Some ideas are worth rediscovering. ToonTalk is one of them.","headline":"TBT (4/?): ToonTalk - Teaching Robots to Program","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:5907/2026/02/19/tbt-toontalk-visual-programming/"},"url":"http://localhost:5907/2026/02/19/tbt-toontalk-visual-programming/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:5907/feed.xml" title="Software Wrighter Lab Blog" /><!-- Theme toggle script - load early to prevent flash -->
  <script>
    (function() {
      var stored = localStorage.getItem('sw-lab-theme');
      var theme = stored;
      if (!theme) {
        theme = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
      }
      document.documentElement.setAttribute('data-theme', theme);
    })();
  </script>
  <!-- Font size - load early to prevent flash -->
  <script>
    (function() {
      var NEW_DEFAULT = 110;
      var OLD_DEFAULT = 150;
      var stored = localStorage.getItem('sw-lab-font-size');
      var ack = localStorage.getItem('sw-lab-prefs-ack');
      var size = stored ? parseInt(stored, 10) : null;

      // Migration: if on old default and not acknowledged, use new default
      if (size === OLD_DEFAULT && ack !== 'true') {
        size = NEW_DEFAULT;
      } else if (size === null) {
        size = NEW_DEFAULT;
      }

      // Apply to post content when DOM is ready
      document.addEventListener('DOMContentLoaded', function() {
        var pc = document.querySelector('.post-content');
        if (pc) pc.style.fontSize = size + '%';
        var pl = document.querySelector('.post-list');
        if (pl) pl.style.fontSize = size + '%';
      });
    })();
  </script>
  <script src="/assets/js/theme-toggle.js" defer></script>
  <script src="/assets/js/font-size.js" defer></script>
  <script src="/assets/js/preferences.js" defer></script>
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">
      <img src="/assets/images/site/logo.jpg" alt="Software Wrighter Lab Blog" class="site-logo">
      <span class="site-title-text">Software Wrighter Lab Blog</span>
    </a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/abstracts/">Abstracts</a><a class="page-link" href="/index-all/">Index</a><a class="page-link" href="/series/">Series</a><a class="page-link" href="/tags/">Tags</a><a class="page-link" href="/categories/">Categories</a><a class="page-link" href="/search/">Search</a><div class="font-size-controls">
  <button class="font-size-btn" id="font-decrease" title="Decrease font size" aria-label="Decrease font size">A-</button>
  <button class="font-size-btn" id="font-reset" title="Reset font size" aria-label="Reset font size">A</button>
  <button class="font-size-btn" id="font-increase" title="Increase font size" aria-label="Increase font size">A+</button>
</div>
<button class="theme-toggle" aria-label="Switch theme" title="Switch theme">
  <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
  </svg>
  <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
  </svg>
</button>
</div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">TBT (4/?): ToonTalk - Teaching Robots to Program</h1><p class="post-meta">February 19, 2026 &bull; Software Wrighter</p>
<p class="post-reading-info"><em><span class="post-word-count">1080 words</span> &bull; <span class="post-read-time">6 min read</span></em> &bull; <span class="abstract-toggle" onclick="this.classList.toggle('open'); this.parentElement.nextElementSibling.classList.toggle('open')">Abstract</span></p><div class="post-meta-abstract">ToonTalk is a 1995 visual programming environment where you train robots by showing them what to do. I vibe coded tt-rs, a Rust/WebAssembly reimplementation with boxes, scales, birds, nests, and robots---programming by demonstration for the browser.</div><div class="post-taxonomies"><span class="post-categories"><a href="/categories/#tbt" class="category">tbt</a><a href="/categories/#visual-programming" class="category">visual-programming</a><a href="/categories/#vibe-coding" class="category">vibe-coding</a></span><span class="post-tags"><a href="/tags/#tbt" class="tag">tbt</a><a href="/tags/#toontalk" class="tag">toontalk</a><a href="/tags/#visual-programming" class="tag">visual-programming</a><a href="/tags/#rust" class="tag">rust</a><a href="/tags/#webassembly" class="tag">webassembly</a><a href="/tags/#education" class="tag">education</a><a href="/tags/#vibe-coding" class="tag">vibe-coding</a></span></div></header><nav class="toc" data-toc-id="default">
  <h4>Contents</h4>
  <ul class="toc-list"></ul>
</nav>

<style>
/* Post content flows around floated TOC */
.post-content {
  overflow: hidden;
}

.toc {
  background: #fffde7;
  border-radius: 8px;
  padding: 1rem 1.5rem;
  margin: 0 1.5rem 1rem 0;
  float: left;
  max-width: 280px;
}

[data-theme="dark"] .toc {
  background: #3d3a00;
}

@media (prefers-color-scheme: dark) {
  :root:not([data-theme="light"]) .toc {
    background: #3d3a00;
  }
}

.toc h4 {
  margin: 0 0 0.75rem 0;
  font-size: 1rem;
}

.toc ul {
  margin: 0;
  padding-left: 1.25rem;
  list-style-type: disc;
}

.toc li {
  margin: 0.25rem 0;
}

.toc li.toc-h3 {
  margin-left: 1rem;
  font-size: 0.95em;
}

.toc a {
  text-decoration: none;
}

.toc a:hover {
  text-decoration: underline;
}


@media (max-width: 600px) {
  .toc {
    float: none;
    max-width: 100%;
    margin: 0 0 1.5rem 0;
  }
}

/* References section that floats alongside TOC */
.references-float {
  overflow: hidden; /* contain floated content */
}

.references-float h2 {
  margin-top: 0;
  font-size: 1.25rem;
}

.references-float table {
  font-size: 0.9em;
  width: 100%;
}

.references-float td, .references-float th {
  padding: 0.4rem 0.6rem;
  vertical-align: top;
}

.references-float td:first-child {
  white-space: nowrap;
  font-weight: bold;
  width: 1%;
}

@media (max-width: 600px) {
  .references-float table {
    font-size: 0.85em;
  }
}
</style>

<script>
(function() {
  // Run after DOM is ready
  function initTOC() {
    document.querySelectorAll('.toc').forEach(function(toc) {
      if (toc.dataset.initialized) return;
      toc.dataset.initialized = 'true';

      const tocList = toc.querySelector('.toc-list');
      if (!tocList) return;

      // Find the associated post-content (next sibling or parent's post-content)
      let article = toc.nextElementSibling;
      while (article && !article.classList.contains('post-content')) {
        article = article.nextElementSibling;
      }
      // Fallback: look for .post-content in the document (single post page)
      if (!article) {
        article = document.querySelector('.post-content');
      }

      if (!article) {
        toc.style.display = 'none';
        return;
      }

      const headings = article.querySelectorAll('h2, h3');

      if (headings.length < 3) {
        toc.style.display = 'none';
        return;
      }

      const tocId = toc.dataset.tocId || Math.random().toString(36).substr(2, 9);

      headings.forEach(function(heading, index) {
        // Add unique ID if missing
        if (!heading.id) {
          heading.id = 'toc-' + tocId + '-heading-' + index;
        }

        const li = document.createElement('li');
        li.className = 'toc-' + heading.tagName.toLowerCase();

        const a = document.createElement('a');
        a.href = '#' + heading.id;
        a.textContent = heading.textContent;

        li.appendChild(a);
        tocList.appendChild(li);
      });
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initTOC);
  } else {
    initTOC();
  }
})();
</script>
<div class="post-content e-content" itemprop="articleBody">
    <p><img src="/assets/images/posts/block-robot.png" class="post-marker" alt="" /></p>

<p>I first discovered ToonTalk during the Windows XP era—probably around 2003 or 2004. It was unlike anything I’d seen: a programming environment disguised as a video game where you trained robots by showing them what to do. The concept stuck with me for two decades.</p>

<div class="resource-box">

  <table>
    <thead>
      <tr>
        <th>Resource</th>
        <th>Link</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Video</strong></td>
        <td><a href="https://youtu.be/qrcWMOfHN2s">ToonTalk in Rust</a><br /><a href="https://youtu.be/qrcWMOfHN2s"><img src="https://img.youtube.com/vi/qrcWMOfHN2s/mqdefault.jpg" alt="Video" class="video-thumb" /></a></td>
      </tr>
      <tr>
        <td><strong>tt-rs Demo</strong></td>
        <td><a href="https://sw-fun.github.io/tt-rs/">Live Demo</a></td>
      </tr>
      <tr>
        <td><strong>tt-rs Repo</strong></td>
        <td><a href="https://github.com/sw-fun/tt-rs">tt-rs</a></td>
      </tr>
    </tbody>
  </table>

</div>

<h2 id="what-is-toontalk">What is ToonTalk?</h2>

<p>ToonTalk is a visual programming environment created by <a href="https://toontalk.com/English/kenkahn.htm">Ken Kahn</a> in 1995. The “Toon” stands for cartoon—every abstract programming concept is mapped to a concrete, animated metaphor:</p>

<table>
  <thead>
    <tr>
      <th>Concept</th>
      <th>ToonTalk Metaphor</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Variables</td>
      <td>Boxes with numbered holes</td>
    </tr>
    <tr>
      <td>Values</td>
      <td>Numbers, text, images in boxes</td>
    </tr>
    <tr>
      <td>Comparison</td>
      <td>Scales that tip when values differ</td>
    </tr>
    <tr>
      <td>Functions</td>
      <td>Robots that watch and learn</td>
    </tr>
    <tr>
      <td>Message passing</td>
      <td>Birds that carry items to nests</td>
    </tr>
    <tr>
      <td>Garbage collection</td>
      <td>Trucks that haul away unused items</td>
    </tr>
  </tbody>
</table>

<p>The design was influenced by games like <em>The Legend of Zelda</em> and <em>Robot Odyssey</em>—the kind of games that made you think while you played.</p>

<h2 id="programming-by-demonstration">Programming by Demonstration</h2>

<p>The core idea is radical: you don’t write code, you <em>show</em> a robot what to do.</p>

<ol>
  <li>Create a robot and put it in “training mode”</li>
  <li>Perform actions while the robot watches (move items, compare values, etc.)</li>
  <li>The robot records your actions as a program</li>
  <li>Give the robot a box matching the training pattern—it executes the learned behavior</li>
</ol>

<p>This is programming by demonstration. The robot generalizes from your example, matching patterns and applying transformations. It’s the same conceptual model as teaching a child: “Watch what I do, then you try.”</p>

<h2 id="three-generations">Three Generations</h2>

<p>ToonTalk has existed in three forms:</p>

<table>
  <thead>
    <tr>
      <th>Version</th>
      <th>Era</th>
      <th>Technology</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Original ToonTalk</strong></td>
      <td>1995-2009</td>
      <td>C++, 3D desktop application</td>
    </tr>
    <tr>
      <td><strong>ToonTalk Reborn</strong></td>
      <td>2014-2017</td>
      <td>JavaScript/jQuery web app</td>
    </tr>
    <tr>
      <td><strong>tt-rs</strong></td>
      <td>2025-2026</td>
      <td>Rust/WebAssembly/Yew</td>
    </tr>
  </tbody>
</table>

<p>The original was a full 3D world—cities, houses, helicopters, even bombs for debugging. Ken Kahn later created <a href="https://github.com/ToonTalk/ToonTalk">ToonTalk Reborn</a>, a simplified JavaScript version that runs in browsers.</p>

<h2 id="why-i-built-tt-rs">Why I Built tt-rs</h2>

<p>When I rediscovered ToonTalk Reborn a few years ago, I wanted to experiment with the concepts myself. But diving into a large jQuery codebase wasn’t appealing. So I did what any reasonable person would do: I vibe coded my own version in Rust.</p>

<p><strong>tt-rs</strong> is a modern reimplementation using:</p>

<ul>
  <li><strong>Rust</strong> for core logic</li>
  <li><strong>WebAssembly</strong> for browser execution</li>
  <li><strong>Yew</strong> for reactive UI</li>
  <li><strong>SVG/CSS</strong> for graphics and animations</li>
</ul>

<p>It’s not a port—it’s a fresh implementation inspired by the same ideas. Building it myself lets me understand the concepts deeply and experiment with variations.</p>

<h2 id="three-learning-levels">Three Learning Levels</h2>

<p>The demo introduces concepts progressively through three levels:</p>

<table>
  <thead>
    <tr>
      <th>Level</th>
      <th>Concepts</th>
      <th>Widgets</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>tt1</strong></td>
      <td>Basics</td>
      <td>Numbers, boxes, scales, wand, vacuum</td>
    </tr>
    <tr>
      <td><strong>tt2</strong></td>
      <td>Messaging</td>
      <td>Birds and nests for communication</td>
    </tr>
    <tr>
      <td><strong>tt3</strong></td>
      <td>Automation</td>
      <td>Sensors (time, random) + robots</td>
    </tr>
  </tbody>
</table>

<p>Level one covers the fundamentals: numbers with arithmetic, boxes as containers, scales for comparison, and tools for copying and removing. Level two adds asynchronous messaging—birds carry items to their paired nests. Level three brings sensors that produce values and robots that automate actions.</p>

<h2 id="current-features">Current Features</h2>

<p>The <a href="https://sw-fun.github.io/tt-rs/">live demo</a> includes:</p>

<p><strong>Widgets:</strong></p>
<ul>
  <li><strong>Numbers</strong>: Rational arithmetic with +, -, *, / operators</li>
  <li><strong>Boxes</strong>: Configurable containers with 0-9 holes (resize with keyboard)</li>
  <li><strong>Text</strong>: Basic text display</li>
  <li><strong>Scales</strong>: Visual comparison that tips when values differ</li>
  <li><strong>Robot</strong>: Training mode, action recording, execution</li>
  <li><strong>Bird/Nest</strong>: Message passing with pairing and delivery</li>
  <li><strong>Sensors</strong>: Time (milliseconds) and random number generation</li>
</ul>

<p><strong>Tools:</strong></p>
<ul>
  <li><strong>Wand</strong>: Copy any widget</li>
  <li><strong>Vacuum</strong>: Remove widgets</li>
  <li><strong>Magnifier</strong>: Inspect nest message queues and robot actions</li>
</ul>

<p><strong>Interactions:</strong></p>
<ul>
  <li>Drag-and-drop with visual feedback</li>
  <li>Box joining (drop box on edge of another)</li>
  <li>Box splitting (drop box on a number)</li>
  <li>Contextual help panel with level-specific content</li>
  <li>Puzzle system with animated “Show Me” demos</li>
</ul>

<h2 id="robot-training">Robot Training</h2>

<p>The core feature is programming by demonstration:</p>

<ol>
  <li><strong>Click robot</strong> to enter training mode (yellow glow indicates “I’m watching”)</li>
  <li><strong>Perform actions</strong> while the robot records (arithmetic, copy, remove, move to box)</li>
  <li><strong>Click robot</strong> again to stop training</li>
  <li><strong>Click robot</strong> to replay—it executes the recorded sequence</li>
</ol>

<p>The tutorials demonstrate this workflow step by step. In the “Train Robot” tutorial, you teach a robot to move a number into a box. In “Robot Sensors,” you train a robot to generate random numbers, apply modulo, and send results to a nest via a bird.</p>

<h2 id="interactive-tutorials">Interactive Tutorials</h2>

<p>Each tutorial has two parts:</p>

<ol>
  <li><strong>Show Me</strong>: Watch an animated demonstration where a cursor walks through the solution</li>
  <li><strong>Practice</strong>: Try it yourself with the same widgets</li>
</ol>

<p>The tutorials cover:</p>
<ul>
  <li>Fill a box with numbers</li>
  <li>Add numbers together</li>
  <li>Copy widgets with the wand</li>
  <li>Send messages with birds and nests</li>
  <li>Train your first robot</li>
  <li>Combine robots with sensors</li>
</ul>

<h2 id="whats-next">What’s Next</h2>

<p>The immediate priorities:</p>

<ol>
  <li><strong>Pattern matching</strong> - Robot generalizes from specific values to “any number”</li>
  <li><strong>Watched execution</strong> - See robot work step-by-step with animated cursor</li>
  <li><strong>Persistence</strong> - Save and load workspaces</li>
</ol>

<p>Long term, I’d like to add the 3D elements from the original—the cities, the houses, the helicopter view. But that’s a much larger project.</p>

<h2 id="the-enduring-appeal">The Enduring Appeal</h2>

<p>What makes ToonTalk fascinating isn’t just the visual metaphors—it’s the <em>computational model</em>. Under the hood, ToonTalk implements concurrent constraint logic programming. The robots are essentially guarded Horn clauses. The birds and nests implement the actor model.</p>

<p>Heavy concepts, but you don’t need to know any of that to use it. You just train robots by example. The abstraction is complete.</p>

<p>That’s why it stuck with me for twenty years. Good abstractions are rare. When you find one, it’s worth understanding deeply.</p>

<div class="references-section">

  <h2 id="references">References</h2>

  <table>
    <thead>
      <tr>
        <th>Resource</th>
        <th>Link</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>ToonTalk Website</strong></td>
        <td><a href="https://www.toontalk.com/">toontalk.com</a></td>
      </tr>
      <tr>
        <td><strong>ToonTalk on Wikipedia</strong></td>
        <td><a href="https://en.wikipedia.org/wiki/ToonTalk">Wikipedia</a></td>
      </tr>
      <tr>
        <td><strong>ToonTalk Reborn (JS)</strong></td>
        <td><a href="https://github.com/ToonTalk/ToonTalk">github.com/ToonTalk/ToonTalk</a></td>
      </tr>
      <tr>
        <td><strong>ToonTalk Reborn Demo</strong></td>
        <td><a href="https://toontalk.github.io/ToonTalk/">toontalk.github.io/ToonTalk</a></td>
      </tr>
      <tr>
        <td><strong>ToonTalk Reborn Wiki</strong></td>
        <td><a href="https://github.com/ToonTalk/ToonTalk/wiki">Wiki</a></td>
      </tr>
      <tr>
        <td><strong>Ken Kahn’s Page</strong></td>
        <td><a href="https://toontalk.com/English/kenkahn.htm">Ken Kahn</a></td>
      </tr>
      <tr>
        <td><strong>Original Paper (1995)</strong></td>
        <td><a href="https://eric.ed.gov/?id=ED392435">ERIC - ToonTalk: An Animated Programming Environment</a></td>
      </tr>
      <tr>
        <td><strong>Ken Kahn’s Research</strong></td>
        <td><a href="https://www.academia.edu/2795458/ToonTalk_and_Logo">Academia.edu</a></td>
      </tr>
    </tbody>
  </table>

</div>

<hr />

<p><em>Part 4 of the Throwback Thursday series. <a href="/series/#throwback-thursday">View all parts</a></em></p>

<p><em>Some ideas are worth rediscovering. ToonTalk is one of them.</em></p>


  </div><div class="series-nav">
    <p><em>Part 4 of the Throwback Thursday series. <a href="/series/#throwback-thursday">View all parts</a></em></p>
  </div>





<div class="youtube-embed-container" id="yt-container-qrcWMOfHN2s">
  <h3>Watch the Video</h3>
  <div class="youtube-embed-wrapper">
    <iframe
      id="yt-player-qrcWMOfHN2s"
      src="https://www.youtube.com/embed/qrcWMOfHN2s?enablejsapi=1&mute=1&autoplay=1&cc_load_policy=1"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      allowfullscreen
      loading="lazy">
    </iframe>
  </div>
  <p class="youtube-embed-note">Unmute to hear narration.</p>
</div>

<style>
.youtube-embed-container {
  margin: 2rem auto;
  padding: 1.5rem;
  background: var(--code-background-color, #f5f5f5);
  border-radius: 8px;
  width: 66%;
}

.youtube-embed-container h3 {
  margin-top: 0;
  margin-bottom: 1rem;
}

.youtube-embed-wrapper {
  position: relative;
  width: 100%;
  padding-bottom: 56.25%; /* 16:9 aspect ratio */
  height: 0;
  overflow: hidden;
}

.youtube-embed-wrapper iframe {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border-radius: 4px;
}

.youtube-embed-note {
  margin-top: 0.75rem;
  margin-bottom: 0;
  font-size: 0.85rem;
  color: var(--text-muted-color, #666);
  font-style: italic;
}
</style>

<script>
(function() {
  const containerId = 'yt-container-qrcWMOfHN2s';
  const playerId = 'yt-player-qrcWMOfHN2s';

  // Load YouTube IFrame API if not already loaded
  if (!window.YT) {
    const tag = document.createElement('script');
    tag.src = 'https://www.youtube.com/iframe_api';
    const firstScriptTag = document.getElementsByTagName('script')[0];
    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
  }

  let player;
  let isPlaying = false;

  function onYouTubeIframeAPIReady() {
    player = new YT.Player(playerId, {
      events: {
        'onReady': onPlayerReady
      }
    });
  }

  function onPlayerReady(event) {
    setupIntersectionObserver();
  }

  function setupIntersectionObserver() {
    const container = document.getElementById(containerId);
    if (!container) return;

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && entry.intersectionRatio >= 0.5) {
          if (!isPlaying && player && player.playVideo) {
            player.playVideo();
            isPlaying = true;
          }
        } else {
          if (isPlaying && player && player.pauseVideo) {
            player.pauseVideo();
            isPlaying = false;
          }
        }
      });
    }, {
      threshold: [0.5]
    });

    observer.observe(container);
  }

  // Handle API ready callback
  if (window.YT && window.YT.Player) {
    onYouTubeIframeAPIReady();
  } else {
    window.onYouTubeIframeAPIReady = window.onYouTubeIframeAPIReady || onYouTubeIframeAPIReady;
    // Queue multiple players if needed
    const existingCallback = window.onYouTubeIframeAPIReady;
    window.onYouTubeIframeAPIReady = function() {
      if (existingCallback) existingCallback();
      onYouTubeIframeAPIReady();
    };
  }
})();
</script>

<img src="/assets/images/site/post-separator.png" class="post-separator" alt=""><a class="u-url" href="/2026/02/19/tbt-toontalk-visual-programming/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Software Wrighter Lab Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Mike Wright</li><li><a class="u-email" href="mailto:"></a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/softwarewrighter"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">softwarewrighter</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>AI coding agents, systems programming, and practical machine learning</p>
      </div>
    </div>

    <div class="footer-copyright">
      <p>Copyright &copy; 2026 Michael A. Wright</p>
    </div>

  </div>

  <button id="scroll-to-top" aria-label="Scroll to top" title="Scroll to top">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="18 15 12 9 6 15"></polyline>
    </svg>
  </button>

  <style>
  #scroll-to-top {
    position: fixed;
    bottom: 2rem;
    right: 2rem;
    width: 44px;
    height: 44px;
    border-radius: 50%;
    border: none;
    background: var(--brand-color, #2a7ae2);
    color: white;
    cursor: pointer;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s, visibility 0.3s, transform 0.2s;
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
  }

  #scroll-to-top:hover {
    transform: scale(1.1);
  }

  #scroll-to-top.visible {
    opacity: 1;
    visibility: visible;
  }

  #scroll-to-top svg {
    width: 24px;
    height: 24px;
  }
  </style>

  <script>
  (function() {
    const btn = document.getElementById('scroll-to-top');
    if (!btn) return;

    window.addEventListener('scroll', function() {
      if (window.scrollY > 300) {
        btn.classList.add('visible');
      } else {
        btn.classList.remove('visible');
      }
    });

    btn.addEventListener('click', function() {
      window.scrollTo({ top: 0, behavior: 'smooth' });
    });
  })();
  </script>

</footer>
</body>

</html>
