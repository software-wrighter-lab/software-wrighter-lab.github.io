<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>DyTopo: Dynamic Topology for Multi-Agent AI | Software Wrighter Lab Blog</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="DyTopo: Dynamic Topology for Multi-Agent AI" />
<meta name="author" content="Software Wrighter" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="When multiple AI agents work together, how should they communicate? Fixed patterns fail at scale. DyTopo rebuilds the communication graph each round based on what agents need and what they can offer. Resource Link Video DyTopo Paper arXiv:2505.16128 Code dytopo-rs The Problem: Fixed Topologies Don’t Scale Multi-agent systems need communication patterns. The obvious approaches have problems: Topology Problem All-to-all Context explosion—every agent reads every message Chain Bottlenecks—one slow agent blocks everyone Star Single point of failure at the hub As agent count grows, fixed topologies either explode in messages or create chokepoints. The DyTopo Solution: Dynamic Routing DyTopo (Dynamic Topology) solves this by reconstructing the communication graph each round. The key insight: agents know what they need and what they can offer. Each round, every agent emits: Query: What information do I need? Key: What can I contribute? The router computes semantic similarity between all keys and queries, then builds a sparse directed graph: score(sender → receiver) = cosine(sender.key, receiver.query) High-scoring pairs connect. Low-scoring pairs are ignored. The result: efficient, adaptive communication. How It Works Round N: 1. Manager broadcasts goal 2. Each agent produces: - Query (what I need) - Key (what I offer) - Draft (my current contribution) 3. Router embeds keys and queries 4. Similarity matrix → sparse graph (top-K per receiver) 5. Messages flow along edges 6. Trace written to JSONL The topology adapts every round. An agent working on parsing might connect to the syntax expert in round 1, then the error-handling expert in round 2. The Implementation: Rust, Zero Python dytopo-rs is a fully Rust implementation with no Python dependencies: Crate Purpose dytopo-core Shared types (AgentId, Topology, TraceEvent) dytopo-embed Text embedding (hash-based baseline, semantic planned) dytopo-router Sparse graph construction dytopo-agents Agent implementations dytopo-orchestrator Main execution loop dytopo-viz DOT export for visualization dytopo-cli Command-line interface Why Rust? Zero-cost abstractions for performance-critical embedding/routing Strong type system catches protocol mismatches at compile time No Python dependency for baseline demos Fearless concurrency for future parallelization Running the Demo cargo run -p dytopo-cli -- demo --rounds 3 --agents 5 --topk 2 This produces: Per-round topology printed to stdout ./traces/trace_*.jsonl for machine-readable analysis DOT files for graph visualization Current Status Milestone 0 is complete—the system runs end-to-end with stub agents and hash-based embeddings. Feature Status Core types and traits Done Hash embedder (deterministic) Done Top-K sparse routing Done Stub agents with templates Done Orchestrator loop Done JSONL tracing Done DOT visualization Done Planned Semantic embeddings (fastembed/candle) LLM-backed agents (Ollama integration) Inbox summarization for long conversations Evaluation harness comparing topologies Key Design Decisions Why Hash Embeddings First? The baseline uses deterministic hash-based embeddings: Reproducible demos for debugging No external dependencies to download Validates the full pipeline before adding ML complexity Semantic embeddings are planned as drop-in replacements. Why Sparse Graphs? Each agent receives at most topk messages per round: Prevents context explosion as agent count grows Makes communication interpretable—you can trace why agents connected Matches the paper’s approach Why JSONL Traces? Every event is logged to JSONL: Append-only for streaming Line-based for grep/filtering Machine-parseable for analysis tools Human-readable for debugging Topology Comparison The system supports multiple topology strategies for comparison: Strategy Description Use Case dynamic DyTopo routing Adaptive, sparse fully_connected All-to-all Baseline comparison chain Sequential Pipeline tasks star Hub-and-spoke Centralized coordination What’s Next LLM Agent Support (Milestone 2)—Replace stubs with real reasoning Semantic Embeddings (Milestone 1)—Meaningful routing decisions Evaluation Harness (Milestone 4)—Quantify DyTopo advantages Resources DyTopo Paper (arXiv:2505.16128) - Li et al., 2025 dytopo-rs Repository Dynamic topology lets agents find the right collaborators each round. No context explosion. No bottlenecks. Just efficient, adaptive communication." />
<meta property="og:description" content="When multiple AI agents work together, how should they communicate? Fixed patterns fail at scale. DyTopo rebuilds the communication graph each round based on what agents need and what they can offer. Resource Link Video DyTopo Paper arXiv:2505.16128 Code dytopo-rs The Problem: Fixed Topologies Don’t Scale Multi-agent systems need communication patterns. The obvious approaches have problems: Topology Problem All-to-all Context explosion—every agent reads every message Chain Bottlenecks—one slow agent blocks everyone Star Single point of failure at the hub As agent count grows, fixed topologies either explode in messages or create chokepoints. The DyTopo Solution: Dynamic Routing DyTopo (Dynamic Topology) solves this by reconstructing the communication graph each round. The key insight: agents know what they need and what they can offer. Each round, every agent emits: Query: What information do I need? Key: What can I contribute? The router computes semantic similarity between all keys and queries, then builds a sparse directed graph: score(sender → receiver) = cosine(sender.key, receiver.query) High-scoring pairs connect. Low-scoring pairs are ignored. The result: efficient, adaptive communication. How It Works Round N: 1. Manager broadcasts goal 2. Each agent produces: - Query (what I need) - Key (what I offer) - Draft (my current contribution) 3. Router embeds keys and queries 4. Similarity matrix → sparse graph (top-K per receiver) 5. Messages flow along edges 6. Trace written to JSONL The topology adapts every round. An agent working on parsing might connect to the syntax expert in round 1, then the error-handling expert in round 2. The Implementation: Rust, Zero Python dytopo-rs is a fully Rust implementation with no Python dependencies: Crate Purpose dytopo-core Shared types (AgentId, Topology, TraceEvent) dytopo-embed Text embedding (hash-based baseline, semantic planned) dytopo-router Sparse graph construction dytopo-agents Agent implementations dytopo-orchestrator Main execution loop dytopo-viz DOT export for visualization dytopo-cli Command-line interface Why Rust? Zero-cost abstractions for performance-critical embedding/routing Strong type system catches protocol mismatches at compile time No Python dependency for baseline demos Fearless concurrency for future parallelization Running the Demo cargo run -p dytopo-cli -- demo --rounds 3 --agents 5 --topk 2 This produces: Per-round topology printed to stdout ./traces/trace_*.jsonl for machine-readable analysis DOT files for graph visualization Current Status Milestone 0 is complete—the system runs end-to-end with stub agents and hash-based embeddings. Feature Status Core types and traits Done Hash embedder (deterministic) Done Top-K sparse routing Done Stub agents with templates Done Orchestrator loop Done JSONL tracing Done DOT visualization Done Planned Semantic embeddings (fastembed/candle) LLM-backed agents (Ollama integration) Inbox summarization for long conversations Evaluation harness comparing topologies Key Design Decisions Why Hash Embeddings First? The baseline uses deterministic hash-based embeddings: Reproducible demos for debugging No external dependencies to download Validates the full pipeline before adding ML complexity Semantic embeddings are planned as drop-in replacements. Why Sparse Graphs? Each agent receives at most topk messages per round: Prevents context explosion as agent count grows Makes communication interpretable—you can trace why agents connected Matches the paper’s approach Why JSONL Traces? Every event is logged to JSONL: Append-only for streaming Line-based for grep/filtering Machine-parseable for analysis tools Human-readable for debugging Topology Comparison The system supports multiple topology strategies for comparison: Strategy Description Use Case dynamic DyTopo routing Adaptive, sparse fully_connected All-to-all Baseline comparison chain Sequential Pipeline tasks star Hub-and-spoke Centralized coordination What’s Next LLM Agent Support (Milestone 2)—Replace stubs with real reasoning Semantic Embeddings (Milestone 1)—Meaningful routing decisions Evaluation Harness (Milestone 4)—Quantify DyTopo advantages Resources DyTopo Paper (arXiv:2505.16128) - Li et al., 2025 dytopo-rs Repository Dynamic topology lets agents find the right collaborators each round. No context explosion. No bottlenecks. Just efficient, adaptive communication." />
<link rel="canonical" href="https://software-wrighter-lab.github.io/2026/02/12/dytopo-rs-dynamic-topology-multi-agent/" />
<meta property="og:url" content="https://software-wrighter-lab.github.io/2026/02/12/dytopo-rs-dynamic-topology-multi-agent/" />
<meta property="og:site_name" content="Software Wrighter Lab Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2026-02-12T06:00:00-08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="DyTopo: Dynamic Topology for Multi-Agent AI" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Software Wrighter"},"dateModified":"2026-02-12T06:00:00-08:00","datePublished":"2026-02-12T06:00:00-08:00","description":"When multiple AI agents work together, how should they communicate? Fixed patterns fail at scale. DyTopo rebuilds the communication graph each round based on what agents need and what they can offer. Resource Link Video DyTopo Paper arXiv:2505.16128 Code dytopo-rs The Problem: Fixed Topologies Don’t Scale Multi-agent systems need communication patterns. The obvious approaches have problems: Topology Problem All-to-all Context explosion—every agent reads every message Chain Bottlenecks—one slow agent blocks everyone Star Single point of failure at the hub As agent count grows, fixed topologies either explode in messages or create chokepoints. The DyTopo Solution: Dynamic Routing DyTopo (Dynamic Topology) solves this by reconstructing the communication graph each round. The key insight: agents know what they need and what they can offer. Each round, every agent emits: Query: What information do I need? Key: What can I contribute? The router computes semantic similarity between all keys and queries, then builds a sparse directed graph: score(sender → receiver) = cosine(sender.key, receiver.query) High-scoring pairs connect. Low-scoring pairs are ignored. The result: efficient, adaptive communication. How It Works Round N: 1. Manager broadcasts goal 2. Each agent produces: - Query (what I need) - Key (what I offer) - Draft (my current contribution) 3. Router embeds keys and queries 4. Similarity matrix → sparse graph (top-K per receiver) 5. Messages flow along edges 6. Trace written to JSONL The topology adapts every round. An agent working on parsing might connect to the syntax expert in round 1, then the error-handling expert in round 2. The Implementation: Rust, Zero Python dytopo-rs is a fully Rust implementation with no Python dependencies: Crate Purpose dytopo-core Shared types (AgentId, Topology, TraceEvent) dytopo-embed Text embedding (hash-based baseline, semantic planned) dytopo-router Sparse graph construction dytopo-agents Agent implementations dytopo-orchestrator Main execution loop dytopo-viz DOT export for visualization dytopo-cli Command-line interface Why Rust? Zero-cost abstractions for performance-critical embedding/routing Strong type system catches protocol mismatches at compile time No Python dependency for baseline demos Fearless concurrency for future parallelization Running the Demo cargo run -p dytopo-cli -- demo --rounds 3 --agents 5 --topk 2 This produces: Per-round topology printed to stdout ./traces/trace_*.jsonl for machine-readable analysis DOT files for graph visualization Current Status Milestone 0 is complete—the system runs end-to-end with stub agents and hash-based embeddings. Feature Status Core types and traits Done Hash embedder (deterministic) Done Top-K sparse routing Done Stub agents with templates Done Orchestrator loop Done JSONL tracing Done DOT visualization Done Planned Semantic embeddings (fastembed/candle) LLM-backed agents (Ollama integration) Inbox summarization for long conversations Evaluation harness comparing topologies Key Design Decisions Why Hash Embeddings First? The baseline uses deterministic hash-based embeddings: Reproducible demos for debugging No external dependencies to download Validates the full pipeline before adding ML complexity Semantic embeddings are planned as drop-in replacements. Why Sparse Graphs? Each agent receives at most topk messages per round: Prevents context explosion as agent count grows Makes communication interpretable—you can trace why agents connected Matches the paper’s approach Why JSONL Traces? Every event is logged to JSONL: Append-only for streaming Line-based for grep/filtering Machine-parseable for analysis tools Human-readable for debugging Topology Comparison The system supports multiple topology strategies for comparison: Strategy Description Use Case dynamic DyTopo routing Adaptive, sparse fully_connected All-to-all Baseline comparison chain Sequential Pipeline tasks star Hub-and-spoke Centralized coordination What’s Next LLM Agent Support (Milestone 2)—Replace stubs with real reasoning Semantic Embeddings (Milestone 1)—Meaningful routing decisions Evaluation Harness (Milestone 4)—Quantify DyTopo advantages Resources DyTopo Paper (arXiv:2505.16128) - Li et al., 2025 dytopo-rs Repository Dynamic topology lets agents find the right collaborators each round. No context explosion. No bottlenecks. Just efficient, adaptive communication.","headline":"DyTopo: Dynamic Topology for Multi-Agent AI","mainEntityOfPage":{"@type":"WebPage","@id":"https://software-wrighter-lab.github.io/2026/02/12/dytopo-rs-dynamic-topology-multi-agent/"},"url":"https://software-wrighter-lab.github.io/2026/02/12/dytopo-rs-dynamic-topology-multi-agent/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://software-wrighter-lab.github.io/feed.xml" title="Software Wrighter Lab Blog" /><!-- Theme toggle script - load early to prevent flash -->
  <script>
    (function() {
      var stored = localStorage.getItem('sw-lab-theme');
      var theme = stored;
      if (!theme) {
        theme = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
      }
      document.documentElement.setAttribute('data-theme', theme);
    })();
  </script>
  <!-- Font size - load early to prevent flash -->
  <script>
    (function() {
      var NEW_DEFAULT = 110;
      var OLD_DEFAULT = 150;
      var stored = localStorage.getItem('sw-lab-font-size');
      var ack = localStorage.getItem('sw-lab-prefs-ack');
      var size = stored ? parseInt(stored, 10) : null;

      // Migration: if on old default and not acknowledged, use new default
      if (size === OLD_DEFAULT && ack !== 'true') {
        size = NEW_DEFAULT;
      } else if (size === null) {
        size = NEW_DEFAULT;
      }

      // Apply to post content when DOM is ready
      document.addEventListener('DOMContentLoaded', function() {
        var pc = document.querySelector('.post-content');
        if (pc) pc.style.fontSize = size + '%';
        var pl = document.querySelector('.post-list');
        if (pl) pl.style.fontSize = size + '%';
      });
    })();
  </script>
  <script src="/assets/js/theme-toggle.js" defer></script>
  <script src="/assets/js/font-size.js" defer></script>
  <script src="/assets/js/preferences.js" defer></script>
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">
      <img src="/assets/images/site/logo.jpg" alt="Software Wrighter Lab Blog" class="site-logo">
      <span class="site-title-text">Software Wrighter Lab Blog</span>
    </a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/abstracts/">Abstracts</a><a class="page-link" href="/index-all/">Index</a><a class="page-link" href="/series/">Series</a><a class="page-link" href="/tags/">Tags</a><a class="page-link" href="/categories/">Categories</a><a class="page-link" href="/search/">Search</a><div class="font-size-controls">
  <button class="font-size-btn" id="font-decrease" title="Decrease font size" aria-label="Decrease font size">A-</button>
  <button class="font-size-btn" id="font-reset" title="Reset font size" aria-label="Reset font size">A</button>
  <button class="font-size-btn" id="font-increase" title="Increase font size" aria-label="Increase font size">A+</button>
</div>
<button class="theme-toggle" aria-label="Switch theme" title="Switch theme">
  <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
  </svg>
  <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
  </svg>
</button>
</div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">DyTopo: Dynamic Topology for Multi-Agent AI</h1><p class="post-meta">February 12, 2026 &bull; Software Wrighter</p>
<p class="post-reading-info"><em><span class="post-word-count">781 words</span> &bull; <span class="post-read-time">4 min read</span></em> &bull; <span class="abstract-toggle" onclick="this.classList.toggle('open'); this.parentElement.nextElementSibling.classList.toggle('open')">Abstract</span></p><div class="post-meta-abstract">When multiple AI agents work together, fixed communication patterns fail at scale. DyTopo rebuilds the graph each round based on semantic similarity between what agents need and what they can offer, preventing context explosion while enabling adaptive collaboration.</div><div class="post-taxonomies"><span class="post-categories"><a href="/categories/#rust" class="category">rust</a><a href="/categories/#multi-agent" class="category">multi-agent</a><a href="/categories/#research" class="category">research</a></span><span class="post-tags"><a href="/tags/#rust" class="tag">rust</a><a href="/tags/#multi-agent" class="tag">multi-agent</a><a href="/tags/#topology" class="tag">topology</a><a href="/tags/#routing" class="tag">routing</a><a href="/tags/#llm" class="tag">llm</a></span></div></header><nav class="toc" data-toc-id="default">
  <h4>Contents</h4>
  <ul class="toc-list"></ul>
</nav>

<style>
/* Post content flows around floated TOC */
.post-content {
  overflow: hidden;
}

.toc {
  background: #fffde7;
  border-radius: 8px;
  padding: 1rem 1.5rem;
  margin: 0 1.5rem 1rem 0;
  float: left;
  max-width: 280px;
}

[data-theme="dark"] .toc {
  background: #3d3a00;
}

@media (prefers-color-scheme: dark) {
  :root:not([data-theme="light"]) .toc {
    background: #3d3a00;
  }
}

.toc h4 {
  margin: 0 0 0.75rem 0;
  font-size: 1rem;
}

.toc ul {
  margin: 0;
  padding-left: 1.25rem;
  list-style-type: disc;
}

.toc li {
  margin: 0.25rem 0;
}

.toc li.toc-h3 {
  margin-left: 1rem;
  font-size: 0.95em;
}

.toc a {
  text-decoration: none;
}

.toc a:hover {
  text-decoration: underline;
}


@media (max-width: 600px) {
  .toc {
    float: none;
    max-width: 100%;
    margin: 0 0 1.5rem 0;
  }
}

/* References section that floats alongside TOC */
.references-float {
  overflow: hidden; /* contain floated content */
}

.references-float h2 {
  margin-top: 0;
  font-size: 1.25rem;
}

.references-float table {
  font-size: 0.9em;
  width: 100%;
}

.references-float td, .references-float th {
  padding: 0.4rem 0.6rem;
  vertical-align: top;
}

.references-float td:first-child {
  white-space: nowrap;
  font-weight: bold;
  width: 1%;
}

@media (max-width: 600px) {
  .references-float table {
    font-size: 0.85em;
  }
}
</style>

<script>
(function() {
  // Run after DOM is ready
  function initTOC() {
    document.querySelectorAll('.toc').forEach(function(toc) {
      if (toc.dataset.initialized) return;
      toc.dataset.initialized = 'true';

      const tocList = toc.querySelector('.toc-list');
      if (!tocList) return;

      // Find the associated post-content (next sibling or parent's post-content)
      let article = toc.nextElementSibling;
      while (article && !article.classList.contains('post-content')) {
        article = article.nextElementSibling;
      }
      // Fallback: look for .post-content in the document (single post page)
      if (!article) {
        article = document.querySelector('.post-content');
      }

      if (!article) {
        toc.style.display = 'none';
        return;
      }

      const headings = article.querySelectorAll('h2, h3');

      if (headings.length < 3) {
        toc.style.display = 'none';
        return;
      }

      const tocId = toc.dataset.tocId || Math.random().toString(36).substr(2, 9);

      headings.forEach(function(heading, index) {
        // Add unique ID if missing
        if (!heading.id) {
          heading.id = 'toc-' + tocId + '-heading-' + index;
        }

        const li = document.createElement('li');
        li.className = 'toc-' + heading.tagName.toLowerCase();

        const a = document.createElement('a');
        a.href = '#' + heading.id;
        a.textContent = heading.textContent;

        li.appendChild(a);
        tocList.appendChild(li);
      });
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initTOC);
  } else {
    initTOC();
  }
})();
</script>
<div class="post-content e-content" itemprop="articleBody">
    <p><img src="/assets/images/posts/block-team.png" class="post-marker" alt="" /></p>

<p>When multiple AI agents work together, how should they communicate? Fixed patterns fail at scale. DyTopo rebuilds the communication graph each round based on what agents need and what they can offer.</p>

<div class="resource-box">

  <table>
    <thead>
      <tr>
        <th>Resource</th>
        <th>Link</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Video</strong></td>
        <td><a href="https://www.youtube.com/shorts/_8_08H97LxM">DyTopo</a><br /><a href="https://www.youtube.com/shorts/_8_08H97LxM"><img src="https://img.youtube.com/vi/_8_08H97LxM/mqdefault.jpg" alt="Video" class="video-thumb" /></a></td>
      </tr>
      <tr>
        <td><strong>Paper</strong></td>
        <td><a href="https://arxiv.org/abs/2505.16128">arXiv:2505.16128</a></td>
      </tr>
      <tr>
        <td><strong>Code</strong></td>
        <td><a href="https://github.com/softwarewrighter/dytopo-rs">dytopo-rs</a></td>
      </tr>
    </tbody>
  </table>

</div>

<h2 id="the-problem-fixed-topologies-dont-scale">The Problem: Fixed Topologies Don’t Scale</h2>

<p>Multi-agent systems need communication patterns. The obvious approaches have problems:</p>

<table>
  <thead>
    <tr>
      <th>Topology</th>
      <th>Problem</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>All-to-all</strong></td>
      <td>Context explosion—every agent reads every message</td>
    </tr>
    <tr>
      <td><strong>Chain</strong></td>
      <td>Bottlenecks—one slow agent blocks everyone</td>
    </tr>
    <tr>
      <td><strong>Star</strong></td>
      <td>Single point of failure at the hub</td>
    </tr>
  </tbody>
</table>

<p>As agent count grows, fixed topologies either explode in messages or create chokepoints.</p>

<h2 id="the-dytopo-solution-dynamic-routing">The DyTopo Solution: Dynamic Routing</h2>

<p>DyTopo (Dynamic Topology) solves this by reconstructing the communication graph each round. The key insight: <strong>agents know what they need and what they can offer</strong>.</p>

<p>Each round, every agent emits:</p>
<ul>
  <li><strong>Query</strong>: What information do I need?</li>
  <li><strong>Key</strong>: What can I contribute?</li>
</ul>

<p>The router computes semantic similarity between all keys and queries, then builds a <strong>sparse directed graph</strong>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>score(sender → receiver) = cosine(sender.key, receiver.query)
</code></pre></div></div>

<p>High-scoring pairs connect. Low-scoring pairs are ignored. The result: efficient, adaptive communication.</p>

<h2 id="how-it-works">How It Works</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Round N:
  1. Manager broadcasts goal
  2. Each agent produces:
     - Query (what I need)
     - Key (what I offer)
     - Draft (my current contribution)
  3. Router embeds keys and queries
  4. Similarity matrix → sparse graph (top-K per receiver)
  5. Messages flow along edges
  6. Trace written to JSONL
</code></pre></div></div>

<p>The topology adapts every round. An agent working on parsing might connect to the syntax expert in round 1, then the error-handling expert in round 2.</p>

<h2 id="the-implementation-rust-zero-python">The Implementation: Rust, Zero Python</h2>

<p>dytopo-rs is a <strong>fully Rust implementation</strong> with no Python dependencies:</p>

<table>
  <thead>
    <tr>
      <th>Crate</th>
      <th>Purpose</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">dytopo-core</code></td>
      <td>Shared types (AgentId, Topology, TraceEvent)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">dytopo-embed</code></td>
      <td>Text embedding (hash-based baseline, semantic planned)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">dytopo-router</code></td>
      <td>Sparse graph construction</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">dytopo-agents</code></td>
      <td>Agent implementations</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">dytopo-orchestrator</code></td>
      <td>Main execution loop</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">dytopo-viz</code></td>
      <td>DOT export for visualization</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">dytopo-cli</code></td>
      <td>Command-line interface</td>
    </tr>
  </tbody>
</table>

<h3 id="why-rust">Why Rust?</h3>

<ol>
  <li><strong>Zero-cost abstractions</strong> for performance-critical embedding/routing</li>
  <li><strong>Strong type system</strong> catches protocol mismatches at compile time</li>
  <li><strong>No Python dependency</strong> for baseline demos</li>
  <li><strong>Fearless concurrency</strong> for future parallelization</li>
</ol>

<h2 id="running-the-demo">Running the Demo</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo run <span class="nt">-p</span> dytopo-cli <span class="nt">--</span> demo <span class="nt">--rounds</span> 3 <span class="nt">--agents</span> 5 <span class="nt">--topk</span> 2
</code></pre></div></div>

<p>This produces:</p>
<ul>
  <li>Per-round topology printed to stdout</li>
  <li><code class="language-plaintext highlighter-rouge">./traces/trace_*.jsonl</code> for machine-readable analysis</li>
  <li>DOT files for graph visualization</li>
</ul>

<h2 id="current-status">Current Status</h2>

<p><strong>Milestone 0 is complete</strong>—the system runs end-to-end with stub agents and hash-based embeddings.</p>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Status</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Core types and traits</td>
      <td>Done</td>
    </tr>
    <tr>
      <td>Hash embedder (deterministic)</td>
      <td>Done</td>
    </tr>
    <tr>
      <td>Top-K sparse routing</td>
      <td>Done</td>
    </tr>
    <tr>
      <td>Stub agents with templates</td>
      <td>Done</td>
    </tr>
    <tr>
      <td>Orchestrator loop</td>
      <td>Done</td>
    </tr>
    <tr>
      <td>JSONL tracing</td>
      <td>Done</td>
    </tr>
    <tr>
      <td>DOT visualization</td>
      <td>Done</td>
    </tr>
  </tbody>
</table>

<h3 id="planned">Planned</h3>

<ul>
  <li>Semantic embeddings (fastembed/candle)</li>
  <li>LLM-backed agents (Ollama integration)</li>
  <li>Inbox summarization for long conversations</li>
  <li>Evaluation harness comparing topologies</li>
</ul>

<h2 id="key-design-decisions">Key Design Decisions</h2>

<h3 id="why-hash-embeddings-first">Why Hash Embeddings First?</h3>

<p>The baseline uses deterministic hash-based embeddings:</p>
<ul>
  <li><strong>Reproducible</strong> demos for debugging</li>
  <li><strong>No external dependencies</strong> to download</li>
  <li>Validates the full pipeline before adding ML complexity</li>
</ul>

<p>Semantic embeddings are planned as drop-in replacements.</p>

<h3 id="why-sparse-graphs">Why Sparse Graphs?</h3>

<p>Each agent receives at most <code class="language-plaintext highlighter-rouge">topk</code> messages per round:</p>
<ul>
  <li><strong>Prevents context explosion</strong> as agent count grows</li>
  <li><strong>Makes communication interpretable</strong>—you can trace why agents connected</li>
  <li><strong>Matches the paper’s approach</strong></li>
</ul>

<h3 id="why-jsonl-traces">Why JSONL Traces?</h3>

<p>Every event is logged to JSONL:</p>
<ul>
  <li><strong>Append-only</strong> for streaming</li>
  <li><strong>Line-based</strong> for grep/filtering</li>
  <li><strong>Machine-parseable</strong> for analysis tools</li>
  <li><strong>Human-readable</strong> for debugging</li>
</ul>

<h2 id="topology-comparison">Topology Comparison</h2>

<p>The system supports multiple topology strategies for comparison:</p>

<table>
  <thead>
    <tr>
      <th>Strategy</th>
      <th>Description</th>
      <th>Use Case</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">dynamic</code></td>
      <td>DyTopo routing</td>
      <td>Adaptive, sparse</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">fully_connected</code></td>
      <td>All-to-all</td>
      <td>Baseline comparison</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">chain</code></td>
      <td>Sequential</td>
      <td>Pipeline tasks</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">star</code></td>
      <td>Hub-and-spoke</td>
      <td>Centralized coordination</td>
    </tr>
  </tbody>
</table>

<h2 id="whats-next">What’s Next</h2>

<ol>
  <li><strong>LLM Agent Support</strong> (Milestone 2)—Replace stubs with real reasoning</li>
  <li><strong>Semantic Embeddings</strong> (Milestone 1)—Meaningful routing decisions</li>
  <li><strong>Evaluation Harness</strong> (Milestone 4)—Quantify DyTopo advantages</li>
</ol>

<h2 id="resources">Resources</h2>

<ul>
  <li><a href="https://arxiv.org/abs/2505.16128">DyTopo Paper (arXiv:2505.16128)</a> - Li et al., 2025</li>
  <li><a href="https://github.com/softwarewrighter/dytopo-rs">dytopo-rs Repository</a></li>
</ul>

<hr />

<p><em>Dynamic topology lets agents find the right collaborators each round. No context explosion. No bottlenecks. Just efficient, adaptive communication.</em></p>


  </div><div class="series-nav">
    <p><em>Part 2 of the Machine Learning series. <a href="/series/#machine-learning">View all parts</a> | <a href="/2026/02/13/rlm-recursive-language-models/">Next: Part 3 →</a></em></p>
  </div>





<div class="youtube-embed-container" id="yt-container-_8_08H97LxM">
  <h3>Watch the Video</h3>
  <div class="youtube-embed-wrapper">
    <iframe
      id="yt-player-_8_08H97LxM"
      src="https://www.youtube.com/embed/_8_08H97LxM?enablejsapi=1&mute=1&autoplay=1&cc_load_policy=1"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      allowfullscreen
      loading="lazy">
    </iframe>
  </div>
  <p class="youtube-embed-note">Unmute to hear narration.</p>
</div>

<style>
.youtube-embed-container {
  margin: 2rem auto;
  padding: 1.5rem;
  background: var(--code-background-color, #f5f5f5);
  border-radius: 8px;
  width: 66%;
}

.youtube-embed-container h3 {
  margin-top: 0;
  margin-bottom: 1rem;
}

.youtube-embed-wrapper {
  position: relative;
  width: 100%;
  padding-bottom: 56.25%; /* 16:9 aspect ratio */
  height: 0;
  overflow: hidden;
}

.youtube-embed-wrapper iframe {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border-radius: 4px;
}

.youtube-embed-note {
  margin-top: 0.75rem;
  margin-bottom: 0;
  font-size: 0.85rem;
  color: var(--text-muted-color, #666);
  font-style: italic;
}
</style>

<script>
(function() {
  const containerId = 'yt-container-_8_08H97LxM';
  const playerId = 'yt-player-_8_08H97LxM';

  // Load YouTube IFrame API if not already loaded
  if (!window.YT) {
    const tag = document.createElement('script');
    tag.src = 'https://www.youtube.com/iframe_api';
    const firstScriptTag = document.getElementsByTagName('script')[0];
    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
  }

  let player;
  let isPlaying = false;

  function onYouTubeIframeAPIReady() {
    player = new YT.Player(playerId, {
      events: {
        'onReady': onPlayerReady
      }
    });
  }

  function onPlayerReady(event) {
    setupIntersectionObserver();
  }

  function setupIntersectionObserver() {
    const container = document.getElementById(containerId);
    if (!container) return;

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && entry.intersectionRatio >= 0.5) {
          if (!isPlaying && player && player.playVideo) {
            player.playVideo();
            isPlaying = true;
          }
        } else {
          if (isPlaying && player && player.pauseVideo) {
            player.pauseVideo();
            isPlaying = false;
          }
        }
      });
    }, {
      threshold: [0.5]
    });

    observer.observe(container);
  }

  // Handle API ready callback
  if (window.YT && window.YT.Player) {
    onYouTubeIframeAPIReady();
  } else {
    window.onYouTubeIframeAPIReady = window.onYouTubeIframeAPIReady || onYouTubeIframeAPIReady;
    // Queue multiple players if needed
    const existingCallback = window.onYouTubeIframeAPIReady;
    window.onYouTubeIframeAPIReady = function() {
      if (existingCallback) existingCallback();
      onYouTubeIframeAPIReady();
    };
  }
})();
</script>

<img src="/assets/images/site/post-separator.png" class="post-separator" alt=""><a class="u-url" href="/2026/02/12/dytopo-rs-dynamic-topology-multi-agent/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Software Wrighter Lab Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Mike Wright</li><li><a class="u-email" href="mailto:"></a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/softwarewrighter"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">softwarewrighter</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>AI coding agents, systems programming, and practical machine learning</p>
      </div>
    </div>

    <div class="footer-copyright">
      <p>Copyright &copy; 2026 Michael A. Wright</p>
    </div>

  </div>

  <button id="scroll-to-top" aria-label="Scroll to top" title="Scroll to top">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="18 15 12 9 6 15"></polyline>
    </svg>
  </button>

  <style>
  #scroll-to-top {
    position: fixed;
    bottom: 2rem;
    right: 2rem;
    width: 44px;
    height: 44px;
    border-radius: 50%;
    border: none;
    background: var(--brand-color, #2a7ae2);
    color: white;
    cursor: pointer;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s, visibility 0.3s, transform 0.2s;
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
  }

  #scroll-to-top:hover {
    transform: scale(1.1);
  }

  #scroll-to-top.visible {
    opacity: 1;
    visibility: visible;
  }

  #scroll-to-top svg {
    width: 24px;
    height: 24px;
  }
  </style>

  <script>
  (function() {
    const btn = document.getElementById('scroll-to-top');
    if (!btn) return;

    window.addEventListener('scroll', function() {
      if (window.scrollY > 300) {
        btn.classList.add('visible');
      } else {
        btn.classList.remove('visible');
      }
    });

    btn.addEventListener('click', function() {
      window.scrollTo({ top: 0, behavior: 'smooth' });
    });
  })();
  </script>

</footer>
</body>

</html>
