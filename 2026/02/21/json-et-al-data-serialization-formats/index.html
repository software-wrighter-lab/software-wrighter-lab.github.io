<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>JSON et al: A Deep Dive into Data Serialization Formats | Software Wrighter Lab Blog</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="JSON et al: A Deep Dive into Data Serialization Formats" />
<meta name="author" content="Software Wrighter" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="JSON is everywhere. APIs. Logs. Databases. Configuration files. But it’s not alone. A whole ecosystem of formats exists—each optimizing for different tradeoffs. This post expands on the JSON et al short, providing technical depth on each format: when it was created, where it’s specified, and what problems it solves. The Tradeoff Triangle Before diving in, understand the fundamental constraint. Data formats balance three competing goals: Goal Description Human Readability Can a developer read and edit it directly? Compactness How many bytes does it take to represent data? Query Performance How fast can you access specific fields? You usually only get two. JSON optimizes readability. Protobuf optimizes compactness. JSONB optimizes query performance. No format wins everywhere. JSON: The Ubiquitous Baseline Created: 2001 (discovered/formalized by Douglas Crockford) Specification: ECMA-404 (2013), RFC 8259 (2017) File Extension: .json JSON (JavaScript Object Notation) emerged from JavaScript’s object literal syntax but became language-agnostic. Crockford didn’t invent it—he “discovered” it already existing in JavaScript and formalized the specification. Technical Details Encoding: UTF-8 text (UTF-16/32 allowed but rare) Data Types: Objects {}, arrays [], strings, numbers, booleans, null Schema: None required Comments: Not allowed in strict JSON Strengths Universal parser support (every language has one) Human readable without tools Web-native (JavaScript parses it natively) Simple specification (fits on a business card) Weaknesses Verbose (field names repeated for every object) No binary data type (must base64-encode) No comments (frustrating for config files) Parsing overhead (tokenization + string decoding every time) ELI5 Like typing a long email instead of sending a terse text. Every message spells everything out—clear, but verbose. When to Use REST APIs, configuration (when comments aren’t needed), data interchange between systems, anywhere human readability matters more than efficiency. JSONL / NDJSON: Streaming JSON Created: ~2013 (formalized) Specification: JSON Lines, NDJSON File Extension: .jsonl, .ndjson JSONL (JSON Lines) and NDJSON (Newline-Delimited JSON) are the same concept: one valid JSON object per line, separated by newlines. Technical Details {&quot;name&quot;: &quot;Alice&quot;, &quot;score&quot;: 95} {&quot;name&quot;: &quot;Bob&quot;, &quot;score&quot;: 87} {&quot;name&quot;: &quot;Carol&quot;, &quot;score&quot;: 92} No wrapping array. Each line is independently parseable. Strengths Streaming: Process line-by-line without loading entire file Append-only: Add records without rewriting the file Parallel processing: Split by line, distribute to workers Fault-tolerant: One corrupt line doesn’t invalidate the file Weaknesses Not valid JSON (can’t parse with standard JSON parser) Still text-based (same verbosity as JSON) No random access by index ELI5 Like removing one comma per line to save some typing. Each line is self-contained, so you can grab and process them one at a time. When to Use Log files, big data pipelines (Spark, Pandas), ML datasets, event streams, anywhere you need to process records incrementally. JSONB: Binary JSON for Databases Created: 2014 (PostgreSQL 9.4) Specification: Implementation-specific (no universal standard) Storage: Database column type JSONB isn’t a file format—it’s a database storage optimization. PostgreSQL’s JSONB differs from MongoDB’s BSON, which differs from other implementations. PostgreSQL JSONB Details Parsed once: Text converted to binary on INSERT Keys sorted: Deterministic ordering for indexing Duplicates removed: Last value wins Offset table: O(log n) field lookup instead of O(n) text scanning MongoDB BSON Specification: bsonspec.org BSON (Binary JSON) is MongoDB’s serialization format. Unlike PostgreSQL’s JSONB, BSON is a standalone binary format: Type-prefixed values Supports additional types (Date, Binary, ObjectId) Length-prefixed for fast skipping ~10-15% smaller than JSON typically Strengths Fast queries without re-parsing Indexable (GIN indexes on JSONB in PostgreSQL) Type coercion at storage time Weaknesses Not portable (implementation-specific) Not human-readable INSERT overhead (parsing cost upfront) ELI5 Instead of cooking from scratch every time, you heat a pre-made meal. The prep work happens once (on INSERT), so serving (queries) is fast. When to Use Database storage where you query into JSON structures. PostgreSQL JSONB + GIN indexes enable fast @&gt; containment queries. Protocol Buffers: Google’s Schema-First Format Created: 2001 (internal Google), 2008 (open-sourced) Specification: developers.google.com/protocol-buffers File Extension: .proto (schema), binary wire format Protocol Buffers (Protobuf) is Google’s language-neutral, schema-required serialization format. It powers gRPC. Technical Details Schema definition: message Sensor { int32 temperature = 1; int32 humidity = 2; } Wire format uses field numbers, not names: Field 1: 72 Field 2: 40 Key Features Varint encoding: Small integers use fewer bytes Field numbers: Enable backward compatibility Code generation: .proto → language-specific classes No self-description: Receiver must know schema Strengths Extremely compact (3-10x smaller than JSON typically) Fast serialization/deserialization Strong versioning semantics gRPC integration Weaknesses Requires schema agreement Not human-readable Tooling required for debugging Schema evolution has rules ELI5 Everyone agrees upfront what “field 1” means. You don’t waste space spelling out “temperature”—you just send the number 1 and the value. Both sides know the code. When to Use Microservices (gRPC), internal APIs, anywhere bandwidth and latency matter more than debuggability. ASN.1: The Telecom Veteran Created: 1984 (ITU-T X.208) Specification: ITU-T X.680-X.683 Encoding Rules: BER, DER, PER, XER, and more ASN.1 (Abstract Syntax Notation One) predates all modern formats. It defines both schema and encoding, with multiple encoding rules for different use cases. Encoding Rules Comparison Rule Use Case BER (Basic Encoding Rules) Flexible, general purpose DER (Distinguished Encoding Rules) Deterministic, for cryptography PER (Packed Encoding Rules) Most compact, for bandwidth-constrained XER (XML Encoding Rules) XML-based, for interop Where You See ASN.1 X.509 certificates (SSL/TLS certs are DER-encoded ASN.1) LDAP (directory services) SNMP (network management) Telecom protocols (SS7, GSM, LTE) Strengths Bit-level precision Proven over 40 years Multiple encoding options Formal verification possible Weaknesses Complex specification Steep learning curve Tooling can be expensive Security vulnerabilities in parsers (historically) ELI5 Same idea as Protobuf—everyone agrees upfront what each field number means. ASN.1 just got there 20 years earlier and handles even more edge cases. When to Use You probably won’t choose ASN.1 for new projects. You’ll encounter it in cryptography, certificates, and legacy telecom systems. YAML: Human-Friendly Configuration Created: 2001 (Clark Evans, Ingy döt Net, Oren Ben-Kiki) Specification: yaml.org/spec/1.2.2 File Extension: .yaml, .yml YAML (YAML Ain’t Markup Language) prioritizes human readability. It’s a superset of JSON—any valid JSON is valid YAML. Technical Details # Comments allowed! server: host: localhost port: 8080 features: - auth - logging Key Features Indentation-based: Whitespace matters Comments: # for single-line Anchors/aliases: &amp;name and *name for references Multiple documents: --- separator Strengths Highly readable Comments supported Multi-line strings without escaping Complex data structures Weaknesses “Norway problem”: NO parses as boolean false Whitespace sensitivity causes errors Multiple ways to express same data Security concerns (arbitrary code execution in some parsers) ELI5 Optimized for clarity, not bandwidth. YAML is for humans editing config files—not for machines exchanging data over networks. When to Use Configuration files (Kubernetes, Docker Compose, CI/CD), anywhere humans edit data directly and comments help. TOML: Minimal Configuration Created: 2013 (Tom Preston-Werner) Specification: toml.io File Extension: .toml TOML (Tom’s Obvious Minimal Language) emerged as a reaction to YAML’s complexity. It’s used by Rust (Cargo.toml), Python (pyproject.toml), and others. Technical Details [server] host = &quot;localhost&quot; port = 8080 [server.features] auth = true logging = true Key Features Explicit typing: Dates, times, arrays have clear syntax Sections: [section] and [section.subsection] No anchors: Intentionally simpler than YAML Deterministic: Same data = same representation Strengths Easy to read and write Unambiguous parsing Clear error messages Growing ecosystem support Weaknesses Less expressive than YAML Nested structures can be verbose Smaller ecosystem than JSON/YAML ELI5 Same goal as YAML—clarity for humans, not bandwidth for machines—but with stricter rules so you make fewer mistakes. When to Use Configuration files where YAML’s complexity isn’t needed. Rust projects (mandatory). Python packaging (pyproject.toml). TOON: Token-Optimized for LLMs Created: October 2025 (toon-format organization) Specification: github.com/toon-format/toon (v3.0) File Extension: .toon Media Type: text/toon (provisional) TOON (Token Oriented Object Notation) is the newest format in this list, designed specifically for LLM input. It’s a lossless representation of JSON that minimizes tokens. Technical Details TOON combines YAML-style indentation for nested objects with CSV-like tabular layouts for uniform arrays: users[2]{name,age}: Alice,25 Bob,30 Equivalent JSON: {&quot;users&quot;: [{&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25}, {&quot;name&quot;: &quot;Bob&quot;, &quot;age&quot;: 30}]} Key Features Header-based: Field names declared once, values follow 40% fewer tokens: Than equivalent JSON typically Lossless: Round-trips to JSON perfectly UTF-8 always: No encoding ambiguity Performance Metric JSON TOON Accuracy 69.7% 73.9% Efficiency (acc/1K tokens) 15.3 26.9 Strengths Significant token savings at scale Better context window utilization Lower API costs for LLM applications Human-readable (unlike binary formats) Weaknesses New format (October 2025) Limited tooling compared to JSON Requires conversion layer for existing systems Not yet widely adopted ELI5 Like having one header row for each column in a table instead of repeating the column name for every single row. You declare field names once, then just list the values. When to Use LLM prompts with structured data, RAG applications, anywhere token efficiency matters. Especially useful for large datasets with uniform object arrays. Implementations TypeScript: Reference implementation Python: toons (Rust-based, fast) Go, Rust, .NET: Available via toon-format org Alternatives Not in the Video MessagePack Created: 2008 (Sadayuki Furuhashi) Specification: msgpack.org Binary JSON without schema. Type-prefixed values, efficient numeric encoding. Use when: You want JSON semantics but smaller/faster. CBOR Created: 2013 (IETF) Specification: RFC 8949 Concise Binary Object Representation. Designed for constrained environments (IoT). Use when: Resource-constrained devices, need a standard binary format. Apache Avro Created: 2009 (Apache, Doug Cutting) Specification: avro.apache.org Schema-based, row-oriented binary format. Schema embedded or stored separately. Strong schema evolution support. Use when: Big data pipelines (Hadoop, Kafka), schema evolution is critical. Apache Parquet Created: 2013 (Twitter + Cloudera) Specification: parquet.apache.org Columnar storage format. Not for serialization—for analytics storage. Use when: Large-scale analytics, data warehousing, Spark/Pandas workflows. Cap’n Proto Created: 2013 (Kenton Varda, ex-Protobuf author) Specification: capnproto.org Zero-copy serialization. The serialized form is the in-memory form. Use when: Extreme performance requirements, inter-process communication. FlatBuffers Created: 2014 (Google) Specification: google.github.io/flatbuffers Zero-copy like Cap’n Proto but with better tooling. Used in games, mobile. Use when: Games, mobile apps, anywhere memory allocation matters. Quick Reference Format Year Schema Binary Human-Readable Best For JSON 2001 No No Yes APIs, interchange JSONL 2013 No No Yes Logs, streaming JSONB 2014 No Yes No Database queries Protobuf 2008 Yes Yes No Microservices ASN.1 1984 Yes Yes No Crypto, telecom YAML 2001 No No Yes Config files TOML 2013 No No Yes Simple config TOON 2025 No No Yes LLM prompts MessagePack 2008 No Yes No Fast JSON CBOR 2013 Optional Yes No IoT Avro 2009 Yes Yes No Big data Key Takeaways No “best” format exists. Each optimizes for different constraints. Text formats favor humans. JSON, YAML, TOML prioritize readability over efficiency. Binary formats favor machines. Protobuf, MessagePack, CBOR prioritize compactness and speed. Schema formats favor correctness. Protobuf, Avro, ASN.1 catch errors at compile time. The tradeoff triangle is real. Readability, compactness, query performance—pick two. The question isn’t “which format wins?” The question is: what problem are you solving? Resources ECMA-404 JSON Specification RFC 8259 JSON JSON Lines Specification PostgreSQL JSONB Documentation Protocol Buffers Documentation YAML 1.2.2 Specification TOML v1.0.0 Specification RFC 8949 CBOR MessagePack Specification Apache Avro Specification Data formats are design decisions. Choose based on your constraints, not trends. Questions? Find me on YouTube @SoftwareWrighter." />
<meta property="og:description" content="JSON is everywhere. APIs. Logs. Databases. Configuration files. But it’s not alone. A whole ecosystem of formats exists—each optimizing for different tradeoffs. This post expands on the JSON et al short, providing technical depth on each format: when it was created, where it’s specified, and what problems it solves. The Tradeoff Triangle Before diving in, understand the fundamental constraint. Data formats balance three competing goals: Goal Description Human Readability Can a developer read and edit it directly? Compactness How many bytes does it take to represent data? Query Performance How fast can you access specific fields? You usually only get two. JSON optimizes readability. Protobuf optimizes compactness. JSONB optimizes query performance. No format wins everywhere. JSON: The Ubiquitous Baseline Created: 2001 (discovered/formalized by Douglas Crockford) Specification: ECMA-404 (2013), RFC 8259 (2017) File Extension: .json JSON (JavaScript Object Notation) emerged from JavaScript’s object literal syntax but became language-agnostic. Crockford didn’t invent it—he “discovered” it already existing in JavaScript and formalized the specification. Technical Details Encoding: UTF-8 text (UTF-16/32 allowed but rare) Data Types: Objects {}, arrays [], strings, numbers, booleans, null Schema: None required Comments: Not allowed in strict JSON Strengths Universal parser support (every language has one) Human readable without tools Web-native (JavaScript parses it natively) Simple specification (fits on a business card) Weaknesses Verbose (field names repeated for every object) No binary data type (must base64-encode) No comments (frustrating for config files) Parsing overhead (tokenization + string decoding every time) ELI5 Like typing a long email instead of sending a terse text. Every message spells everything out—clear, but verbose. When to Use REST APIs, configuration (when comments aren’t needed), data interchange between systems, anywhere human readability matters more than efficiency. JSONL / NDJSON: Streaming JSON Created: ~2013 (formalized) Specification: JSON Lines, NDJSON File Extension: .jsonl, .ndjson JSONL (JSON Lines) and NDJSON (Newline-Delimited JSON) are the same concept: one valid JSON object per line, separated by newlines. Technical Details {&quot;name&quot;: &quot;Alice&quot;, &quot;score&quot;: 95} {&quot;name&quot;: &quot;Bob&quot;, &quot;score&quot;: 87} {&quot;name&quot;: &quot;Carol&quot;, &quot;score&quot;: 92} No wrapping array. Each line is independently parseable. Strengths Streaming: Process line-by-line without loading entire file Append-only: Add records without rewriting the file Parallel processing: Split by line, distribute to workers Fault-tolerant: One corrupt line doesn’t invalidate the file Weaknesses Not valid JSON (can’t parse with standard JSON parser) Still text-based (same verbosity as JSON) No random access by index ELI5 Like removing one comma per line to save some typing. Each line is self-contained, so you can grab and process them one at a time. When to Use Log files, big data pipelines (Spark, Pandas), ML datasets, event streams, anywhere you need to process records incrementally. JSONB: Binary JSON for Databases Created: 2014 (PostgreSQL 9.4) Specification: Implementation-specific (no universal standard) Storage: Database column type JSONB isn’t a file format—it’s a database storage optimization. PostgreSQL’s JSONB differs from MongoDB’s BSON, which differs from other implementations. PostgreSQL JSONB Details Parsed once: Text converted to binary on INSERT Keys sorted: Deterministic ordering for indexing Duplicates removed: Last value wins Offset table: O(log n) field lookup instead of O(n) text scanning MongoDB BSON Specification: bsonspec.org BSON (Binary JSON) is MongoDB’s serialization format. Unlike PostgreSQL’s JSONB, BSON is a standalone binary format: Type-prefixed values Supports additional types (Date, Binary, ObjectId) Length-prefixed for fast skipping ~10-15% smaller than JSON typically Strengths Fast queries without re-parsing Indexable (GIN indexes on JSONB in PostgreSQL) Type coercion at storage time Weaknesses Not portable (implementation-specific) Not human-readable INSERT overhead (parsing cost upfront) ELI5 Instead of cooking from scratch every time, you heat a pre-made meal. The prep work happens once (on INSERT), so serving (queries) is fast. When to Use Database storage where you query into JSON structures. PostgreSQL JSONB + GIN indexes enable fast @&gt; containment queries. Protocol Buffers: Google’s Schema-First Format Created: 2001 (internal Google), 2008 (open-sourced) Specification: developers.google.com/protocol-buffers File Extension: .proto (schema), binary wire format Protocol Buffers (Protobuf) is Google’s language-neutral, schema-required serialization format. It powers gRPC. Technical Details Schema definition: message Sensor { int32 temperature = 1; int32 humidity = 2; } Wire format uses field numbers, not names: Field 1: 72 Field 2: 40 Key Features Varint encoding: Small integers use fewer bytes Field numbers: Enable backward compatibility Code generation: .proto → language-specific classes No self-description: Receiver must know schema Strengths Extremely compact (3-10x smaller than JSON typically) Fast serialization/deserialization Strong versioning semantics gRPC integration Weaknesses Requires schema agreement Not human-readable Tooling required for debugging Schema evolution has rules ELI5 Everyone agrees upfront what “field 1” means. You don’t waste space spelling out “temperature”—you just send the number 1 and the value. Both sides know the code. When to Use Microservices (gRPC), internal APIs, anywhere bandwidth and latency matter more than debuggability. ASN.1: The Telecom Veteran Created: 1984 (ITU-T X.208) Specification: ITU-T X.680-X.683 Encoding Rules: BER, DER, PER, XER, and more ASN.1 (Abstract Syntax Notation One) predates all modern formats. It defines both schema and encoding, with multiple encoding rules for different use cases. Encoding Rules Comparison Rule Use Case BER (Basic Encoding Rules) Flexible, general purpose DER (Distinguished Encoding Rules) Deterministic, for cryptography PER (Packed Encoding Rules) Most compact, for bandwidth-constrained XER (XML Encoding Rules) XML-based, for interop Where You See ASN.1 X.509 certificates (SSL/TLS certs are DER-encoded ASN.1) LDAP (directory services) SNMP (network management) Telecom protocols (SS7, GSM, LTE) Strengths Bit-level precision Proven over 40 years Multiple encoding options Formal verification possible Weaknesses Complex specification Steep learning curve Tooling can be expensive Security vulnerabilities in parsers (historically) ELI5 Same idea as Protobuf—everyone agrees upfront what each field number means. ASN.1 just got there 20 years earlier and handles even more edge cases. When to Use You probably won’t choose ASN.1 for new projects. You’ll encounter it in cryptography, certificates, and legacy telecom systems. YAML: Human-Friendly Configuration Created: 2001 (Clark Evans, Ingy döt Net, Oren Ben-Kiki) Specification: yaml.org/spec/1.2.2 File Extension: .yaml, .yml YAML (YAML Ain’t Markup Language) prioritizes human readability. It’s a superset of JSON—any valid JSON is valid YAML. Technical Details # Comments allowed! server: host: localhost port: 8080 features: - auth - logging Key Features Indentation-based: Whitespace matters Comments: # for single-line Anchors/aliases: &amp;name and *name for references Multiple documents: --- separator Strengths Highly readable Comments supported Multi-line strings without escaping Complex data structures Weaknesses “Norway problem”: NO parses as boolean false Whitespace sensitivity causes errors Multiple ways to express same data Security concerns (arbitrary code execution in some parsers) ELI5 Optimized for clarity, not bandwidth. YAML is for humans editing config files—not for machines exchanging data over networks. When to Use Configuration files (Kubernetes, Docker Compose, CI/CD), anywhere humans edit data directly and comments help. TOML: Minimal Configuration Created: 2013 (Tom Preston-Werner) Specification: toml.io File Extension: .toml TOML (Tom’s Obvious Minimal Language) emerged as a reaction to YAML’s complexity. It’s used by Rust (Cargo.toml), Python (pyproject.toml), and others. Technical Details [server] host = &quot;localhost&quot; port = 8080 [server.features] auth = true logging = true Key Features Explicit typing: Dates, times, arrays have clear syntax Sections: [section] and [section.subsection] No anchors: Intentionally simpler than YAML Deterministic: Same data = same representation Strengths Easy to read and write Unambiguous parsing Clear error messages Growing ecosystem support Weaknesses Less expressive than YAML Nested structures can be verbose Smaller ecosystem than JSON/YAML ELI5 Same goal as YAML—clarity for humans, not bandwidth for machines—but with stricter rules so you make fewer mistakes. When to Use Configuration files where YAML’s complexity isn’t needed. Rust projects (mandatory). Python packaging (pyproject.toml). TOON: Token-Optimized for LLMs Created: October 2025 (toon-format organization) Specification: github.com/toon-format/toon (v3.0) File Extension: .toon Media Type: text/toon (provisional) TOON (Token Oriented Object Notation) is the newest format in this list, designed specifically for LLM input. It’s a lossless representation of JSON that minimizes tokens. Technical Details TOON combines YAML-style indentation for nested objects with CSV-like tabular layouts for uniform arrays: users[2]{name,age}: Alice,25 Bob,30 Equivalent JSON: {&quot;users&quot;: [{&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25}, {&quot;name&quot;: &quot;Bob&quot;, &quot;age&quot;: 30}]} Key Features Header-based: Field names declared once, values follow 40% fewer tokens: Than equivalent JSON typically Lossless: Round-trips to JSON perfectly UTF-8 always: No encoding ambiguity Performance Metric JSON TOON Accuracy 69.7% 73.9% Efficiency (acc/1K tokens) 15.3 26.9 Strengths Significant token savings at scale Better context window utilization Lower API costs for LLM applications Human-readable (unlike binary formats) Weaknesses New format (October 2025) Limited tooling compared to JSON Requires conversion layer for existing systems Not yet widely adopted ELI5 Like having one header row for each column in a table instead of repeating the column name for every single row. You declare field names once, then just list the values. When to Use LLM prompts with structured data, RAG applications, anywhere token efficiency matters. Especially useful for large datasets with uniform object arrays. Implementations TypeScript: Reference implementation Python: toons (Rust-based, fast) Go, Rust, .NET: Available via toon-format org Alternatives Not in the Video MessagePack Created: 2008 (Sadayuki Furuhashi) Specification: msgpack.org Binary JSON without schema. Type-prefixed values, efficient numeric encoding. Use when: You want JSON semantics but smaller/faster. CBOR Created: 2013 (IETF) Specification: RFC 8949 Concise Binary Object Representation. Designed for constrained environments (IoT). Use when: Resource-constrained devices, need a standard binary format. Apache Avro Created: 2009 (Apache, Doug Cutting) Specification: avro.apache.org Schema-based, row-oriented binary format. Schema embedded or stored separately. Strong schema evolution support. Use when: Big data pipelines (Hadoop, Kafka), schema evolution is critical. Apache Parquet Created: 2013 (Twitter + Cloudera) Specification: parquet.apache.org Columnar storage format. Not for serialization—for analytics storage. Use when: Large-scale analytics, data warehousing, Spark/Pandas workflows. Cap’n Proto Created: 2013 (Kenton Varda, ex-Protobuf author) Specification: capnproto.org Zero-copy serialization. The serialized form is the in-memory form. Use when: Extreme performance requirements, inter-process communication. FlatBuffers Created: 2014 (Google) Specification: google.github.io/flatbuffers Zero-copy like Cap’n Proto but with better tooling. Used in games, mobile. Use when: Games, mobile apps, anywhere memory allocation matters. Quick Reference Format Year Schema Binary Human-Readable Best For JSON 2001 No No Yes APIs, interchange JSONL 2013 No No Yes Logs, streaming JSONB 2014 No Yes No Database queries Protobuf 2008 Yes Yes No Microservices ASN.1 1984 Yes Yes No Crypto, telecom YAML 2001 No No Yes Config files TOML 2013 No No Yes Simple config TOON 2025 No No Yes LLM prompts MessagePack 2008 No Yes No Fast JSON CBOR 2013 Optional Yes No IoT Avro 2009 Yes Yes No Big data Key Takeaways No “best” format exists. Each optimizes for different constraints. Text formats favor humans. JSON, YAML, TOML prioritize readability over efficiency. Binary formats favor machines. Protobuf, MessagePack, CBOR prioritize compactness and speed. Schema formats favor correctness. Protobuf, Avro, ASN.1 catch errors at compile time. The tradeoff triangle is real. Readability, compactness, query performance—pick two. The question isn’t “which format wins?” The question is: what problem are you solving? Resources ECMA-404 JSON Specification RFC 8259 JSON JSON Lines Specification PostgreSQL JSONB Documentation Protocol Buffers Documentation YAML 1.2.2 Specification TOML v1.0.0 Specification RFC 8949 CBOR MessagePack Specification Apache Avro Specification Data formats are design decisions. Choose based on your constraints, not trends. Questions? Find me on YouTube @SoftwareWrighter." />
<link rel="canonical" href="http://localhost:5907/2026/02/21/json-et-al-data-serialization-formats/" />
<meta property="og:url" content="http://localhost:5907/2026/02/21/json-et-al-data-serialization-formats/" />
<meta property="og:site_name" content="Software Wrighter Lab Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2026-02-21T14:00:00-08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="JSON et al: A Deep Dive into Data Serialization Formats" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Software Wrighter"},"dateModified":"2026-02-21T14:00:00-08:00","datePublished":"2026-02-21T14:00:00-08:00","description":"JSON is everywhere. APIs. Logs. Databases. Configuration files. But it’s not alone. A whole ecosystem of formats exists—each optimizing for different tradeoffs. This post expands on the JSON et al short, providing technical depth on each format: when it was created, where it’s specified, and what problems it solves. The Tradeoff Triangle Before diving in, understand the fundamental constraint. Data formats balance three competing goals: Goal Description Human Readability Can a developer read and edit it directly? Compactness How many bytes does it take to represent data? Query Performance How fast can you access specific fields? You usually only get two. JSON optimizes readability. Protobuf optimizes compactness. JSONB optimizes query performance. No format wins everywhere. JSON: The Ubiquitous Baseline Created: 2001 (discovered/formalized by Douglas Crockford) Specification: ECMA-404 (2013), RFC 8259 (2017) File Extension: .json JSON (JavaScript Object Notation) emerged from JavaScript’s object literal syntax but became language-agnostic. Crockford didn’t invent it—he “discovered” it already existing in JavaScript and formalized the specification. Technical Details Encoding: UTF-8 text (UTF-16/32 allowed but rare) Data Types: Objects {}, arrays [], strings, numbers, booleans, null Schema: None required Comments: Not allowed in strict JSON Strengths Universal parser support (every language has one) Human readable without tools Web-native (JavaScript parses it natively) Simple specification (fits on a business card) Weaknesses Verbose (field names repeated for every object) No binary data type (must base64-encode) No comments (frustrating for config files) Parsing overhead (tokenization + string decoding every time) ELI5 Like typing a long email instead of sending a terse text. Every message spells everything out—clear, but verbose. When to Use REST APIs, configuration (when comments aren’t needed), data interchange between systems, anywhere human readability matters more than efficiency. JSONL / NDJSON: Streaming JSON Created: ~2013 (formalized) Specification: JSON Lines, NDJSON File Extension: .jsonl, .ndjson JSONL (JSON Lines) and NDJSON (Newline-Delimited JSON) are the same concept: one valid JSON object per line, separated by newlines. Technical Details {&quot;name&quot;: &quot;Alice&quot;, &quot;score&quot;: 95} {&quot;name&quot;: &quot;Bob&quot;, &quot;score&quot;: 87} {&quot;name&quot;: &quot;Carol&quot;, &quot;score&quot;: 92} No wrapping array. Each line is independently parseable. Strengths Streaming: Process line-by-line without loading entire file Append-only: Add records without rewriting the file Parallel processing: Split by line, distribute to workers Fault-tolerant: One corrupt line doesn’t invalidate the file Weaknesses Not valid JSON (can’t parse with standard JSON parser) Still text-based (same verbosity as JSON) No random access by index ELI5 Like removing one comma per line to save some typing. Each line is self-contained, so you can grab and process them one at a time. When to Use Log files, big data pipelines (Spark, Pandas), ML datasets, event streams, anywhere you need to process records incrementally. JSONB: Binary JSON for Databases Created: 2014 (PostgreSQL 9.4) Specification: Implementation-specific (no universal standard) Storage: Database column type JSONB isn’t a file format—it’s a database storage optimization. PostgreSQL’s JSONB differs from MongoDB’s BSON, which differs from other implementations. PostgreSQL JSONB Details Parsed once: Text converted to binary on INSERT Keys sorted: Deterministic ordering for indexing Duplicates removed: Last value wins Offset table: O(log n) field lookup instead of O(n) text scanning MongoDB BSON Specification: bsonspec.org BSON (Binary JSON) is MongoDB’s serialization format. Unlike PostgreSQL’s JSONB, BSON is a standalone binary format: Type-prefixed values Supports additional types (Date, Binary, ObjectId) Length-prefixed for fast skipping ~10-15% smaller than JSON typically Strengths Fast queries without re-parsing Indexable (GIN indexes on JSONB in PostgreSQL) Type coercion at storage time Weaknesses Not portable (implementation-specific) Not human-readable INSERT overhead (parsing cost upfront) ELI5 Instead of cooking from scratch every time, you heat a pre-made meal. The prep work happens once (on INSERT), so serving (queries) is fast. When to Use Database storage where you query into JSON structures. PostgreSQL JSONB + GIN indexes enable fast @&gt; containment queries. Protocol Buffers: Google’s Schema-First Format Created: 2001 (internal Google), 2008 (open-sourced) Specification: developers.google.com/protocol-buffers File Extension: .proto (schema), binary wire format Protocol Buffers (Protobuf) is Google’s language-neutral, schema-required serialization format. It powers gRPC. Technical Details Schema definition: message Sensor { int32 temperature = 1; int32 humidity = 2; } Wire format uses field numbers, not names: Field 1: 72 Field 2: 40 Key Features Varint encoding: Small integers use fewer bytes Field numbers: Enable backward compatibility Code generation: .proto → language-specific classes No self-description: Receiver must know schema Strengths Extremely compact (3-10x smaller than JSON typically) Fast serialization/deserialization Strong versioning semantics gRPC integration Weaknesses Requires schema agreement Not human-readable Tooling required for debugging Schema evolution has rules ELI5 Everyone agrees upfront what “field 1” means. You don’t waste space spelling out “temperature”—you just send the number 1 and the value. Both sides know the code. When to Use Microservices (gRPC), internal APIs, anywhere bandwidth and latency matter more than debuggability. ASN.1: The Telecom Veteran Created: 1984 (ITU-T X.208) Specification: ITU-T X.680-X.683 Encoding Rules: BER, DER, PER, XER, and more ASN.1 (Abstract Syntax Notation One) predates all modern formats. It defines both schema and encoding, with multiple encoding rules for different use cases. Encoding Rules Comparison Rule Use Case BER (Basic Encoding Rules) Flexible, general purpose DER (Distinguished Encoding Rules) Deterministic, for cryptography PER (Packed Encoding Rules) Most compact, for bandwidth-constrained XER (XML Encoding Rules) XML-based, for interop Where You See ASN.1 X.509 certificates (SSL/TLS certs are DER-encoded ASN.1) LDAP (directory services) SNMP (network management) Telecom protocols (SS7, GSM, LTE) Strengths Bit-level precision Proven over 40 years Multiple encoding options Formal verification possible Weaknesses Complex specification Steep learning curve Tooling can be expensive Security vulnerabilities in parsers (historically) ELI5 Same idea as Protobuf—everyone agrees upfront what each field number means. ASN.1 just got there 20 years earlier and handles even more edge cases. When to Use You probably won’t choose ASN.1 for new projects. You’ll encounter it in cryptography, certificates, and legacy telecom systems. YAML: Human-Friendly Configuration Created: 2001 (Clark Evans, Ingy döt Net, Oren Ben-Kiki) Specification: yaml.org/spec/1.2.2 File Extension: .yaml, .yml YAML (YAML Ain’t Markup Language) prioritizes human readability. It’s a superset of JSON—any valid JSON is valid YAML. Technical Details # Comments allowed! server: host: localhost port: 8080 features: - auth - logging Key Features Indentation-based: Whitespace matters Comments: # for single-line Anchors/aliases: &amp;name and *name for references Multiple documents: --- separator Strengths Highly readable Comments supported Multi-line strings without escaping Complex data structures Weaknesses “Norway problem”: NO parses as boolean false Whitespace sensitivity causes errors Multiple ways to express same data Security concerns (arbitrary code execution in some parsers) ELI5 Optimized for clarity, not bandwidth. YAML is for humans editing config files—not for machines exchanging data over networks. When to Use Configuration files (Kubernetes, Docker Compose, CI/CD), anywhere humans edit data directly and comments help. TOML: Minimal Configuration Created: 2013 (Tom Preston-Werner) Specification: toml.io File Extension: .toml TOML (Tom’s Obvious Minimal Language) emerged as a reaction to YAML’s complexity. It’s used by Rust (Cargo.toml), Python (pyproject.toml), and others. Technical Details [server] host = &quot;localhost&quot; port = 8080 [server.features] auth = true logging = true Key Features Explicit typing: Dates, times, arrays have clear syntax Sections: [section] and [section.subsection] No anchors: Intentionally simpler than YAML Deterministic: Same data = same representation Strengths Easy to read and write Unambiguous parsing Clear error messages Growing ecosystem support Weaknesses Less expressive than YAML Nested structures can be verbose Smaller ecosystem than JSON/YAML ELI5 Same goal as YAML—clarity for humans, not bandwidth for machines—but with stricter rules so you make fewer mistakes. When to Use Configuration files where YAML’s complexity isn’t needed. Rust projects (mandatory). Python packaging (pyproject.toml). TOON: Token-Optimized for LLMs Created: October 2025 (toon-format organization) Specification: github.com/toon-format/toon (v3.0) File Extension: .toon Media Type: text/toon (provisional) TOON (Token Oriented Object Notation) is the newest format in this list, designed specifically for LLM input. It’s a lossless representation of JSON that minimizes tokens. Technical Details TOON combines YAML-style indentation for nested objects with CSV-like tabular layouts for uniform arrays: users[2]{name,age}: Alice,25 Bob,30 Equivalent JSON: {&quot;users&quot;: [{&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25}, {&quot;name&quot;: &quot;Bob&quot;, &quot;age&quot;: 30}]} Key Features Header-based: Field names declared once, values follow 40% fewer tokens: Than equivalent JSON typically Lossless: Round-trips to JSON perfectly UTF-8 always: No encoding ambiguity Performance Metric JSON TOON Accuracy 69.7% 73.9% Efficiency (acc/1K tokens) 15.3 26.9 Strengths Significant token savings at scale Better context window utilization Lower API costs for LLM applications Human-readable (unlike binary formats) Weaknesses New format (October 2025) Limited tooling compared to JSON Requires conversion layer for existing systems Not yet widely adopted ELI5 Like having one header row for each column in a table instead of repeating the column name for every single row. You declare field names once, then just list the values. When to Use LLM prompts with structured data, RAG applications, anywhere token efficiency matters. Especially useful for large datasets with uniform object arrays. Implementations TypeScript: Reference implementation Python: toons (Rust-based, fast) Go, Rust, .NET: Available via toon-format org Alternatives Not in the Video MessagePack Created: 2008 (Sadayuki Furuhashi) Specification: msgpack.org Binary JSON without schema. Type-prefixed values, efficient numeric encoding. Use when: You want JSON semantics but smaller/faster. CBOR Created: 2013 (IETF) Specification: RFC 8949 Concise Binary Object Representation. Designed for constrained environments (IoT). Use when: Resource-constrained devices, need a standard binary format. Apache Avro Created: 2009 (Apache, Doug Cutting) Specification: avro.apache.org Schema-based, row-oriented binary format. Schema embedded or stored separately. Strong schema evolution support. Use when: Big data pipelines (Hadoop, Kafka), schema evolution is critical. Apache Parquet Created: 2013 (Twitter + Cloudera) Specification: parquet.apache.org Columnar storage format. Not for serialization—for analytics storage. Use when: Large-scale analytics, data warehousing, Spark/Pandas workflows. Cap’n Proto Created: 2013 (Kenton Varda, ex-Protobuf author) Specification: capnproto.org Zero-copy serialization. The serialized form is the in-memory form. Use when: Extreme performance requirements, inter-process communication. FlatBuffers Created: 2014 (Google) Specification: google.github.io/flatbuffers Zero-copy like Cap’n Proto but with better tooling. Used in games, mobile. Use when: Games, mobile apps, anywhere memory allocation matters. Quick Reference Format Year Schema Binary Human-Readable Best For JSON 2001 No No Yes APIs, interchange JSONL 2013 No No Yes Logs, streaming JSONB 2014 No Yes No Database queries Protobuf 2008 Yes Yes No Microservices ASN.1 1984 Yes Yes No Crypto, telecom YAML 2001 No No Yes Config files TOML 2013 No No Yes Simple config TOON 2025 No No Yes LLM prompts MessagePack 2008 No Yes No Fast JSON CBOR 2013 Optional Yes No IoT Avro 2009 Yes Yes No Big data Key Takeaways No “best” format exists. Each optimizes for different constraints. Text formats favor humans. JSON, YAML, TOML prioritize readability over efficiency. Binary formats favor machines. Protobuf, MessagePack, CBOR prioritize compactness and speed. Schema formats favor correctness. Protobuf, Avro, ASN.1 catch errors at compile time. The tradeoff triangle is real. Readability, compactness, query performance—pick two. The question isn’t “which format wins?” The question is: what problem are you solving? Resources ECMA-404 JSON Specification RFC 8259 JSON JSON Lines Specification PostgreSQL JSONB Documentation Protocol Buffers Documentation YAML 1.2.2 Specification TOML v1.0.0 Specification RFC 8949 CBOR MessagePack Specification Apache Avro Specification Data formats are design decisions. Choose based on your constraints, not trends. Questions? Find me on YouTube @SoftwareWrighter.","headline":"JSON et al: A Deep Dive into Data Serialization Formats","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:5907/2026/02/21/json-et-al-data-serialization-formats/"},"url":"http://localhost:5907/2026/02/21/json-et-al-data-serialization-formats/"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:5907/feed.xml" title="Software Wrighter Lab Blog" /><!-- Theme toggle script - load early to prevent flash -->
  <script>
    (function() {
      var stored = localStorage.getItem('sw-lab-theme');
      var theme = stored;
      if (!theme) {
        theme = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
      }
      document.documentElement.setAttribute('data-theme', theme);
    })();
  </script>
  <!-- Font size - load early to prevent flash -->
  <script>
    (function() {
      var NEW_DEFAULT = 110;
      var OLD_DEFAULT = 150;
      var stored = localStorage.getItem('sw-lab-font-size');
      var ack = localStorage.getItem('sw-lab-prefs-ack');
      var size = stored ? parseInt(stored, 10) : null;

      // Migration: if on old default and not acknowledged, use new default
      if (size === OLD_DEFAULT && ack !== 'true') {
        size = NEW_DEFAULT;
      } else if (size === null) {
        size = NEW_DEFAULT;
      }

      // Apply to post content when DOM is ready
      document.addEventListener('DOMContentLoaded', function() {
        var pc = document.querySelector('.post-content');
        if (pc) pc.style.fontSize = size + '%';
        var pl = document.querySelector('.post-list');
        if (pl) pl.style.fontSize = size + '%';
      });
    })();
  </script>
  <script src="/assets/js/theme-toggle.js" defer></script>
  <script src="/assets/js/font-size.js" defer></script>
  <script src="/assets/js/preferences.js" defer></script>
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">
      <img src="/assets/images/site/logo.jpg" alt="Software Wrighter Lab Blog" class="site-logo">
      <span class="site-title-text">Software Wrighter Lab Blog</span>
    </a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/abstracts/">Abstracts</a><a class="page-link" href="/index-all/">Index</a><a class="page-link" href="/series/">Series</a><a class="page-link" href="/tags/">Tags</a><a class="page-link" href="/categories/">Categories</a><a class="page-link" href="/search/">Search</a><div class="font-size-controls">
  <button class="font-size-btn" id="font-decrease" title="Decrease font size" aria-label="Decrease font size">A-</button>
  <button class="font-size-btn" id="font-reset" title="Reset font size" aria-label="Reset font size">A</button>
  <button class="font-size-btn" id="font-increase" title="Increase font size" aria-label="Increase font size">A+</button>
</div>
<button class="theme-toggle" aria-label="Switch theme" title="Switch theme">
  <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <circle cx="12" cy="12" r="5"></circle>
    <line x1="12" y1="1" x2="12" y2="3"></line>
    <line x1="12" y1="21" x2="12" y2="23"></line>
    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
    <line x1="1" y1="12" x2="3" y2="12"></line>
    <line x1="21" y1="12" x2="23" y2="12"></line>
    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
  </svg>
  <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
  </svg>
</button>
</div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">JSON et al: A Deep Dive into Data Serialization Formats</h1><p class="post-meta">February 21, 2026 &bull; Software Wrighter</p>
<p class="post-reading-info"><em><span class="post-word-count">2251 words</span> &bull; <span class="post-read-time">12 min read</span></em> &bull; <span class="abstract-toggle" onclick="this.classList.toggle('open'); this.parentElement.nextElementSibling.classList.toggle('open')">Abstract</span></p><div class="post-meta-abstract">JSON is everywhere, but it's not the only option. This post explores data formats beyond basic JSON—JSONL for streaming, JSONB for fast queries, Protocol Buffers for compact wire formats, YAML/TOML for human editing, and TOON for LLM efficiency. Each has trade-offs: pick two of readability, compactness, or speed.</div><div class="post-taxonomies"><span class="post-categories"><a href="/categories/#data-formats" class="category">data-formats</a><a href="/categories/#fundamentals" class="category">fundamentals</a></span><span class="post-tags"><a href="/tags/#json" class="tag">json</a><a href="/tags/#jsonb" class="tag">jsonb</a><a href="/tags/#jsonl" class="tag">jsonl</a><a href="/tags/#protobuf" class="tag">protobuf</a><a href="/tags/#yaml" class="tag">yaml</a><a href="/tags/#toml" class="tag">toml</a><a href="/tags/#serialization" class="tag">serialization</a></span></div></header><nav class="toc" data-toc-id="default">
  <h4>Contents</h4>
  <ul class="toc-list"></ul>
</nav>

<style>
/* Post content flows around floated TOC */
.post-content {
  overflow: hidden;
}

.toc {
  background: #fffde7;
  border-radius: 8px;
  padding: 1rem 1.5rem;
  margin: 0 1.5rem 1rem 0;
  float: left;
  max-width: 280px;
}

[data-theme="dark"] .toc {
  background: #3d3a00;
}

@media (prefers-color-scheme: dark) {
  :root:not([data-theme="light"]) .toc {
    background: #3d3a00;
  }
}

.toc h4 {
  margin: 0 0 0.75rem 0;
  font-size: 1rem;
}

.toc ul {
  margin: 0;
  padding-left: 1.25rem;
  list-style-type: disc;
}

.toc li {
  margin: 0.25rem 0;
}

.toc li.toc-h3 {
  margin-left: 1rem;
  font-size: 0.95em;
}

.toc a {
  text-decoration: none;
}

.toc a:hover {
  text-decoration: underline;
}


@media (max-width: 600px) {
  .toc {
    float: none;
    max-width: 100%;
    margin: 0 0 1.5rem 0;
  }
}

/* References section that floats alongside TOC */
.references-float {
  overflow: hidden; /* contain floated content */
}

.references-float h2 {
  margin-top: 0;
  font-size: 1.25rem;
}

.references-float table {
  font-size: 0.9em;
  width: 100%;
}

.references-float td, .references-float th {
  padding: 0.4rem 0.6rem;
  vertical-align: top;
}

.references-float td:first-child {
  white-space: nowrap;
  font-weight: bold;
  width: 1%;
}

@media (max-width: 600px) {
  .references-float table {
    font-size: 0.85em;
  }
}
</style>

<script>
(function() {
  // Run after DOM is ready
  function initTOC() {
    document.querySelectorAll('.toc').forEach(function(toc) {
      if (toc.dataset.initialized) return;
      toc.dataset.initialized = 'true';

      const tocList = toc.querySelector('.toc-list');
      if (!tocList) return;

      // Find the associated post-content (next sibling or parent's post-content)
      let article = toc.nextElementSibling;
      while (article && !article.classList.contains('post-content')) {
        article = article.nextElementSibling;
      }
      // Fallback: look for .post-content in the document (single post page)
      if (!article) {
        article = document.querySelector('.post-content');
      }

      if (!article) {
        toc.style.display = 'none';
        return;
      }

      const headings = article.querySelectorAll('h2, h3');

      if (headings.length < 3) {
        toc.style.display = 'none';
        return;
      }

      const tocId = toc.dataset.tocId || Math.random().toString(36).substr(2, 9);

      headings.forEach(function(heading, index) {
        // Add unique ID if missing
        if (!heading.id) {
          heading.id = 'toc-' + tocId + '-heading-' + index;
        }

        const li = document.createElement('li');
        li.className = 'toc-' + heading.tagName.toLowerCase();

        const a = document.createElement('a');
        a.href = '#' + heading.id;
        a.textContent = heading.textContent;

        li.appendChild(a);
        tocList.appendChild(li);
      });
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initTOC);
  } else {
    initTOC();
  }
})();
</script>
<div class="post-content e-content" itemprop="articleBody">
    <p><img src="/assets/images/posts/block-brackets.png" class="post-marker no-invert" alt="" /></p>

<p>JSON is everywhere. APIs. Logs. Databases. Configuration files. But it’s not alone. A whole ecosystem of formats exists—each optimizing for different tradeoffs.</p>

<p>This post expands on the <a href="https://www.youtube.com/shorts/3ezjk1CnZEU">JSON et al</a> short, providing technical depth on each format: when it was created, where it’s specified, and what problems it solves.</p>

<hr />

<h2 id="the-tradeoff-triangle">The Tradeoff Triangle</h2>

<p>Before diving in, understand the fundamental constraint. Data formats balance three competing goals:</p>

<table>
  <thead>
    <tr>
      <th>Goal</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Human Readability</strong></td>
      <td>Can a developer read and edit it directly?</td>
    </tr>
    <tr>
      <td><strong>Compactness</strong></td>
      <td>How many bytes does it take to represent data?</td>
    </tr>
    <tr>
      <td><strong>Query Performance</strong></td>
      <td>How fast can you access specific fields?</td>
    </tr>
  </tbody>
</table>

<p>You usually only get two. JSON optimizes readability. Protobuf optimizes compactness. JSONB optimizes query performance. No format wins everywhere.</p>

<hr />

<h2 id="json-the-ubiquitous-baseline">JSON: The Ubiquitous Baseline</h2>

<p><strong>Created:</strong> 2001 (discovered/formalized by Douglas Crockford)
<strong>Specification:</strong> <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-404/">ECMA-404</a> (2013), <a href="https://datatracker.ietf.org/doc/html/rfc8259">RFC 8259</a> (2017)
<strong>File Extension:</strong> <code class="language-plaintext highlighter-rouge">.json</code></p>

<p>JSON (JavaScript Object Notation) emerged from JavaScript’s object literal syntax but became language-agnostic. Crockford didn’t invent it—he “discovered” it already existing in JavaScript and formalized the specification.</p>

<h3 id="technical-details">Technical Details</h3>

<ul>
  <li><strong>Encoding:</strong> UTF-8 text (UTF-16/32 allowed but rare)</li>
  <li><strong>Data Types:</strong> Objects <code class="language-plaintext highlighter-rouge">{}</code>, arrays <code class="language-plaintext highlighter-rouge">[]</code>, strings, numbers, booleans, <code class="language-plaintext highlighter-rouge">null</code></li>
  <li><strong>Schema:</strong> None required</li>
  <li><strong>Comments:</strong> Not allowed in strict JSON</li>
</ul>

<h3 id="strengths">Strengths</h3>

<ul>
  <li>Universal parser support (every language has one)</li>
  <li>Human readable without tools</li>
  <li>Web-native (JavaScript parses it natively)</li>
  <li>Simple specification (fits on a business card)</li>
</ul>

<h3 id="weaknesses">Weaknesses</h3>

<ul>
  <li>Verbose (field names repeated for every object)</li>
  <li>No binary data type (must base64-encode)</li>
  <li>No comments (frustrating for config files)</li>
  <li>Parsing overhead (tokenization + string decoding every time)</li>
</ul>

<h3 id="eli5">ELI5</h3>

<p>Like typing a long email instead of sending a terse text. Every message spells everything out—clear, but verbose.</p>

<h3 id="when-to-use">When to Use</h3>

<p>REST APIs, configuration (when comments aren’t needed), data interchange between systems, anywhere human readability matters more than efficiency.</p>

<hr />

<h2 id="jsonl--ndjson-streaming-json">JSONL / NDJSON: Streaming JSON</h2>

<p><strong>Created:</strong> ~2013 (formalized)
<strong>Specification:</strong> <a href="https://jsonlines.org/">JSON Lines</a>, <a href="http://ndjsonspec.org/">NDJSON</a>
<strong>File Extension:</strong> <code class="language-plaintext highlighter-rouge">.jsonl</code>, <code class="language-plaintext highlighter-rouge">.ndjson</code></p>

<p>JSONL (JSON Lines) and NDJSON (Newline-Delimited JSON) are the same concept: one valid JSON object per line, separated by newlines.</p>

<h3 id="technical-details-1">Technical Details</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{"name": "Alice", "score": 95}
{"name": "Bob", "score": 87}
{"name": "Carol", "score": 92}
</code></pre></div></div>

<p>No wrapping array. Each line is independently parseable.</p>

<h3 id="strengths-1">Strengths</h3>

<ul>
  <li><strong>Streaming:</strong> Process line-by-line without loading entire file</li>
  <li><strong>Append-only:</strong> Add records without rewriting the file</li>
  <li><strong>Parallel processing:</strong> Split by line, distribute to workers</li>
  <li><strong>Fault-tolerant:</strong> One corrupt line doesn’t invalidate the file</li>
</ul>

<h3 id="weaknesses-1">Weaknesses</h3>

<ul>
  <li>Not valid JSON (can’t parse with standard JSON parser)</li>
  <li>Still text-based (same verbosity as JSON)</li>
  <li>No random access by index</li>
</ul>

<h3 id="eli5-1">ELI5</h3>

<p>Like removing one comma per line to save some typing. Each line is self-contained, so you can grab and process them one at a time.</p>

<h3 id="when-to-use-1">When to Use</h3>

<p>Log files, big data pipelines (Spark, Pandas), ML datasets, event streams, anywhere you need to process records incrementally.</p>

<hr />

<h2 id="jsonb-binary-json-for-databases">JSONB: Binary JSON for Databases</h2>

<p><strong>Created:</strong> 2014 (PostgreSQL 9.4)
<strong>Specification:</strong> Implementation-specific (no universal standard)
<strong>Storage:</strong> Database column type</p>

<p>JSONB isn’t a file format—it’s a database storage optimization. PostgreSQL’s JSONB differs from MongoDB’s BSON, which differs from other implementations.</p>

<h3 id="postgresql-jsonb-details">PostgreSQL JSONB Details</h3>

<ul>
  <li><strong>Parsed once:</strong> Text converted to binary on INSERT</li>
  <li><strong>Keys sorted:</strong> Deterministic ordering for indexing</li>
  <li><strong>Duplicates removed:</strong> Last value wins</li>
  <li><strong>Offset table:</strong> O(log n) field lookup instead of O(n) text scanning</li>
</ul>

<h3 id="mongodb-bson">MongoDB BSON</h3>

<p><strong>Specification:</strong> <a href="https://bsonspec.org/">bsonspec.org</a></p>

<p>BSON (Binary JSON) is MongoDB’s serialization format. Unlike PostgreSQL’s JSONB, BSON is a standalone binary format:</p>

<ul>
  <li>Type-prefixed values</li>
  <li>Supports additional types (Date, Binary, ObjectId)</li>
  <li>Length-prefixed for fast skipping</li>
  <li>~10-15% smaller than JSON typically</li>
</ul>

<h3 id="strengths-2">Strengths</h3>

<ul>
  <li>Fast queries without re-parsing</li>
  <li>Indexable (GIN indexes on JSONB in PostgreSQL)</li>
  <li>Type coercion at storage time</li>
</ul>

<h3 id="weaknesses-2">Weaknesses</h3>

<ul>
  <li>Not portable (implementation-specific)</li>
  <li>Not human-readable</li>
  <li>INSERT overhead (parsing cost upfront)</li>
</ul>

<h3 id="eli5-2">ELI5</h3>

<p>Instead of cooking from scratch every time, you heat a pre-made meal. The prep work happens once (on INSERT), so serving (queries) is fast.</p>

<h3 id="when-to-use-2">When to Use</h3>

<p>Database storage where you query into JSON structures. PostgreSQL JSONB + GIN indexes enable fast <code class="language-plaintext highlighter-rouge">@&gt;</code> containment queries.</p>

<hr />

<h2 id="protocol-buffers-googles-schema-first-format">Protocol Buffers: Google’s Schema-First Format</h2>

<p><strong>Created:</strong> 2001 (internal Google), 2008 (open-sourced)
<strong>Specification:</strong> <a href="https://developers.google.com/protocol-buffers/docs/proto3">developers.google.com/protocol-buffers</a>
<strong>File Extension:</strong> <code class="language-plaintext highlighter-rouge">.proto</code> (schema), binary wire format</p>

<p>Protocol Buffers (Protobuf) is Google’s language-neutral, schema-required serialization format. It powers gRPC.</p>

<h3 id="technical-details-2">Technical Details</h3>

<p>Schema definition:</p>
<div class="language-protobuf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">message</span> <span class="nc">Sensor</span> <span class="p">{</span>
  <span class="kt">int32</span> <span class="na">temperature</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int32</span> <span class="na">humidity</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Wire format uses field numbers, not names:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Field 1: 72
Field 2: 40
</code></pre></div></div>

<h3 id="key-features">Key Features</h3>

<ul>
  <li><strong>Varint encoding:</strong> Small integers use fewer bytes</li>
  <li><strong>Field numbers:</strong> Enable backward compatibility</li>
  <li><strong>Code generation:</strong> <code class="language-plaintext highlighter-rouge">.proto</code> → language-specific classes</li>
  <li><strong>No self-description:</strong> Receiver must know schema</li>
</ul>

<h3 id="strengths-3">Strengths</h3>

<ul>
  <li>Extremely compact (3-10x smaller than JSON typically)</li>
  <li>Fast serialization/deserialization</li>
  <li>Strong versioning semantics</li>
  <li>gRPC integration</li>
</ul>

<h3 id="weaknesses-3">Weaknesses</h3>

<ul>
  <li>Requires schema agreement</li>
  <li>Not human-readable</li>
  <li>Tooling required for debugging</li>
  <li>Schema evolution has rules</li>
</ul>

<h3 id="eli5-3">ELI5</h3>

<p>Everyone agrees upfront what “field 1” means. You don’t waste space spelling out “temperature”—you just send the number 1 and the value. Both sides know the code.</p>

<h3 id="when-to-use-3">When to Use</h3>

<p>Microservices (gRPC), internal APIs, anywhere bandwidth and latency matter more than debuggability.</p>

<hr />

<h2 id="asn1-the-telecom-veteran">ASN.1: The Telecom Veteran</h2>

<p><strong>Created:</strong> 1984 (ITU-T X.208)
<strong>Specification:</strong> <a href="https://www.itu.int/rec/T-REC-X.680-X.683">ITU-T X.680-X.683</a>
<strong>Encoding Rules:</strong> BER, DER, PER, XER, and more</p>

<p>ASN.1 (Abstract Syntax Notation One) predates all modern formats. It defines both schema and encoding, with multiple encoding rules for different use cases.</p>

<h3 id="encoding-rules-comparison">Encoding Rules Comparison</h3>

<table>
  <thead>
    <tr>
      <th>Rule</th>
      <th>Use Case</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>BER</strong> (Basic Encoding Rules)</td>
      <td>Flexible, general purpose</td>
    </tr>
    <tr>
      <td><strong>DER</strong> (Distinguished Encoding Rules)</td>
      <td>Deterministic, for cryptography</td>
    </tr>
    <tr>
      <td><strong>PER</strong> (Packed Encoding Rules)</td>
      <td>Most compact, for bandwidth-constrained</td>
    </tr>
    <tr>
      <td><strong>XER</strong> (XML Encoding Rules)</td>
      <td>XML-based, for interop</td>
    </tr>
  </tbody>
</table>

<h3 id="where-you-see-asn1">Where You See ASN.1</h3>

<ul>
  <li><strong>X.509 certificates</strong> (SSL/TLS certs are DER-encoded ASN.1)</li>
  <li><strong>LDAP</strong> (directory services)</li>
  <li><strong>SNMP</strong> (network management)</li>
  <li><strong>Telecom protocols</strong> (SS7, GSM, LTE)</li>
</ul>

<h3 id="strengths-4">Strengths</h3>

<ul>
  <li>Bit-level precision</li>
  <li>Proven over 40 years</li>
  <li>Multiple encoding options</li>
  <li>Formal verification possible</li>
</ul>

<h3 id="weaknesses-4">Weaknesses</h3>

<ul>
  <li>Complex specification</li>
  <li>Steep learning curve</li>
  <li>Tooling can be expensive</li>
  <li>Security vulnerabilities in parsers (historically)</li>
</ul>

<h3 id="eli5-4">ELI5</h3>

<p>Same idea as Protobuf—everyone agrees upfront what each field number means. ASN.1 just got there 20 years earlier and handles even more edge cases.</p>

<h3 id="when-to-use-4">When to Use</h3>

<p>You probably won’t choose ASN.1 for new projects. You’ll encounter it in cryptography, certificates, and legacy telecom systems.</p>

<hr />

<h2 id="yaml-human-friendly-configuration">YAML: Human-Friendly Configuration</h2>

<p><strong>Created:</strong> 2001 (Clark Evans, Ingy döt Net, Oren Ben-Kiki)
<strong>Specification:</strong> <a href="https://yaml.org/spec/1.2.2/">yaml.org/spec/1.2.2</a>
<strong>File Extension:</strong> <code class="language-plaintext highlighter-rouge">.yaml</code>, <code class="language-plaintext highlighter-rouge">.yml</code></p>

<p>YAML (YAML Ain’t Markup Language) prioritizes human readability. It’s a superset of JSON—any valid JSON is valid YAML.</p>

<h3 id="technical-details-3">Technical Details</h3>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Comments allowed!</span>
<span class="na">server</span><span class="pi">:</span>
  <span class="na">host</span><span class="pi">:</span> <span class="s">localhost</span>
  <span class="na">port</span><span class="pi">:</span> <span class="m">8080</span>
  <span class="na">features</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">auth</span>
    <span class="pi">-</span> <span class="s">logging</span>
</code></pre></div></div>

<h3 id="key-features-1">Key Features</h3>

<ul>
  <li><strong>Indentation-based:</strong> Whitespace matters</li>
  <li><strong>Comments:</strong> <code class="language-plaintext highlighter-rouge">#</code> for single-line</li>
  <li><strong>Anchors/aliases:</strong> <code class="language-plaintext highlighter-rouge">&amp;name</code> and <code class="language-plaintext highlighter-rouge">*name</code> for references</li>
  <li><strong>Multiple documents:</strong> <code class="language-plaintext highlighter-rouge">---</code> separator</li>
</ul>

<h3 id="strengths-5">Strengths</h3>

<ul>
  <li>Highly readable</li>
  <li>Comments supported</li>
  <li>Multi-line strings without escaping</li>
  <li>Complex data structures</li>
</ul>

<h3 id="weaknesses-5">Weaknesses</h3>

<ul>
  <li><strong>“Norway problem”:</strong> <code class="language-plaintext highlighter-rouge">NO</code> parses as boolean <code class="language-plaintext highlighter-rouge">false</code></li>
  <li>Whitespace sensitivity causes errors</li>
  <li>Multiple ways to express same data</li>
  <li>Security concerns (arbitrary code execution in some parsers)</li>
</ul>

<h3 id="eli5-5">ELI5</h3>

<p>Optimized for clarity, not bandwidth. YAML is for humans editing config files—not for machines exchanging data over networks.</p>

<h3 id="when-to-use-5">When to Use</h3>

<p>Configuration files (Kubernetes, Docker Compose, CI/CD), anywhere humans edit data directly and comments help.</p>

<hr />

<h2 id="toml-minimal-configuration">TOML: Minimal Configuration</h2>

<p><strong>Created:</strong> 2013 (Tom Preston-Werner)
<strong>Specification:</strong> <a href="https://toml.io/en/v1.0.0">toml.io</a>
<strong>File Extension:</strong> <code class="language-plaintext highlighter-rouge">.toml</code></p>

<p>TOML (Tom’s Obvious Minimal Language) emerged as a reaction to YAML’s complexity. It’s used by Rust (Cargo.toml), Python (pyproject.toml), and others.</p>

<h3 id="technical-details-4">Technical Details</h3>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">[</span><span class="n">server</span><span class="k">]</span>
<span class="n">host</span> <span class="o">=</span><span class="w"> </span><span class="s">"localhost"</span>
<span class="n">port</span> <span class="o">=</span><span class="w"> </span><span class="mi">8080</span>

<span class="k">[</span><span class="n">server</span><span class="k">.</span><span class="n">features</span><span class="k">]</span>
<span class="n">auth</span> <span class="o">=</span><span class="w"> </span><span class="kc">true</span>
<span class="n">logging</span> <span class="o">=</span><span class="w"> </span><span class="kc">true</span>
</code></pre></div></div>

<h3 id="key-features-2">Key Features</h3>

<ul>
  <li><strong>Explicit typing:</strong> Dates, times, arrays have clear syntax</li>
  <li><strong>Sections:</strong> <code class="language-plaintext highlighter-rouge">[section]</code> and <code class="language-plaintext highlighter-rouge">[section.subsection]</code></li>
  <li><strong>No anchors:</strong> Intentionally simpler than YAML</li>
  <li><strong>Deterministic:</strong> Same data = same representation</li>
</ul>

<h3 id="strengths-6">Strengths</h3>

<ul>
  <li>Easy to read and write</li>
  <li>Unambiguous parsing</li>
  <li>Clear error messages</li>
  <li>Growing ecosystem support</li>
</ul>

<h3 id="weaknesses-6">Weaknesses</h3>

<ul>
  <li>Less expressive than YAML</li>
  <li>Nested structures can be verbose</li>
  <li>Smaller ecosystem than JSON/YAML</li>
</ul>

<h3 id="eli5-6">ELI5</h3>

<p>Same goal as YAML—clarity for humans, not bandwidth for machines—but with stricter rules so you make fewer mistakes.</p>

<h3 id="when-to-use-6">When to Use</h3>

<p>Configuration files where YAML’s complexity isn’t needed. Rust projects (mandatory). Python packaging (pyproject.toml).</p>

<hr />

<h2 id="toon-token-optimized-for-llms">TOON: Token-Optimized for LLMs</h2>

<p><strong>Created:</strong> October 2025 (toon-format organization)
<strong>Specification:</strong> <a href="https://github.com/toon-format/toon">github.com/toon-format/toon</a> (v3.0)
<strong>File Extension:</strong> <code class="language-plaintext highlighter-rouge">.toon</code>
<strong>Media Type:</strong> <code class="language-plaintext highlighter-rouge">text/toon</code> (provisional)</p>

<p>TOON (Token Oriented Object Notation) is the newest format in this list, designed specifically for LLM input. It’s a lossless representation of JSON that minimizes tokens.</p>

<h3 id="technical-details-5">Technical Details</h3>

<p>TOON combines YAML-style indentation for nested objects with CSV-like tabular layouts for uniform arrays:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>users[2]{name,age}:
Alice,25
Bob,30
</code></pre></div></div>

<p>Equivalent JSON:</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"users"</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Alice"</span><span class="p">,</span><span class="w"> </span><span class="nl">"age"</span><span class="p">:</span><span class="w"> </span><span class="mi">25</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Bob"</span><span class="p">,</span><span class="w"> </span><span class="nl">"age"</span><span class="p">:</span><span class="w"> </span><span class="mi">30</span><span class="p">}]}</span><span class="w">
</span></code></pre></div></div>

<h3 id="key-features-3">Key Features</h3>

<ul>
  <li><strong>Header-based:</strong> Field names declared once, values follow</li>
  <li><strong>40% fewer tokens:</strong> Than equivalent JSON typically</li>
  <li><strong>Lossless:</strong> Round-trips to JSON perfectly</li>
  <li><strong>UTF-8 always:</strong> No encoding ambiguity</li>
</ul>

<h3 id="performance">Performance</h3>

<table>
  <thead>
    <tr>
      <th>Metric</th>
      <th>JSON</th>
      <th>TOON</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Accuracy</td>
      <td>69.7%</td>
      <td>73.9%</td>
    </tr>
    <tr>
      <td>Efficiency (acc/1K tokens)</td>
      <td>15.3</td>
      <td>26.9</td>
    </tr>
  </tbody>
</table>

<h3 id="strengths-7">Strengths</h3>

<ul>
  <li>Significant token savings at scale</li>
  <li>Better context window utilization</li>
  <li>Lower API costs for LLM applications</li>
  <li>Human-readable (unlike binary formats)</li>
</ul>

<h3 id="weaknesses-7">Weaknesses</h3>

<ul>
  <li>New format (October 2025)</li>
  <li>Limited tooling compared to JSON</li>
  <li>Requires conversion layer for existing systems</li>
  <li>Not yet widely adopted</li>
</ul>

<h3 id="eli5-7">ELI5</h3>

<p>Like having one header row for each column in a table instead of repeating the column name for every single row. You declare field names once, then just list the values.</p>

<h3 id="when-to-use-7">When to Use</h3>

<p>LLM prompts with structured data, RAG applications, anywhere token efficiency matters. Especially useful for large datasets with uniform object arrays.</p>

<h3 id="implementations">Implementations</h3>

<ul>
  <li><strong>TypeScript:</strong> Reference implementation</li>
  <li><strong>Python:</strong> <a href="https://pypi.org/project/toons/">toons</a> (Rust-based, fast)</li>
  <li><strong>Go, Rust, .NET:</strong> Available via toon-format org</li>
</ul>

<hr />

<h2 id="alternatives-not-in-the-video">Alternatives Not in the Video</h2>

<h3 id="messagepack">MessagePack</h3>

<p><strong>Created:</strong> 2008 (Sadayuki Furuhashi)
<strong>Specification:</strong> <a href="https://msgpack.org/">msgpack.org</a></p>

<p>Binary JSON without schema. Type-prefixed values, efficient numeric encoding.</p>

<p><strong>Use when:</strong> You want JSON semantics but smaller/faster.</p>

<h3 id="cbor">CBOR</h3>

<p><strong>Created:</strong> 2013 (IETF)
<strong>Specification:</strong> <a href="https://datatracker.ietf.org/doc/html/rfc8949">RFC 8949</a></p>

<p>Concise Binary Object Representation. Designed for constrained environments (IoT).</p>

<p><strong>Use when:</strong> Resource-constrained devices, need a standard binary format.</p>

<h3 id="apache-avro">Apache Avro</h3>

<p><strong>Created:</strong> 2009 (Apache, Doug Cutting)
<strong>Specification:</strong> <a href="https://avro.apache.org/docs/current/spec.html">avro.apache.org</a></p>

<p>Schema-based, row-oriented binary format. Schema embedded or stored separately. Strong schema evolution support.</p>

<p><strong>Use when:</strong> Big data pipelines (Hadoop, Kafka), schema evolution is critical.</p>

<h3 id="apache-parquet">Apache Parquet</h3>

<p><strong>Created:</strong> 2013 (Twitter + Cloudera)
<strong>Specification:</strong> <a href="https://parquet.apache.org/docs/file-format/">parquet.apache.org</a></p>

<p>Columnar storage format. Not for serialization—for analytics storage.</p>

<p><strong>Use when:</strong> Large-scale analytics, data warehousing, Spark/Pandas workflows.</p>

<h3 id="capn-proto">Cap’n Proto</h3>

<p><strong>Created:</strong> 2013 (Kenton Varda, ex-Protobuf author)
<strong>Specification:</strong> <a href="https://capnproto.org/">capnproto.org</a></p>

<p>Zero-copy serialization. The serialized form <em>is</em> the in-memory form.</p>

<p><strong>Use when:</strong> Extreme performance requirements, inter-process communication.</p>

<h3 id="flatbuffers">FlatBuffers</h3>

<p><strong>Created:</strong> 2014 (Google)
<strong>Specification:</strong> <a href="https://google.github.io/flatbuffers/">google.github.io/flatbuffers</a></p>

<p>Zero-copy like Cap’n Proto but with better tooling. Used in games, mobile.</p>

<p><strong>Use when:</strong> Games, mobile apps, anywhere memory allocation matters.</p>

<hr />

<h2 id="quick-reference">Quick Reference</h2>

<table>
  <thead>
    <tr>
      <th>Format</th>
      <th>Year</th>
      <th>Schema</th>
      <th>Binary</th>
      <th>Human-Readable</th>
      <th>Best For</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>JSON</td>
      <td>2001</td>
      <td>No</td>
      <td>No</td>
      <td>Yes</td>
      <td>APIs, interchange</td>
    </tr>
    <tr>
      <td>JSONL</td>
      <td>2013</td>
      <td>No</td>
      <td>No</td>
      <td>Yes</td>
      <td>Logs, streaming</td>
    </tr>
    <tr>
      <td>JSONB</td>
      <td>2014</td>
      <td>No</td>
      <td>Yes</td>
      <td>No</td>
      <td>Database queries</td>
    </tr>
    <tr>
      <td>Protobuf</td>
      <td>2008</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>No</td>
      <td>Microservices</td>
    </tr>
    <tr>
      <td>ASN.1</td>
      <td>1984</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>No</td>
      <td>Crypto, telecom</td>
    </tr>
    <tr>
      <td>YAML</td>
      <td>2001</td>
      <td>No</td>
      <td>No</td>
      <td>Yes</td>
      <td>Config files</td>
    </tr>
    <tr>
      <td>TOML</td>
      <td>2013</td>
      <td>No</td>
      <td>No</td>
      <td>Yes</td>
      <td>Simple config</td>
    </tr>
    <tr>
      <td>TOON</td>
      <td>2025</td>
      <td>No</td>
      <td>No</td>
      <td>Yes</td>
      <td>LLM prompts</td>
    </tr>
    <tr>
      <td>MessagePack</td>
      <td>2008</td>
      <td>No</td>
      <td>Yes</td>
      <td>No</td>
      <td>Fast JSON</td>
    </tr>
    <tr>
      <td>CBOR</td>
      <td>2013</td>
      <td>Optional</td>
      <td>Yes</td>
      <td>No</td>
      <td>IoT</td>
    </tr>
    <tr>
      <td>Avro</td>
      <td>2009</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>No</td>
      <td>Big data</td>
    </tr>
  </tbody>
</table>

<hr />

<h2 id="key-takeaways">Key Takeaways</h2>

<ol>
  <li>
    <p><strong>No “best” format exists.</strong> Each optimizes for different constraints.</p>
  </li>
  <li>
    <p><strong>Text formats favor humans.</strong> JSON, YAML, TOML prioritize readability over efficiency.</p>
  </li>
  <li>
    <p><strong>Binary formats favor machines.</strong> Protobuf, MessagePack, CBOR prioritize compactness and speed.</p>
  </li>
  <li>
    <p><strong>Schema formats favor correctness.</strong> Protobuf, Avro, ASN.1 catch errors at compile time.</p>
  </li>
  <li>
    <p><strong>The tradeoff triangle is real.</strong> Readability, compactness, query performance—pick two.</p>
  </li>
</ol>

<p>The question isn’t “which format wins?” The question is: what problem are you solving?</p>

<hr />

<h2 id="resources">Resources</h2>

<ul>
  <li><a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-404/">ECMA-404 JSON Specification</a></li>
  <li><a href="https://datatracker.ietf.org/doc/html/rfc8259">RFC 8259 JSON</a></li>
  <li><a href="https://jsonlines.org/">JSON Lines Specification</a></li>
  <li><a href="https://www.postgresql.org/docs/current/datatype-json.html">PostgreSQL JSONB Documentation</a></li>
  <li><a href="https://developers.google.com/protocol-buffers">Protocol Buffers Documentation</a></li>
  <li><a href="https://yaml.org/spec/1.2.2/">YAML 1.2.2 Specification</a></li>
  <li><a href="https://toml.io/en/v1.0.0">TOML v1.0.0 Specification</a></li>
  <li><a href="https://datatracker.ietf.org/doc/html/rfc8949">RFC 8949 CBOR</a></li>
  <li><a href="https://github.com/msgpack/msgpack/blob/master/spec.md">MessagePack Specification</a></li>
  <li><a href="https://avro.apache.org/docs/current/spec.html">Apache Avro Specification</a></li>
</ul>

<hr />

<p><em>Data formats are design decisions. Choose based on your constraints, not trends.</em></p>

<p><em>Questions? Find me on <a href="https://www.youtube.com/@SoftwareWrighter">YouTube @SoftwareWrighter</a>.</em></p>

  </div><div class="series-nav">
    <p><em>Part 2 of the General Technology series. <a href="/series/#general-technology">View all parts</a></em></p>
  </div>





<div class="youtube-embed-container" id="yt-container-3ezjk1CnZEU">
  <h3>Watch the Video</h3>
  <div class="youtube-embed-wrapper">
    <iframe
      id="yt-player-3ezjk1CnZEU"
      src="https://www.youtube.com/embed/3ezjk1CnZEU?enablejsapi=1&mute=1&autoplay=1&cc_load_policy=1"
      title="YouTube video player"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      allowfullscreen
      loading="lazy">
    </iframe>
  </div>
  <p class="youtube-embed-note">Unmute to hear narration.</p>
</div>

<style>
.youtube-embed-container {
  margin: 2rem auto;
  padding: 1.5rem;
  background: var(--code-background-color, #f5f5f5);
  border-radius: 8px;
  width: 66%;
}

.youtube-embed-container h3 {
  margin-top: 0;
  margin-bottom: 1rem;
}

.youtube-embed-wrapper {
  position: relative;
  width: 100%;
  padding-bottom: 56.25%; /* 16:9 aspect ratio */
  height: 0;
  overflow: hidden;
}

.youtube-embed-wrapper iframe {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border-radius: 4px;
}

.youtube-embed-note {
  margin-top: 0.75rem;
  margin-bottom: 0;
  font-size: 0.85rem;
  color: var(--text-muted-color, #666);
  font-style: italic;
}
</style>

<script>
(function() {
  const containerId = 'yt-container-3ezjk1CnZEU';
  const playerId = 'yt-player-3ezjk1CnZEU';

  // Load YouTube IFrame API if not already loaded
  if (!window.YT) {
    const tag = document.createElement('script');
    tag.src = 'https://www.youtube.com/iframe_api';
    const firstScriptTag = document.getElementsByTagName('script')[0];
    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
  }

  let player;
  let isPlaying = false;

  function onYouTubeIframeAPIReady() {
    player = new YT.Player(playerId, {
      events: {
        'onReady': onPlayerReady
      }
    });
  }

  function onPlayerReady(event) {
    setupIntersectionObserver();
  }

  function setupIntersectionObserver() {
    const container = document.getElementById(containerId);
    if (!container) return;

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && entry.intersectionRatio >= 0.5) {
          if (!isPlaying && player && player.playVideo) {
            player.playVideo();
            isPlaying = true;
          }
        } else {
          if (isPlaying && player && player.pauseVideo) {
            player.pauseVideo();
            isPlaying = false;
          }
        }
      });
    }, {
      threshold: [0.5]
    });

    observer.observe(container);
  }

  // Handle API ready callback
  if (window.YT && window.YT.Player) {
    onYouTubeIframeAPIReady();
  } else {
    window.onYouTubeIframeAPIReady = window.onYouTubeIframeAPIReady || onYouTubeIframeAPIReady;
    // Queue multiple players if needed
    const existingCallback = window.onYouTubeIframeAPIReady;
    window.onYouTubeIframeAPIReady = function() {
      if (existingCallback) existingCallback();
      onYouTubeIframeAPIReady();
    };
  }
})();
</script>

<img src="/assets/images/site/post-separator.png" class="post-separator" alt=""><a class="u-url" href="/2026/02/21/json-et-al-data-serialization-formats/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Software Wrighter Lab Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Mike Wright</li><li><a class="u-email" href="mailto:"></a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/softwarewrighter"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">softwarewrighter</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>AI coding agents, systems programming, and practical machine learning</p>
      </div>
    </div>

    <div class="footer-copyright">
      <p>Copyright &copy; 2026 Michael A. Wright</p>
    </div>

  </div>

  <button id="scroll-to-top" aria-label="Scroll to top" title="Scroll to top">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="18 15 12 9 6 15"></polyline>
    </svg>
  </button>

  <style>
  #scroll-to-top {
    position: fixed;
    bottom: 2rem;
    right: 2rem;
    width: 44px;
    height: 44px;
    border-radius: 50%;
    border: none;
    background: var(--brand-color, #2a7ae2);
    color: white;
    cursor: pointer;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s, visibility 0.3s, transform 0.2s;
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
  }

  #scroll-to-top:hover {
    transform: scale(1.1);
  }

  #scroll-to-top.visible {
    opacity: 1;
    visibility: visible;
  }

  #scroll-to-top svg {
    width: 24px;
    height: 24px;
  }
  </style>

  <script>
  (function() {
    const btn = document.getElementById('scroll-to-top');
    if (!btn) return;

    window.addEventListener('scroll', function() {
      if (window.scrollY > 300) {
        btn.classList.add('visible');
      } else {
        btn.classList.remove('visible');
      }
    });

    btn.addEventListener('click', function() {
      window.scrollTo({ top: 0, behavior: 'smooth' });
    });
  })();
  </script>

</footer>
</body>

</html>
